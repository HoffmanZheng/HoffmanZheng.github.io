<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Database on 人间一场大梦</title>
    <link>https://nervousorange.github.io/tags/database/</link>
    <description>Recent content in Database on 人间一场大梦</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 10 Dec 2020 13:19:47 +0100</lastBuildDate>
    
	<atom:link href="https://nervousorange.github.io/tags/database/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Database：高性能 MySQL - 索引</title>
      <link>https://nervousorange.github.io/2020/database-index/</link>
      <pubDate>Thu, 10 Dec 2020 13:19:47 +0100</pubDate>
      
      <guid>https://nervousorange.github.io/2020/database-index/</guid>
      <description>在之前的博客 Database：MySQL 数据库 我已经介绍了自己对 MySQL 的一些基本认识，包括它的存储引擎、数据存储结构、索引及事务等，本篇及之后的一篇将着眼于 MySQL 的性能深入探究。
索引是存储引擎用于快速找到记录的一种数据结构，它对良好的性能非常关键，它能让 MySQL 以最高效、扫描行数最少的方式找到需要的记录。本篇将结合 《高性能 MySQL》 第五章 创建高性能的索引 的内容深入分析，如何使用索引来提高 MySQL 数据库的查询性能。
本篇使用和书本相同的 MySQL 5.5 版本，使用 官方提供的测试数据库，通过 MySQL Workbench 导入 dump 数据。
索引的类型 B-Tree 索引 在 Database：MySQL 数据库 我已经介绍过 B-Tree 索引了，这里谈下一个面试常问的问题：为什么 MySQL 的索引要使用 B+ 树而不是其他的树形结构，比如 B 树？
 B 树是一颗多叉树，相比于二叉树在相等数据量的情况下，树的高度更低，可以减少查询时的 I/O 次数。 B+ 树相比 B 树，只有叶子节点存放数据，非叶子节点只存储索引，这样就能在一张 16kb 的非叶子节点数据页中 存储更多的指针，降低树的高度，减少查询 I/O 次数，提高查询性能。 计算机层面，一次 I/O 就是磁盘的 寻道、寻点、拷贝到内存 三步操作。寻道是磁臂移动到指定磁道所需要的时间，一般在 5ms 以下；寻点是从磁道中找到数据存在的那个点，平均为半圈时间，在一个 7200 转/min 的磁盘，大概是 60,000 / 7200 / 2 = 4.</description>
    </item>
    
    <item>
      <title>Database：MySQL 数据库</title>
      <link>https://nervousorange.github.io/2020/database-mysql/</link>
      <pubDate>Wed, 04 Mar 2020 13:19:47 +0100</pubDate>
      
      <guid>https://nervousorange.github.io/2020/database-mysql/</guid>
      <description>本篇介绍 MySQL 数据库，主要内容有：MySQL 常见的两种存储引擎（InnoDB 与 MyISAM）、数据库存储结构与索引原理以及数据库事务隔离级别、读写锁等。
存储引擎 MyISAM 与 InnoDB 区别：   InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；
  InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；（主键是能确定一条记录的唯一标识，外键用于与另一张表的关联）
  InnoDB 是聚集索引，MyISAM 是 非聚集索引（堆表）。
 聚集索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询（回表），先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。 聚集索引的顺序就是数据的物理存储顺序，所以 insert 和 update 操作可能会导致数据重排，而导致性能下降。 而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。    InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；（MyISAM 查询效率更高，且支持全文索引）
  InnoDB 最小的锁粒度是 行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</description>
    </item>
    
  </channel>
</rss>