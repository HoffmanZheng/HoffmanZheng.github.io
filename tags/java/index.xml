<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java - Tag - 人间一场大梦</title>
    <link>https://hoffmanzheng.github.io/tags/java/</link>
    <description>人间一场大梦</description>
    <generator>Hugo 0.156.0 &amp; FixIt v0.4.3-20260130042349-e23a50d7</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 02 Apr 2021 13:19:47 +0100</lastBuildDate>
    <atom:link href="https://hoffmanzheng.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java：并发编程实战</title>
      <link>https://hoffmanzheng.github.io/2021/java-concurrency/</link>
      <pubDate>Fri, 02 Apr 2021 13:19:47 +0100</pubDate>
      <guid>https://hoffmanzheng.github.io/2021/java-concurrency/</guid>
      <category domain="https://hoffmanzheng.github.io/categories/reading-notes/">Reading Notes</category>
      <description>&lt;p&gt;在 &lt;a href=&#34;http://www.mooreslaw.org&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;摩尔定律&lt;/a&gt; 失效的今天，通过提高时钟频率来提升处理器的性能已变得越来越困难，如何高效地使用并发，充分发挥多核处理器的强大计算能力变得益发重要。操作系统的出现使得计算机可以每次运行多个程序，实现了 &lt;strong&gt;进程级别的并发&lt;/strong&gt;，操作系统为每个进程分配各自的资源（比如内存），不同的进程之间可以通过一些通信机制来交换数据，包括套接字、文件、共享内存等。&lt;/p&gt;&#xA;&lt;p&gt;线程的出现允许在同一个进程中同时存在 &lt;strong&gt;多个程序控制流&lt;/strong&gt;，它们共享进程中的资源，并且可以被同时调度到多个 CPU 上运行。多线程程序通过对多核处理器的充分利用来提升系统吞吐率，然而这却会引入更多的问题：指令重排、并发修改、死锁、饥饿、活锁、上下文切换、线程调度开销等。&lt;/p&gt;&#xA;&lt;p&gt;本篇将结合 &lt;a href=&#34;https://book.douban.com/subject/10484692/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;《Java 并发编程实战》&lt;/a&gt; 讲解在 Java 项目中如何利用线程来提高并发程序的吞吐量或响应性，如何确保并发程序的执行与预期一致，避免安全性和活跃性问题。&lt;/p&gt;&#xA;&lt;h1 class=&#34;heading-element&#34; id=&#34;并发任务的控制&#34;&gt;&lt;span&gt;并发任务的控制&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%b9%b6%e5%8f%91%e4%bb%bb%e5%8a%a1%e7%9a%84%e6%8e%a7%e5%88%b6&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&lt;p&gt;在设计并发程序时，第一步就是要找出清晰的 &lt;strong&gt;任务边界&lt;/strong&gt;，抽象出相互独立、可以并行执行的工作单元。大多数服务器应用程序都提供了一种自然的任务边界选择方式：以独立的客户请求为边界，主线程不断接收外部连接、&lt;strong&gt;分发请求&lt;/strong&gt;并创建一个新线程来处理请求，但这种方法存在一些缺陷：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java：异常处理与日志记录</title>
      <link>https://hoffmanzheng.github.io/2021/java-exception-log/</link>
      <pubDate>Wed, 24 Mar 2021 13:19:47 +0100</pubDate>
      <guid>https://hoffmanzheng.github.io/2021/java-exception-log/</guid>
      <category domain="https://hoffmanzheng.github.io/categories/study-notes/">Study Notes</category>
      <description>&lt;p&gt;在开发 Java 项目中通常依赖 Eclipse/IDEA 等集成开发工具的 Debug 调试来追踪解决 Bug，而在没有调试工具的测试、生产环境（一般也不允许远程调试）往往通过日志的轨迹 &lt;strong&gt;快速定位并解决线上问题&lt;/strong&gt;。 但如果日志输出不好，不仅无法辅助定位问题反而可能会影响到程序的运行性能和稳定性。&lt;/p&gt;&#xA;&lt;p&gt;本篇将结合 &lt;a href=&#34;https://developer.aliyun.com/topic/java20&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;阿里巴巴《Java 开发手册（嵩山版）》&lt;/a&gt;、 &lt;a href=&#34;https://logging.apache.org/log4j/2.x/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Log4j 2.x 官方文档&lt;/a&gt;、 &lt;a href=&#34;https://www.overops.com/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Takipi 日志相关文章&lt;/a&gt; 讲解在项目中如何优雅地处理异常以及高效且有效地记录日志。&lt;/p&gt;&#xA;&lt;h1 class=&#34;heading-element&#34; id=&#34;java-的异常处理&#34;&gt;&lt;span&gt;Java 的异常处理&lt;/span&gt;&#xA;  &lt;a href=&#34;#java-%e7%9a%84%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&lt;h3 class=&#34;heading-element&#34; id=&#34;错误码&#34;&gt;&lt;span&gt;错误码&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e9%94%99%e8%af%af%e7%a0%81&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://developer.aliyun.com/topic/java20&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;阿里巴巴《Java 开发手册（嵩山版）》&lt;/a&gt; 中有关错误码给出了以下几点指导：&lt;/p&gt;</description>
    </item>
    <item>
      <title>深入分析 ClassLoader 工作机制</title>
      <link>https://hoffmanzheng.github.io/2020/java-classloader/</link>
      <pubDate>Tue, 22 Sep 2020 09:19:47 +0100</pubDate>
      <guid>https://hoffmanzheng.github.io/2020/java-classloader/</guid>
      <category domain="https://hoffmanzheng.github.io/categories/reading-notes/">Reading Notes</category>
      <description>&lt;p&gt;Java 是个强类型的编程语言，一个变量的类型在编译时就已经决定了，就是最初声明它的类型， 如果想把它当成另一个类型来使用，需要先经过显式的类型转换，转换时可能会因为类型不符而抛出 &lt;code&gt;ClassCastException&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;本篇以 &lt;a href=&#34;https://book.douban.com/subject/25953851/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;《深入分析 Java Web 技术内幕》&lt;/a&gt; 第六章 深入分析 ClassLoader 工作机制 的内容为参考，讲解 Java 中的类型，类加载机制，类加载错误分析 等。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;java-中的类型&#34;&gt;&lt;span&gt;Java 中的类型&lt;/span&gt;&#xA;  &lt;a href=&#34;#java-%e4%b8%ad%e7%9a%84%e7%b1%bb%e5%9e%8b&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;如开篇所说，一个 Java 对象的类型在声明的时候就被确定了，但 Java 是面对对象的语言，有丰富的接口和抽象类，一个对象被传来传去的时候，可能就丢失了它的一些类型信息，但 Java 也像 C++ 那样是拥有 RTTI (Run-Time Type Identification) &lt;strong&gt;运行时类型识别&lt;/strong&gt; 特性的语言。在任何时刻，任何一个对象都清楚地知道自己的具体类型（可以通过反射获取）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Javac 编译原理与 class 文件结构</title>
      <link>https://hoffmanzheng.github.io/2020/java-compile/</link>
      <pubDate>Sat, 05 Sep 2020 09:19:47 +0100</pubDate>
      <guid>https://hoffmanzheng.github.io/2020/java-compile/</guid>
      <category domain="https://hoffmanzheng.github.io/categories/reading-notes/">Reading Notes</category>
      <description>&lt;p&gt;JVM 让 Java 成为了一次编译，到处运行，具有平台无关性的高级语言。要让 Java 代码跑在 JVM 中少不了 Javac 编译器，它把人类能理解的 Java 源代码语言翻译成 JVM 容易理解的字节码（将 .java 文件转换成 .class 文件）。某种意义上来说，Javac 编译器的存在使 Java 语言向开发者屏蔽了很多与机器相关的细节，JVM 使 Java 语言的执行和平台无关，这才成就了 Java 的繁荣。&lt;/p&gt;&#xA;&lt;p&gt;本篇以 &lt;a href=&#34;https://book.douban.com/subject/25953851/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;《深入分析 Java Web 技术内幕》&lt;/a&gt; 第四章 Javac 编译原理 及第五章 深入 class 文件结构 的内容为参考，讲解 Javac 编译器的基本结构，Javac 的工作原理，class 文件结构等。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;javac-编译器的基本结构&#34;&gt;&lt;span&gt;Javac 编译器的基本结构&lt;/span&gt;&#xA;  &lt;a href=&#34;#javac-%e7%bc%96%e8%af%91%e5%99%a8%e7%9a%84%e5%9f%ba%e6%9c%ac%e7%bb%93%e6%9e%84&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/compile.jpg&#39; alt=&#34;/images/compile.jpg&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>深入分析 Java Web 中的中文编码问题</title>
      <link>https://hoffmanzheng.github.io/2020/java-encode/</link>
      <pubDate>Sat, 29 Aug 2020 09:19:47 +0100</pubDate>
      <guid>https://hoffmanzheng.github.io/2020/java-encode/</guid>
      <category domain="https://hoffmanzheng.github.io/categories/reading-notes/">Reading Notes</category>
      <description>&lt;p&gt;作为非英语国家程序员，编码问题是我们一直都绕不过去的一道坎。&lt;/p&gt;&#xA;&lt;p&gt;本篇以 &lt;a href=&#34;https://book.douban.com/subject/25953851/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;《深入分析 Java Web 技术内幕》&lt;/a&gt; 第三章 深入分析 Java Web 中的中文编码问题 的内容为参考，讲解常见的编码格式、Java 中的编解码、Java Web 中的编解码，及常见乱码问题分析等。&lt;/p&gt;&#xA;&lt;p&gt;计算机中存储信息的最小单元是 1 个字节，即 8 bits，所以能表示的字符范围是 0~255 个，而我们人类的语言太多，表示这些语言的符号太多，因而必须要经过一些翻译工作，才能让计算机理解我们的语言。这个翻译工作就是从 char 到 byte 的编码过程。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;常见的编码格式&#34;&gt;&lt;span&gt;常见的编码格式&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%b8%b8%e8%a7%81%e7%9a%84%e7%bc%96%e7%a0%81%e6%a0%bc%e5%bc%8f&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;h4 class=&#34;heading-element&#34; id=&#34;asc-码&#34;&gt;&lt;span&gt;ASCⅡ 码&lt;/span&gt;&#xA;  &lt;a href=&#34;#asc-%e7%a0%81&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;使用一个字节的低 7 位表示，范围为 0&lt;del&gt;127 共 128 个，包括了英文大小写字母，数字及常用的数学符号。0&lt;/del&gt;31 是控制字符如换行、回车、空字符等，32~126 是打印字符，127 为删除。&lt;/p&gt;</description>
    </item>
    <item>
      <title>深入分析 Java I/O 的工作机制</title>
      <link>https://hoffmanzheng.github.io/2020/java-io/</link>
      <pubDate>Mon, 17 Aug 2020 09:19:47 +0100</pubDate>
      <guid>https://hoffmanzheng.github.io/2020/java-io/</guid>
      <category domain="https://hoffmanzheng.github.io/categories/reading-notes/">Reading Notes</category>
      <description>&lt;p&gt;I/O 是任何编程语言都无法回避的问题，它是人机交互中机器获取和交换信息的主要渠道，可以说大部分 Web 应用系统的瓶颈都是 I/O 瓶颈。&lt;/p&gt;&#xA;&lt;p&gt;本篇以 &lt;a href=&#34;https://book.douban.com/subject/25953851/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;《深入分析 Java Web 技术内幕》&lt;/a&gt; 第二章 深入分析 Java I/O 的工作机制 的内容为参考，讲解 Java I/O 类库、磁盘 I/O、网络 I/O、NIO 工作机制等。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;java-io-类库的基本架构&#34;&gt;&lt;span&gt;Java I/O 类库的基本架构&lt;/span&gt;&#xA;  &lt;a href=&#34;#java-io-%e7%b1%bb%e5%ba%93%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%9e%b6%e6%9e%84&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;h4 class=&#34;heading-element&#34; id=&#34;基于字节的-io-操作接口&#34;&gt;&lt;span&gt;基于字节的 I/O 操作接口&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%9f%ba%e4%ba%8e%e5%ad%97%e8%8a%82%e7%9a%84-io-%e6%93%8d%e4%bd%9c%e6%8e%a5%e5%8f%a3&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;无论是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以 I/O 操作的都是字节而不是字符，Java 中基于字节的 I/O 操作接口输入和输出分别是 InputStream 和 OutputStream，其类层次关系如下图所示。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java：程序的部署和 Nginx 负载均衡</title>
      <link>https://hoffmanzheng.github.io/2020/deploy/</link>
      <pubDate>Tue, 21 Apr 2020 11:30:47 +0100</pubDate>
      <guid>https://hoffmanzheng.github.io/2020/deploy/</guid>
      <category domain="https://hoffmanzheng.github.io/categories/study-notes/">Study Notes</category>
      <description>&lt;p&gt;本篇介绍 Java 程序部署的三种方式：exec 插件、jar 包、Docker 方式部署，以及使用 Nginx 实现简单的负载均衡。&lt;/p&gt;&#xA;&lt;h1 class=&#34;heading-element&#34; id=&#34;java-程序的部署&#34;&gt;&lt;span&gt;Java 程序的部署&lt;/span&gt;&#xA;  &lt;a href=&#34;#java-%e7%a8%8b%e5%ba%8f%e7%9a%84%e9%83%a8%e7%bd%b2&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&lt;h3 class=&#34;heading-element&#34; id=&#34;maven-exec-插件部署&#34;&gt;&lt;span&gt;Maven exec 插件部署&lt;/span&gt;&#xA;  &lt;a href=&#34;#maven-exec-%e6%8f%92%e4%bb%b6%e9%83%a8%e7%bd%b2&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;ol&gt;&#xA;&lt;li&gt;导入 Maven 的 exec 插件：&lt;a href=&#34;https://mvnrepository.com/artifact/org.codehaus.mojo/exec-maven-plugin&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Maven Repository：exec-maven-plugin&lt;/a&gt;，然后在 pom.xml 中进行配置，使之可以调用外部命令执行 Java 程序并自动加载依赖的 classpath 路径：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;plugin&amp;gt;&#xA;&amp;lt;groupId&amp;gt;org.codehaus.mojo&amp;lt;/groupId&amp;gt;&#xA;&amp;lt;artifactId&amp;gt;exec-maven-plugin&amp;lt;/artifactId&amp;gt;&#xA;&amp;lt;version&amp;gt;1.6.0&amp;lt;/version&amp;gt;&#xA;&amp;lt;executions&amp;gt;&#xA;&#x9;&amp;lt;execution&amp;gt;&#xA;&#x9;&#x9;&amp;lt;id&amp;gt;run&amp;lt;/id&amp;gt;&#xA;&#x9;&#x9;&amp;lt;goals&amp;gt;&#xA;&#x9;&#x9;&#x9;&amp;lt;goal&amp;gt;exec&amp;lt;/goal&amp;gt;&#xA;&#x9;&#x9;&amp;lt;/goals&amp;gt;&#xA;&#x9;&#x9;&amp;lt;configuration&amp;gt;&#xA;&#x9;&#x9;&#x9;&amp;lt;executable&amp;gt;java&amp;lt;/executable&amp;gt;&#xA;&#x9;&#x9;&#x9;&amp;lt;arguments&amp;gt;&#xA;&#x9;&#x9;&#x9;&#x9;&amp;lt;argument&amp;gt;-classpath&amp;lt;/argument&amp;gt;&#xA;&#x9;&amp;lt;!-- automatically creates the classpath using all project dependencies,&#xA;          also adding the project build directory --&amp;gt;&#xA;&#x9;&#x9;&#x9;&#x9;&amp;lt;classpath/&amp;gt;&#xA;&#x9;&#x9;&#x9;&#x9;&amp;lt;argument&amp;gt;com.github.hoffmanzheng.springboot.Application&amp;lt;/argument&amp;gt;&#xA;&#x9;&#x9;&#x9;&amp;lt;/arguments&amp;gt;&#xA;&#x9;&#x9;&amp;lt;/configuration&amp;gt;&#xA;&#x9;&amp;lt;/execution&amp;gt;&#xA;&amp;lt;/executions&amp;gt;&#xA;&amp;lt;/plugin&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;&lt;code&gt;mvn exec:exec@[executionID]&lt;/code&gt; 即可完成程序的部署；&lt;code&gt;-X&lt;/code&gt; 参数可以用于排查部署时出现的问题，&lt;code&gt;-DskipTests&lt;/code&gt;  可以跳过测试。&lt;/li&gt;&#xA;&lt;li&gt;windosw下（需使用系统 cmd） &lt;code&gt;netstat -ano | findstr &amp;quot;8080&amp;quot;&lt;/code&gt; 可以查看当前端口被占用的情况，&lt;code&gt;tasklist |findstr &amp;quot;进程id号&amp;quot;&lt;/code&gt;  查找对应的进程名称，然后 &lt;code&gt;taskkill /f /t /im &amp;quot;进程id或者进程名称&amp;quot;&lt;/code&gt; 杀掉当前占用端口的进程&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;部署效果图：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java：线程池原理、源码分析</title>
      <link>https://hoffmanzheng.github.io/2020/java-threadpool/</link>
      <pubDate>Fri, 27 Mar 2020 10:19:47 +0100</pubDate>
      <guid>https://hoffmanzheng.github.io/2020/java-threadpool/</guid>
      <category domain="https://hoffmanzheng.github.io/categories/study-notes/">Study Notes</category>
      <description>&lt;p&gt;本篇为 &lt;a href=&#34;https://hoffmanzheng.github.io/2020/java-multi-thread/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Java：初识多线程、原理及实现&lt;/a&gt; 的续篇，介绍 Java 中的线程池，主要内容有：进程与线程、线程池化的意义、Executors 工具类、线程池工作流程、线程复用原理等。&lt;/p&gt;&#xA;&lt;h1 class=&#34;heading-element&#34; id=&#34;为什么需要线程池&#34;&gt;&lt;span&gt;为什么需要线程池&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e7%ba%bf%e7%a8%8b%e6%b1%a0&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&lt;h3 class=&#34;heading-element&#34; id=&#34;进程与线程&#34;&gt;&lt;span&gt;进程与线程&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e8%bf%9b%e7%a8%8b%e4%b8%8e%e7%ba%bf%e7%a8%8b&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;h4 class=&#34;heading-element&#34; id=&#34;起源&#34;&gt;&lt;span&gt;起源&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e8%b5%b7%e6%ba%90&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt; 是在批处理操作系统的基础上，为进一步提高计算机效率，改善操作系统串行的运行方式的产物。进程的出现改变了内存中始终只有一个程序运行的事实，进程是在内存中独享一片内存空间的程序，各个进程之间互不干扰。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java：HashMap 源码解读</title>
      <link>https://hoffmanzheng.github.io/2020/java-hashmap/</link>
      <pubDate>Tue, 28 Jan 2020 14:11:47 +0100</pubDate>
      <guid>https://hoffmanzheng.github.io/2020/java-hashmap/</guid>
      <category domain="https://hoffmanzheng.github.io/categories/study-notes/">Study Notes</category>
      <description>&lt;p&gt;本篇基于哈希表的源码详解哈希表相关的各种问题，包括底层实现、扩容机制、get / put 过程、JDK 1.8 的改进、并发问题及 key 问题，并对源码文档进行翻译。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;hashmap-的实现原理&#34;&gt;&lt;span&gt;HashMap 的实现原理&lt;/span&gt;&#xA;  &lt;a href=&#34;#hashmap-%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;h4 class=&#34;heading-element&#34; id=&#34;1-哈希表底层实现原理&#34;&gt;&lt;span&gt;1. 哈希表底层实现原理&lt;/span&gt;&#xA;  &lt;a href=&#34;#1-%e5%93%88%e5%b8%8c%e8%a1%a8%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/hashmap底层结构.png&#39; alt=&#34;/images/hashmap底层结构.png&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java：多线程下的安全容器</title>
      <link>https://hoffmanzheng.github.io/2020/java-thread-safe-collection/</link>
      <pubDate>Thu, 16 Jan 2020 13:19:47 +0100</pubDate>
      <guid>https://hoffmanzheng.github.io/2020/java-thread-safe-collection/</guid>
      <category domain="https://hoffmanzheng.github.io/categories/study-notes/">Study Notes</category>
      <description>&lt;p&gt;在我之前的博客 &lt;a href=&#34;https://hoffmanzheng.github.io/2020/java-multi-thread/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Java：初识多线程、原理及实现&lt;/a&gt; 提及，多线程下对数据的非原子性操作会造成数据错误，为此 JDK 也提供了一些线程安全的容器。本篇主要介绍 List 类的安全容器：Vector 和 CopyOnWriteArrayList，以及 Map 类的 HashTable 和 ConcurrentHashMap。从他们之前的区别，后者对前者的改进，具体的实现原理这几个角度进行分析。&lt;/p&gt;&#xA;&lt;h1 class=&#34;heading-element&#34; id=&#34;list-类的安全容器&#34;&gt;&lt;span&gt;List 类的安全容器&lt;/span&gt;&#xA;  &lt;a href=&#34;#list-%e7%b1%bb%e7%9a%84%e5%ae%89%e5%85%a8%e5%ae%b9%e5%99%a8&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&lt;h3 class=&#34;heading-element&#34; id=&#34;1-vector-与-synchronizedlist&#34;&gt;&lt;span&gt;1. Vector 与 SynchronizedList&lt;/span&gt;&#xA;  &lt;a href=&#34;#1-vector-%e4%b8%8e-synchronizedlist&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;h4 class=&#34;heading-element&#34; id=&#34;11-vector&#34;&gt;&lt;span&gt;1.1 Vector&lt;/span&gt;&#xA;  &lt;a href=&#34;#11-vector&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Vector&lt;/code&gt; 类通过将所有的方法声明 synchronized 来保证数据的线程安全。但同步的确是整个 vector 实例，导致一个线程在访问实例时，其他线程都需要等待的尴尬情形，较大的同步开销完全不符合并发设计的初衷。此外，多线程下对 Verctor 的复合操作（如遍历+修改）仍会导致 &lt;strong&gt;并发修改异常&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java：初识多线程、原理及实现</title>
      <link>https://hoffmanzheng.github.io/2020/java-multi-thread/</link>
      <pubDate>Sun, 12 Jan 2020 14:49:47 +0100</pubDate>
      <guid>https://hoffmanzheng.github.io/2020/java-multi-thread/</guid>
      <category domain="https://hoffmanzheng.github.io/categories/study-notes/">Study Notes</category>
      <description>&lt;h1 class=&#34;heading-element&#34; id=&#34;多线程原理&#34;&gt;&lt;span&gt;多线程原理&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%a4%9a%e7%ba%bf%e7%a8%8b%e5%8e%9f%e7%90%86&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&lt;h3 class=&#34;heading-element&#34; id=&#34;1-为什么需要多线程&#34;&gt;&lt;span&gt;1. 为什么需要多线程&lt;/span&gt;&#xA;  &lt;a href=&#34;#1-%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%a4%9a%e7%ba%bf%e7%a8%8b&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;h4 class=&#34;heading-element&#34; id=&#34;11-java-代码的执行是同步阻塞模型&#34;&gt;&lt;span&gt;1.1 Java 代码的执行是同步阻塞模型&lt;/span&gt;&#xA;  &lt;a href=&#34;#11-java-%e4%bb%a3%e7%a0%81%e7%9a%84%e6%89%a7%e8%a1%8c%e6%98%af%e5%90%8c%e6%ad%a5%e9%98%bb%e5%a1%9e%e6%a8%a1%e5%9e%8b&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;Java 代码在执行的时候，是从 &lt;code&gt;main&lt;/code&gt; 代码块开始逐行执行，但当当前代码耗时过长时，下一行的代码就必须等待当前任务执行完毕，代码才能继续往下执行。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java：Collection、Map 集合工具类</title>
      <link>https://hoffmanzheng.github.io/2020/java-collection/</link>
      <pubDate>Thu, 02 Jan 2020 16:11:47 +0100</pubDate>
      <guid>https://hoffmanzheng.github.io/2020/java-collection/</guid>
      <category domain="https://hoffmanzheng.github.io/categories/study-notes/">Study Notes</category>
      <description>&lt;p&gt;本篇介绍 Java 中集合类框架的基础知识，包括 List，Set，Map。此外，关于使用频率最高的容器 HashMap 则会在另一篇博文 &lt;a href=&#34;https://hoffmanzheng.github.io/2020/java-hashmap/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Java：HashMap 源码解读&lt;/a&gt; 中详细分析；关于这些集合类的线程安全问题，会在 &lt;a href=&#34;https://hoffmanzheng.github.io/2020/java-thread-safe-collection/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Java：多线程下的安全容器&lt;/a&gt; 中进行讲述。&lt;/p&gt;&#xA;&lt;h1 class=&#34;heading-element&#34; id=&#34;collection-继承体系&#34;&gt;&lt;span&gt;Collection 继承体系&lt;/span&gt;&#xA;  &lt;a href=&#34;#collection-%e7%bb%a7%e6%89%bf%e4%bd%93%e7%b3%bb&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/Collections.png&#39; alt=&#34;Collection 继承体系&#34;&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
