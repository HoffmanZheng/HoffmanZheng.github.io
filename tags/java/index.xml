<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 人间一场大梦</title>
    <link>http://chenghao.monster/tags/java/</link>
    <description>Recent content in Java on 人间一场大梦</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 16 Jan 2020 13:19:47 +0100</lastBuildDate>
    
	<atom:link href="http://chenghao.monster/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java：多线程下的安全容器</title>
      <link>http://chenghao.monster/2020/java-thread-safe-collection/</link>
      <pubDate>Thu, 16 Jan 2020 13:19:47 +0100</pubDate>
      
      <guid>http://chenghao.monster/2020/java-thread-safe-collection/</guid>
      <description>在我之前的博客 Java：初识多线程、原理及实现 提及，多线程下对数据的非原子性操作会造成数据错误，为此 JDK 也提供了一些线程安全的容器。本篇主要介绍 List 类的安全容器：Vector 和 CopyOnWriteArrayList，以及 Map 类的 HashTable 和 ConcurrentHashMap。从他们之前的区别，后者对前者的改进，具体的实现原理这几个角度进行分析。
List 类的安全容器  Map 类的安全容器 ConcurrentHashMap 和 Hashtable 的区别
Hashtable ：将 get / put 所有相关操作都 synchronized 化，这相当于给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。
ConcurrentHashMap：对整个桶数组进行了分割分段 Segment，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。
一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和 HashMap 类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。
到了 JDK 1.8 的时候已经摒弃了分段锁，而是直接用 Node 数组 + 链表 + 红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（ JDK 1.6 以后 对 synchronized 锁做了很多优化， 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK 1.</description>
    </item>
    
    <item>
      <title>Java：初识多线程、原理及实现</title>
      <link>http://chenghao.monster/2020/java-multi-thread/</link>
      <pubDate>Sun, 12 Jan 2020 14:49:47 +0100</pubDate>
      
      <guid>http://chenghao.monster/2020/java-multi-thread/</guid>
      <description>多线程原理 1. 为什么需要多线程 1.1 Java 代码的执行是同步阻塞模型 Java 代码在执行的时候，是从 main 代码块开始逐行执行，但当当前代码耗时过长时，下一行的代码就必须等待当前任务执行完毕，代码才能继续往下执行。
1.2 CPU的运算实在太快了 取主频为 3GHz CPU 为例，CPU 执行单个指令所需的时间约为 0.3ns；与之相对的，在内存中进行读取1MB大小文件所需时间大概为 250us，SSD随机读取耗时约为 1ms，HDD约为 20ms。（推荐阅读：我是一个CPU：这个世界慢！死！了！）
相比与内存，硬盘，网络传输，CPU 的运算实在是太快了，但是由于阻塞模型，如若当前代码执行的是较为耗时的 IO 操作，线程中的下一个任务就必须等待当前任务结束才能继续执行。使得单线程的代码执行非常没有效率，另外也浪费了 CPU 的运算性能。
2. Java 线程简介 2.1 多线程的方法栈 一般的 Java 程序都是从启动类的 main 函数入口开始执行，随着 main 函数的结束而停止. 这条执行路径就是 Java 程序的主线程。Java 虚拟机允许拥有同时运行多个线程，当新线程运行时，就会在栈中生成一个新的方法栈，新线程独享单独的执行流和局部变量，而静态变量则是被所有线程共享的。
2.2 多线程的性能 使用多线程就只有好处没有坏处吗？并不是，使用多线程是要付出代价的，如果没有耗时的任务，使用多线程，效率反而更低，因为CPU 在线程间的切换也需要耗费时间。引用知乎上看到的一句话：
 多线程在 CPU 密集型的作业下的确不能提高性能甚至更浪费时间，但是在 IO 密集型的作业下则可以提升性能（或者更准确点说叫平均响应时间）。
 由上得出的结论是，正确的使用多线程可以提高程序的运行效率。
3. 多线程问题的来源 3.1 多线程下的数据安全问题 多线程同时对一个共享的全局变量进行非原子操作将会引发严重的数据安全问题。
  原子操作可理解为不可分隔的操作，而非原子操作例如 i++ 则可以分解为 temp = i; temp = temp + 1; i = temp; 这样的取值、运算、赋值三个独立的操作。</description>
    </item>
    
    <item>
      <title>Java：Collection、Map 工具类及常见方法</title>
      <link>http://chenghao.monster/2020/java-collection/</link>
      <pubDate>Thu, 02 Jan 2020 16:11:47 +0100</pubDate>
      
      <guid>http://chenghao.monster/2020/java-collection/</guid>
      <description>本篇介绍 Java 中的集合类框架的基础知识，并重点对 HashMap 的源码进行剖析，具体介绍 JDK 1.8 对 HashMap 所做的改动。关于这些集合类的线程安全问题，会在我的另一篇博客 Java：多线程下的安全容器 中进行详细的分析。
Collection 继承体系 1. 集合 Collection 介绍  为什么需要集合？  集合使 Java 可以处理多个同类型的对象（List / Set），亦或是多个键值对类型的数据（Map）。   集合的常用功能：  添加：add(Object obj)、addAll(Collection c)； 删除：clear()、remove(Object)、removeAll(Collection)； 判断包含：isEmpty()、contains(Object)、containsAll(Collection)；  contains 方法进行判定时，会调用 equals 方法，所以在用集合存储引用对象（非原生数据类型）时需要重写 equals 和 HashCode 方法。   遍历获取：Iteratoriterator()； 长度：size()； 交集：retainAll(Collection c)； 若有元素被移除，此操作会改变原有实例集合。   迭代器（Iterator）：  以内部类的方式遍历集合中的元素，有以下方法：  hasNext()； next()； remove()；   构造思路：  写一个 iterator() 方法返回一个自己的迭代器， 创建一个自己的迭代器继承 Iterator 接口，重写接口的三个方法。 使用时：用 iterator() 创建迭代器，再用迭代器去调用其中的三个方法。      2.</description>
    </item>
    
  </channel>
</rss>