<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="Chenghao.Zheng">
  
  
  
  <link rel="prev" href="https://nervousorange.github.io/2020/database-mysql/" />
  <link rel="next" href="https://nervousorange.github.io/2020/deploy/" />
  <link rel="canonical" href="https://nervousorange.github.io/2020/java-threadpool/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           Java：线程池原理、源码分析 | 人间一场大梦
       
  </title>
  <meta name="title" content="Java：线程池原理、源码分析 | 人间一场大梦">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/nervousorange.github.io\/"
    },
    "articleSection" : "posts",
    "name" : "Java：线程池原理、源码分析",
    "headline" : "Java：线程池原理、源码分析",
    "description" : "本篇为 Java：初识多线程、原理及实现 的续篇，介绍 Java 中的线程池，主要内容有：进程与线程、线程池化的意义、Executors 工具类、线程池工作流程、线程复用原理等。\n为什么需要线程池 进程与线程 起源 进程 是在批处理操作系统的基础上，为进一步提高计算机效率，改善操作系统串行的运行方式的产物。进程的出现改变了内存中始终只有一个程序运行的事实，进程是在内存中独享一片内存空间的程序，各个进程之间互不干扰。\nCPU 采用 时间片轮转 的方式运行进程，使用上下文切换的方式让操作系统的并发成为可能。虽然并发从宏观上看有多个任务在执行，但对于单核 CPU 来说，任意时刻都只有一个任务在占用 CPU 资源。\n 上下文指某一时刻 CPU 寄存器和程序计数器的内容，通过在内存中保存 \/ 读取来完成其切换。上下⽂切换通常是计算密集型的，意味着此操作会消耗⼤量的 CPU 时间，故线程也不是越多越好。如何减少系统中上下⽂切换次数，是提升多线程性能的⼀个重点课题。\n 如果说进程让操作系统的并发性成为了可能，那么 线程 就让进程的内部并发成为了可能。每个线程执行进程中的一个子任务，使得杀毒软件一遍检测用户电脑一遍清理垃圾成为可能。\n进程和线程的区别  进程间的通信比较复杂，而线程间的通信比较简单。线程相比进程更为轻量级，多线程并发相比多进程开销更小。 进程和线程本质的区别是 是否单独占有内存地址空间及其他的系统资源（比如 I\/O）：进程间存在内存隔离，而线程共享所属进程占有的内存地址空间和隔离，数据共享简单，但是同步复杂。 进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位。一个进程出现问题不会影响其他进程；而一个线程崩溃可能影响整个程序的稳定性。  Java 线程与操作系统内核线程 用户级线程与内核级线程 推荐阅读：用户级线程和内核级线程，你分清楚了吗？\n 用户级线程 ULT：由应用程序实现和管理（创建、同步、调度等），线程阻塞则整个进程阻塞。对操作系统来说，用户级线程具有不可见性、透明性，ULT 下 CPU 的调度还是以进程为单位。 内核级线程 KLT：需通过 系统调用 创建，由系统内核管理，可实现多核 CPU 并行处理。线程阻塞不会影响同进程内其他线程的运行。  线程池的意义  JVM 运行在用户态，通过调用系统库来创建内核线程，由 CPU 来完成线程的调度；但是从用户态到内核态的权限提升和状态切换需要相当的 系统开销，频繁的创建和销毁线程将不利于程序性能的提升。 为此，将线程池化管理，对线程进行统一分配、调优和监控，避免频繁的线程创建，减少状态切换带来的资源消耗，重用线程 就是使用线程池的意义。 线程池比较适合处理数量庞大，但是处理时间较短的任务。如果某个任务耗时过长，会导致池内任务堆积。  线程池原理 ThreadPoolExecutor 的构造器参数 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u0026lt;Runnable\u0026gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)  corePoolSize：核⼼线程数，在没有任务执行时线程池的大小 maximumPoolSize：池内最大线程数，在工作队列满了的情况下会创建出超过非核心的线程   最大线程数 = 核心线程 \u002b 非核心线程。非核心线程如果长时间闲置，就会被销毁。",
    "inLanguage" : "en-us",
    "author" : "Chenghao Zheng",
    "creator" : "Chenghao Zheng",
    "publisher": "Chenghao Zheng",
    "accountablePerson" : "Chenghao Zheng",
    "copyrightHolder" : "Chenghao Zheng",
    "copyrightYear" : "2020",
    "datePublished": "2020-03-27 10:19:47 \u002b0100 \u002b0100",
    "dateModified" : "2020-03-27 10:19:47 \u002b0100 \u002b0100",
    "url" : "https:\/\/nervousorange.github.io\/2020\/java-threadpool\/",
    "wordCount" : "1473",
    "keywords" : [ "Java", "人间一场大梦"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    
        <div class="top-scroll-bar"></div>
    
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://nervousorange.github.io/">人间一场大梦</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
    
        <div class="top-scroll-bar"></div>
    
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://nervousorange.github.io/">人间一场大梦</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Java：线程池原理、源码分析</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://nervousorange.github.io/" rel="author">Chenghao Zheng</a> with ♥ 
                <span class="post-time">
                on <time datetime=2020-03-27 itemprop="datePublished">March 27, 2020</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="https://nervousorange.github.io/categories/study-notes/"> Study notes </a>
                        
                </span>
                 <span class="post-word-count">,1473 words</span>
        </div>
    </header>
    <div class="post-content">
        

        
            
        

        
        
     
          
          
          

          
          
          

          <p>本篇为 <a href="https://nervousorange.github.io/2020/java-multi-thread/">Java：初识多线程、原理及实现</a> 的续篇，介绍 Java 中的线程池，主要内容有：进程与线程、线程池化的意义、Executors 工具类、线程池工作流程、线程复用原理等。</p>
<h1 id="为什么需要线程池">为什么需要线程池</h1>
<h3 id="进程与线程">进程与线程</h3>
<h4 id="起源">起源</h4>
<p><strong>进程</strong> 是在批处理操作系统的基础上，为进一步提高计算机效率，改善操作系统串行的运行方式的产物。进程的出现改变了内存中始终只有一个程序运行的事实，进程是在内存中独享一片内存空间的程序，各个进程之间互不干扰。</p>
<p>CPU 采用 <strong>时间片轮转</strong> 的方式运行进程，使用上下文切换的方式让操作系统的并发成为可能。虽然并发从宏观上看有多个任务在执行，但对于单核 CPU 来说，任意时刻都只有一个任务在占用 CPU 资源。</p>
<blockquote>
<p>上下文指某一时刻 CPU 寄存器和程序计数器的内容，通过在内存中保存 / 读取来完成其切换。上下⽂切换通常是计算密集型的，意味着此操作会消耗⼤量的 CPU 时间，故线程也不是越多越好。如何减少系统中上下⽂切换次数，是提升多线程性能的⼀个重点课题。</p>
</blockquote>
<p>如果说进程让操作系统的并发性成为了可能，那么 <strong>线程</strong> 就让进程的内部并发成为了可能。每个线程执行进程中的一个子任务，使得杀毒软件一遍检测用户电脑一遍清理垃圾成为可能。</p>
<h4 id="进程和线程的区别">进程和线程的区别</h4>
<ol>
<li>进程间的通信比较复杂，而线程间的通信比较简单。线程相比进程更为轻量级，多线程并发相比多进程开销更小。</li>
<li>进程和线程本质的区别是 <strong>是否单独占有内存地址空间及其他的系统资源（比如 I/O）</strong>：进程间存在内存隔离，而线程共享所属进程占有的内存地址空间和隔离，数据共享简单，但是同步复杂。</li>
<li>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位。一个进程出现问题不会影响其他进程；而一个线程崩溃可能影响整个程序的稳定性。</li>
</ol>
<h3 id="java-线程与操作系统内核线程">Java 线程与操作系统内核线程</h3>
<h4 id="用户级线程与内核级线程">用户级线程与内核级线程</h4>
<p>推荐阅读：<a href="https://cloud.tencent.com/developer/article/1541432">用户级线程和内核级线程，你分清楚了吗？</a></p>
<ol>
<li>用户级线程 ULT：由应用程序实现和管理（创建、同步、调度等），线程阻塞则整个进程阻塞。对操作系统来说，用户级线程具有不可见性、透明性，ULT 下 CPU 的调度还是以进程为单位。</li>
<li>内核级线程 KLT：需通过 <strong>系统调用</strong> 创建，由系统内核管理，可实现多核 CPU 并行处理。线程阻塞不会影响同进程内其他线程的运行。</li>
</ol>
<p><img src="/images/system-memory.png" alt=""></p>
<h4 id="线程池的意义">线程池的意义</h4>
<ul>
<li>JVM 运行在用户态，通过调用系统库来创建内核线程，由 CPU 来完成线程的调度；但是从用户态到内核态的权限提升和状态切换需要相当的 <strong>系统开销</strong>，频繁的创建和销毁线程将不利于程序性能的提升。</li>
<li>为此，将线程池化管理，对线程进行统一分配、调优和监控，避免频繁的线程创建，减少状态切换带来的资源消耗，<strong>重用线程</strong> 就是使用线程池的意义。</li>
<li>线程池比较适合处理数量庞大，但是处理时间较短的任务。如果某个任务耗时过长，会导致池内任务堆积。</li>
</ul>
<h1 id="线程池原理">线程池原理</h1>
<h3 id="threadpoolexecutor-的构造器参数">ThreadPoolExecutor 的构造器参数</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ThreadPoolExecutor</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> corePoolSize<span style="color:#f92672">,</span>
                          <span style="color:#66d9ef">int</span> maximumPoolSize<span style="color:#f92672">,</span>
                          <span style="color:#66d9ef">long</span> keepAliveTime<span style="color:#f92672">,</span>
                          TimeUnit unit<span style="color:#f92672">,</span>
                          BlockingQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;</span> workQueue<span style="color:#f92672">,</span>
                          ThreadFactory threadFactory<span style="color:#f92672">,</span>
                          RejectedExecutionHandler handler<span style="color:#f92672">)</span> 
</code></pre></div><ul>
<li>corePoolSize：核⼼线程数，在没有任务执行时线程池的大小</li>
<li>maximumPoolSize：池内最大线程数，在工作队列满了的情况下会创建出超过非核心的线程</li>
</ul>
<blockquote>
<p>最大线程数 = 核心线程 + 非核心线程。非核心线程如果长时间闲置，就会被销毁。</p>
</blockquote>
<ul>
<li>keepAliveTime / unit：非核心线程闲置超时时长 / 时间单位，当非核心线程的空闲时间超过存活时间后会被标记为可回收的，帮助回收空闲线程占有的资源</li>
<li>workQueue：阻塞的任务队列，保存那些即将被执行的任务</li>
</ul>
<blockquote>
<p>阻塞队列：在任意时刻，不管并发有多高，永远只有一个线程能够进行队列的入队或者出队操作！无界|有界；队列满，只能进行出队操作，所有入队的操作必须等待，也就是被阻塞；队列空，只能进行入队操作，所有出队的操作必须等待，也就是被阻塞。</p>
</blockquote>
<ul>
<li>threadFactory：创建线程的工厂</li>
<li>rejectedExecutionHandler：当任务队列满且无法再创建非核心线程时会执行拒绝处理策略
<ul>
<li>AbortPolicy 默认拒绝处理策略，丢弃任务并抛出 RejectedExecutionException 异常。</li>
<li>CallerRunsPolicy：由调⽤线程处理该任务，如果将 WebServer 改为有界队列和 “调用者运行” 饱和策略，当线程池中所有线程都被占用，并且工作队列也被填满后，下一个任务会 <strong>在主线程中执行</strong>。由于执行任务需要一定的时间，因此主线程至少在一段时间内不能提交任务任务。在这期间到达的请求会被保存在 TCP 层的队列中而不是在应用程序的队列中，如果持续过载，那么 TCP 层最终会发现它的请求队列被填满，然后开始抛弃请求。</li>
<li>DiscardOldestPolicy：丢弃队列头部（最旧的）的任务，然后重新尝试执⾏程序，如果工作队列是一个优先级队列，那么 “抛弃最旧的” 策略将导致抛弃优先级最高的任务</li>
<li>DiscardPolicy：悄悄丢弃新来的任务</li>
</ul>
</li>
</ul>
<h3 id="线程池的状态">线程池的状态</h3>
<h4 id="线程池的五种状态">线程池的五种状态</h4>
<ul>
<li>RUNNING：线程池创建后处于 RUNNING 状态，能接受新任务以及处理已添加的任务</li>
<li>SHUTDOWN：调用 shutdown() 方法后处于该状态，线程池不能接受新任务，可以处理队列中的任务，并清除一些空闲的 worker</li>
<li>STOP：调用 shutdownNow() 后处于该状态，线程池不能接受新任务，丢弃队列中的任务，并且中断正在处理的任务</li>
<li>TIDYING：当所有的任务已经终止，ctl 记录的 “任务数量” 为 0，线程池会处于 TIDYING 状态</li>
<li>TERMINATED：在 TIDYING 状态执行完 terminated() 方法后，线程池彻底终止，转变为TERMINATED 状态</li>
</ul>
<p><img src="/images/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.png" alt=""></p>
<h4 id="源码分析">源码分析</h4>
<p>ThreadPoolExecutor 中 使用 <code>AtomicInteger ctl</code> 记录线程池的运行状态与活动线程数量</p>
<p>以一个整数 32 位为例：</p>
<ul>
<li>
<p>COUNT_BITS = 29；CAPACITY = 0001 1111 1111 1111 1111 1111 1111 1111；（高 3 位为0，后 29 位皆为 1）</p>
</li>
<li>
<p>以 ctl 的 <strong>高三位</strong> 记录当前的线程池状态</p>
<ul>
<li>
<table>
<thead>
<tr>
<th style="text-align:center">线程池状态</th>
<th style="text-align:center">ctl 高 3 位 （后 29 位皆为 0）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">RUNNING</td>
<td style="text-align:center">111</td>
</tr>
<tr>
<td style="text-align:center">SHUTDOWN</td>
<td style="text-align:center">000</td>
</tr>
<tr>
<td style="text-align:center">STOP</td>
<td style="text-align:center">001</td>
</tr>
<tr>
<td style="text-align:center">TIDYING</td>
<td style="text-align:center">010</td>
</tr>
<tr>
<td style="text-align:center">TERMINATED</td>
<td style="text-align:center">011</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>如此，通过当前 ctl 的值与 CAPACITY  的与运算就可以求得当前线程池状态 / 当前活跃线程数量</p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> AtomicInteger ctl <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AtomicInteger<span style="color:#f92672">(</span>ctlOf<span style="color:#f92672">(</span>RUNNING<span style="color:#f92672">,</span> 0<span style="color:#f92672">));</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> COUNT_BITS <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">SIZE</span> <span style="color:#f92672">-</span> 3<span style="color:#f92672">;</span>       <span style="color:#75715e">// = 29
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> CAPACITY   <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>1 <span style="color:#f92672">&lt;&lt;</span> COUNT_BITS<span style="color:#f92672">)</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>

    <span style="color:#75715e">// runState is stored in the high-order bits
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> RUNNING    <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1 <span style="color:#f92672">&lt;&lt;</span> COUNT_BITS<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> SHUTDOWN   <span style="color:#f92672">=</span>  0 <span style="color:#f92672">&lt;&lt;</span> COUNT_BITS<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> STOP       <span style="color:#f92672">=</span>  1 <span style="color:#f92672">&lt;&lt;</span> COUNT_BITS<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> TIDYING    <span style="color:#f92672">=</span>  2 <span style="color:#f92672">&lt;&lt;</span> COUNT_BITS<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> TERMINATED <span style="color:#f92672">=</span>  3 <span style="color:#f92672">&lt;&lt;</span> COUNT_BITS<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">runStateOf</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> c<span style="color:#f92672">)</span>     <span style="color:#f92672">{</span> <span style="color:#66d9ef">return</span> c <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>CAPACITY<span style="color:#f92672">;</span> <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">workerCountOf</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> c<span style="color:#f92672">)</span>  <span style="color:#f92672">{</span> <span style="color:#66d9ef">return</span> c <span style="color:#f92672">&amp;</span> CAPACITY<span style="color:#f92672">;</span> <span style="color:#f92672">}</span>
</code></pre></div><h3 id="四种常见的线程池">四种常见的线程池</h3>
<p>Executors 工具类中提供的⼏个静态⽅法来创建线程池。⼤家到了这⼀步，如果看懂了前⾯讲的 ThreadPoolExecutor 构造⽅法中各种参数的意义，那么⼀看到 Executors 类中提供的线程池的源码就应该知道这个线程池是⼲嘛的。</p>
<p>不过 <a href="https://developer.aliyun.com/topic/java20">阿里巴巴《Java 开发手册（嵩山版）》</a>  中指明 <strong>不允许</strong> 使用 Executors 创建线程池，而是通过 ThreadPoolExecutor 的方式，下面会通过源码进行分析。</p>
<h4 id="newcachedthreadpool">newCachedThreadPool</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ExecutorService <span style="color:#a6e22e">newCachedThreadPool</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">,</span>
                                      60L<span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">SECONDS</span><span style="color:#f92672">,</span>
                                      <span style="color:#66d9ef">new</span> SynchronousQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;());</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>当一个任务提交时，corePoolSize 为 0 不创建核心线程，SynchronousQueue 是一个不存储元素的队列，可以理解为队里永远是满的，因此最终会创建非核心线程来执行任务。</p>
<p>对于非核心线程空闲 60 s 时将被回收。因为 Integer.MAX_VALUE 非常大，可以认为是可以无限创建线程的，在资源有限的情况下容易引起 <strong>OOM 异常</strong>。</p>
<p>当需要执⾏很多 <strong>短时间</strong> 的任务时，CacheThreadPool 的线程复⽤率⽐较⾼， 会显著的提⾼性能。⽽且线程 60s 后会回收，意味着即使没有任务进来，CacheThreadPool 并不会占⽤很多资源 。</p>
<h4 id="newfixedthreadpool">newFixedThreadPool</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ExecutorService <span style="color:#a6e22e">newFixedThreadPool</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> nThreads<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">(</span>nThreads<span style="color:#f92672">,</span> nThreads<span style="color:#f92672">,</span>
                                      0L<span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">MILLISECONDS</span><span style="color:#f92672">,</span>
                                      <span style="color:#66d9ef">new</span> LinkedBlockingQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;());</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>可以看到 newFixedThreadPool 创建的都是核心线程，如果任务队列中没有任务可取，线程会一直阻塞在 getTask() 方法，而 newCachedThreadPool 会在等待 60s 后收回非核心线程。所以在没有任务的情况下 FixedThreadPool 会 <strong>占用更多的资源</strong>。</p>
<p>和 SingleThreadExecutor 类似，都使用了无界队列，唯一的区别就是核心线程数不同，并且由于使用的是 LinkedBlockingQueue，在资源有限的时候容易引起 <strong>OOM 异常</strong>。</p>
<p>两种线程池都⼏乎不会触发拒绝策略，但是原理不同。FixedThreadPool 是因为阻塞队列可以很⼤（最⼤为 Integer 最⼤值），故⼏乎不会触发拒绝策略；CachedThreadPool 是因为线程池很⼤（最⼤为Integer最⼤值），⼏乎不会导致线程数量⼤于最⼤线程数，故⼏乎不会触发拒绝策略 。</p>
<h4 id="newsinglethreadexecutor">newSingleThreadExecutor</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ExecutorService <span style="color:#a6e22e">newSingleThreadExecutor</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> FinalizableDelegatedExecutorService
            <span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> 1<span style="color:#f92672">,</span>
                                    0L<span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">MILLISECONDS</span><span style="color:#f92672">,</span>
                                    <span style="color:#66d9ef">new</span> LinkedBlockingQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;()));</span>
    <span style="color:#f92672">}</span> 
</code></pre></div><p>单线程的线程池，可以通过线程封闭的方式确保不会有任务并发执行，实现线程安全性。因为 LinkedBlockingQueue 是长度为 <code>Integer.MAX_VALUE</code> 的队列，可以认为是 <strong>无界队列</strong>，因此往队列中可以插入无限多的任务，在资源有限的时候容易引起 <strong>OOM 异常</strong>，同时因为无界队列，maximumPoolSize 和 keepAliveTime 参数将无效，压根就不会创建非核心线程。</p>
<h4 id="newscheduledthreadpool">newScheduledThreadPool</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ScheduledExecutorService <span style="color:#a6e22e">newScheduledThreadPool</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> corePoolSize<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> ScheduledThreadPoolExecutor<span style="color:#f92672">(</span>corePoolSize<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ScheduledThreadPoolExecutor</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> corePoolSize<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">super</span><span style="color:#f92672">(</span>corePoolSize<span style="color:#f92672">,</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> NANOSECONDS<span style="color:#f92672">,</span>
              <span style="color:#66d9ef">new</span> DelayedWorkQueue<span style="color:#f92672">());</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>⼀个定⻓线程池，⽀持定时及周期性任务执⾏。</p>
<p>四种常⻅的线程池基本够我们使⽤了，但是《阿⾥巴巴开发⼿册》<strong>不建议</strong> 我们直接使⽤ Executors 类中的线程池，⽽是通过 ThreadPoolExecutor 的⽅式，这样的处理⽅式让写的同学需要更加明确线程池的运⾏规则，规避资源耗尽的⻛险。</p>
<ul>
<li>FixedThreadPool 和 SingleThreadExecutor =&gt; 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而引起 OOM 异常</li>
<li>CachedThreadPool =&gt; 允许创建的线程数为 Integer.MAX_VALUE，可能会创建大量的线程，从而引起 OOM 异常</li>
</ul>
<h4 id="如何定义线程池参数">如何定义线程池参数</h4>
<p><strong>CPU密集型 =&gt;</strong> 线程池的大小推荐为CPU数量 + 1，CPU数量可以根据 <code>Runtime.availableProcessors</code> 方法获取</p>
<p><strong>IO密集型 =&gt;</strong> CPU 数量 * CPU利用率 * (1 + 线程等待时间 / 线程 CPU 时间)</p>
<p><strong>混合型 =&gt;</strong> 将任务分为 CPU 密集型和 IO 密集型，然后分别使用不同的线程池去处理，从而使每个线程池可以根据各自的工作负载来调整</p>
<p><strong>阻塞队列 =&gt;</strong> 推荐使用有界队列，有界队列有助于避免资源耗尽的情况发生</p>
<p><strong>拒绝策略 =&gt;</strong> 默认采用的是 AbortPolicy 拒绝策略，直接在程序中抛出 RejectedExecutionException 异常【因为是运行时异常，不强制catch】，这种处理方式不够优雅。处理拒绝策略有以下几种比较推荐：</p>
<ul>
<li>在程序中捕获 RejectedExecutionException 异常，在捕获异常中对任务进行处理。针对默认拒绝策略</li>
<li>使用 CallerRunsPolicy 拒绝策略，该策略会将任务交给调用 execute 的线程执行【一般为主线程】，此时主线程将在一段时间内不能提交任何任务，从而使工作线程处理正在执行的任务。此时提交的线程将被保存在 TCP 队列中，TCP 队列满将会影响客户端，这是一种 <strong>平缓的性能降低</strong></li>
<li>自定义拒绝策略，只需要实现 RejectedExecutionHandler 接口即可</li>
<li>如果任务不是特别重要，使用 DiscardPolicy 和 DiscardOldestPolicy 拒绝策略将任务丢弃也是可以的</li>
</ul>
<h3 id="线程池的使用">线程池的使用</h3>
<p>此处结合 <a href="https://book.douban.com/subject/10484692/">Java 并发编程实战</a> 第八章 线程池的使用 介绍在使用任务执行框架时需要注意的各种危险，以及一些使用 Executor 的高级示例。</p>
<h4 id="任务与执行策略之间的隐形耦合">任务与执行策略之间的隐形耦合</h4>
<p>只有当任务都是同类型的并且相互独立时，线程池的性能才能达到最佳。由于线程池中的线程的 <strong>可重用性</strong>，必须在任务完成后在 try-finally 块中清除 <code>ThreadLocal</code> 变量，避免影响后续业务逻辑和造成内存泄漏等问题。</p>
<p>如果提交的任务 <strong>依赖</strong> 于其他任务，那么除非线程池无限大，否则将可能造成死锁。试想在单线程的 Executor 中，一个任务将另一个任务提交到同一个 Executor，并等待这个被提交任务的结果，那么通常会引发死锁。第二个任务停留在队列中，等待第一个任务完成，而第一个任务又无法完成，因为它在等待第二个任务的完成。在更大的线程池中，如果所有正在执行任务的线程都由于等待其他仍处于队列中的任务而阻塞，则会发生同样的问题，称为 <strong>线程饥饿死锁</strong>。</p>
<p>如果将 <strong>运行时间较长</strong> 的与运行时间较短的任务混合在一起，除非线程池很大，否则将可能造成 “拥塞”。执行时间较长的任务不仅会造成线程池堵塞，甚至还会增加执行时间较短任务的服务时间。如果线程池中的 <strong>线程数量远小于</strong> 在稳定状态下执行时间较长的任务数量，那么到最后可能所有的线程都会运行这些执行时间较长的任务，从而影响整体的响应性。</p>
<p>有一项技术可以缓解执行时间较长任务造成的影响，即限定等待资源的时间，大多数可阻塞方法都提供了限时版本和无限时版本，如果 <strong>等待超时</strong> 就把任务标记为失败，这样就能将线程释放出来以执行一些能更快完成的任务。</p>
<h4 id="线程池的配置与扩展">线程池的配置与扩展</h4>
<p>在 <a href="https://nervousorange.github.io/2021/java-concurrency/">Java：并发编程实战</a> 中介绍了无限制地创建线程将导致系统的不稳定性。虽然可以通过使用固定大小的线程池来解决这个问题，然而在高负载下如果新请求的到达速率超过了线程池的处理速率，请求会 <strong>在队列中累计</strong> 起来，应用程序仍可能耗尽资源。</p>
<p>相比使用 newFixedThreadPool 和 newSingleThreadExecutor 默认的无界队列 <code>LinkedBlockingQueue</code>，使用有界队列如 <code>ArrayBlockingQueue</code> 可以有助于避免资源耗尽的情况发生。需要注意的是，只有当任务相互独立时，为线程池或工作队列设置界限才是合理的。如果任务之间存在依赖性，那么有界的线程池或队列就可能导致线程饥饿死锁问题。队列满后新到的任务将会根据饱和策略进行处理。有界队列的大小必须与线程池大小一起调节，如果线程池较小而队列较大，那么有助于减少内存使用量，降低 CPU 的使用率，同时还可以减少上下文切换，但付出的代码是可能会限制吞吐量。</p>
<p>对于非常大或者无界的线程池（比如 newCachedThreadPool），可以通过使用 <code>SynchronousQueue</code> 来避免任务排队，它不是一个真正的队列（没有容量），而是一种在线程之间进行移交的机制。要将一个任务放入 SynchronousQueue 中，就必须有另一个线程正在等待这个任务，否则将会根据当前线程池的大小创建一个新的线程或者按照饱和策略拒绝掉这个任务。</p>
<p>如果希望给线程池中的线程定制一些行为，例如指定一个 UncaughtExceptionHandler、给线程取一个更有意义的名称等，可以通过使用定制的线程工厂来实现：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyThreadFactory</span> <span style="color:#66d9ef">implements</span> ThreadFactory <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> String poolName<span style="color:#f92672">;</span>
    
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">MyThreadFactory</span><span style="color:#f92672">(</span>String poolName<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">poolName</span> <span style="color:#f92672">=</span> poolName<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    
    <span style="color:#66d9ef">public</span> Threaed <span style="color:#a6e22e">newThread</span><span style="color:#f92672">(</span>Runnable runnable<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> MyAppThread<span style="color:#f92672">(</span>runnable<span style="color:#f92672">,</span> poolName<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyAppThread</span> <span style="color:#66d9ef">extends</span> Thread <span style="color:#f92672">{</span>  
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> AtomicInteger created <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AtomicInteger<span style="color:#f92672">();</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">boolean</span> debugLifecycle <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> AtomicInteger alive <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AtomicInteger<span style="color:#f92672">();</span>  <span style="color:#75715e">// 存活线程数
</span><span style="color:#75715e"></span>    
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">MyAppThread</span><span style="color:#f92672">(</span>Runnable runnable<span style="color:#f92672">,</span> String name<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">super</span><span style="color:#f92672">(</span>runnable<span style="color:#f92672">,</span> name <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;-&#34;</span> <span style="color:#f92672">+</span> created<span style="color:#f92672">.</span><span style="color:#a6e22e">incrementAndGet</span><span style="color:#f92672">());</span>
        setUncaughtExceptionHandler<span style="color:#f92672">(</span>    <span style="color:#75715e">// 定制 UncaughtExceptionHandler
</span><span style="color:#75715e"></span>        	<span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">UncaughtExceptionHandler</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">uncaughtException</span><span style="color:#f92672">(</span>Thread t<span style="color:#f92672">,</span> Throwable e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    log<span style="color:#f92672">.</span><span style="color:#a6e22e">log</span><span style="color:#f92672">(</span>Level<span style="color:#f92672">.</span><span style="color:#a6e22e">SERVER</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;UNCAUGHT in thread &#34;</span> <span style="color:#f92672">+</span> t<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">(),</span> e<span style="color:#f92672">);</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">});</span>
    <span style="color:#f92672">}</span>
    
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">boolean</span> debug <span style="color:#f92672">=</span> debugLifecycle<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>debug<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> log<span style="color:#f92672">.</span><span style="color:#a6e22e">log</span><span style="color:#f92672">(</span>Level<span style="color:#f92672">.</span><span style="color:#a6e22e">FINE</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Created &#34;</span> <span style="color:#f92672">+</span> getName<span style="color:#f92672">());</span> <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
            alive<span style="color:#f92672">.</span><span style="color:#a6e22e">incrementAndGet</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">super</span><span style="color:#f92672">.</span><span style="color:#a6e22e">run</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
            alive<span style="color:#f92672">.</span><span style="color:#a6e22e">decrementAndGet</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>debug<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> log<span style="color:#f92672">.</span><span style="color:#a6e22e">log</span><span style="color:#f92672">(</span>Level<span style="color:#f92672">.</span><span style="color:#a6e22e">FINE</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Exiting &#34;</span> <span style="color:#f92672">+</span> getName<span style="color:#f92672">());</span> <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getThreadAlive</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span> <span style="color:#66d9ef">return</span> alive<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span> <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>// TODO</p>
<h4 id="递归算法的并行化">递归算法的并行化</h4>
<h3 id="线程池主要的任务处理流程">线程池主要的任务处理流程</h3>
<p>ThreadPoolExecutor 的 <code>execute(Runnable command)</code> 处理用户新提交的任务：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// JDK 1.8
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">execute</span><span style="color:#f92672">(</span>Runnable command<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>command <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NullPointerException<span style="color:#f92672">();</span>
    	 <span style="color:#75715e">// 任务为空，抛异常
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>workerCountOf<span style="color:#f92672">(</span>c<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;</span> corePoolSize<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 当前有核心线程空闲，调用核心线程执行任务
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>addWorker<span style="color:#f92672">(</span>command<span style="color:#f92672">,</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">))</span>
                <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
            c <span style="color:#f92672">=</span> ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
            <span style="color:#75715e">// 若 addWorker 调用核心线程失败，则更新 ctl，执行下方代码，将任务添加进队列
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
    
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isRunning<span style="color:#f92672">(</span>c<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span> workQueue<span style="color:#f92672">.</span><span style="color:#a6e22e">offer</span><span style="color:#f92672">(</span>command<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 当前核心线程无空闲，则将任务添加到任务队列中
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> recheck <span style="color:#f92672">=</span> ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span> isRunning<span style="color:#f92672">(</span>recheck<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span> remove<span style="color:#f92672">(</span>command<span style="color:#f92672">))</span>
                reject<span style="color:#f92672">(</span>command<span style="color:#f92672">);</span>
            <span style="color:#75715e">// 再次检查线程池状态，不在 RUNNING 状态则从队列中移除任务，执行拒绝策略
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>workerCountOf<span style="color:#f92672">(</span>recheck<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span>
                addWorker<span style="color:#f92672">(</span><span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">);</span>
            <span style="color:#75715e">// 若线程池处于 RUNNING 状态，但没有 worker，则创建线程
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
    
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>addWorker<span style="color:#f92672">(</span>command<span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">))</span>
            reject<span style="color:#f92672">(</span>command<span style="color:#f92672">);</span>
   	<span style="color:#75715e">// 如果任务队列满了无法加入，则会创建非核心线程执行任务，若失败则执行拒绝策略
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</code></pre></div><p>然后再看一下在 execute() 中多次被调用的 <code>addWorker(Runnable firstTask, boolean core)</code> 方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">addWorker</span><span style="color:#f92672">(</span>Runnable firstTask<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> core<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        retry<span style="color:#f92672">:</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(;;)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">int</span> rs <span style="color:#f92672">=</span> runStateOf<span style="color:#f92672">(</span>c<span style="color:#f92672">);</span>

            <span style="color:#75715e">// Check if queue empty only if necessary.
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>rs <span style="color:#f92672">&gt;=</span> SHUTDOWN <span style="color:#f92672">&amp;&amp;</span>
                <span style="color:#f92672">!</span> <span style="color:#f92672">(</span>rs <span style="color:#f92672">==</span> SHUTDOWN <span style="color:#f92672">&amp;&amp;</span>
                   firstTask <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span>
                   <span style="color:#f92672">!</span> workQueue<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()))</span>
                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
            <span style="color:#75715e">// 
</span><span style="color:#75715e"></span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(;;)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">int</span> wc <span style="color:#f92672">=</span> workerCountOf<span style="color:#f92672">(</span>c<span style="color:#f92672">);</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>wc <span style="color:#f92672">&gt;=</span> CAPACITY <span style="color:#f92672">||</span>
                    wc <span style="color:#f92672">&gt;=</span> <span style="color:#f92672">(</span>core <span style="color:#f92672">?</span> corePoolSize <span style="color:#f92672">:</span> maximumPoolSize<span style="color:#f92672">))</span>
                    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
                <span style="color:#75715e">// 根据 core 的布尔值创建核心 / 非核心线程，若当前线程数以达到预设值，则返回 false
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>compareAndIncrementWorkerCount<span style="color:#f92672">(</span>c<span style="color:#f92672">))</span>
                    <span style="color:#66d9ef">break</span> retry<span style="color:#f92672">;</span>
                <span style="color:#75715e">// 满足可以新增线程的条件，CAS 更新 ctl，跳出循环
</span><span style="color:#75715e"></span>                c <span style="color:#f92672">=</span> ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>  <span style="color:#75715e">// Re-read ctl
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>runStateOf<span style="color:#f92672">(</span>c<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> rs<span style="color:#f92672">)</span>
                    <span style="color:#66d9ef">continue</span> retry<span style="color:#f92672">;</span>
                <span style="color:#75715e">// else CAS failed due to workerCount change; retry inner loop
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// CAS 更新失败，若线程池状态没变，重复当前 for 循环，状态变了则从 retry 重来
</span><span style="color:#75715e"></span>            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">boolean</span> workerStarted <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">boolean</span> workerAdded <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
        Worker w <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
            w <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Worker<span style="color:#f92672">(</span>firstTask<span style="color:#f92672">);</span>               <span style="color:#75715e">// 这里会创建一个新的线程
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">final</span> Thread t <span style="color:#f92672">=</span> w<span style="color:#f92672">.</span><span style="color:#a6e22e">thread</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>t <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>             <span style="color:#75715e">// 若线程创建失败，则跳至最下方 finally
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">final</span> ReentrantLock mainLock <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">mainLock</span><span style="color:#f92672">;</span>
                mainLock<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span>
                <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                    <span style="color:#75715e">// Recheck while holding lock.
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// Back out on ThreadFactory failure or if
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// shut down before lock acquired.
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">int</span> rs <span style="color:#f92672">=</span> runStateOf<span style="color:#f92672">(</span>ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">());</span>

                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>rs <span style="color:#f92672">&lt;</span> SHUTDOWN <span style="color:#f92672">||</span>
                        <span style="color:#f92672">(</span>rs <span style="color:#f92672">==</span> SHUTDOWN <span style="color:#f92672">&amp;&amp;</span> firstTask <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>t<span style="color:#f92672">.</span><span style="color:#a6e22e">isAlive</span><span style="color:#f92672">())</span> <span style="color:#75715e">// precheck that t is startable
</span><span style="color:#75715e"></span>                            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalThreadStateException<span style="color:#f92672">();</span>
                        workers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>w<span style="color:#f92672">);</span>
                        <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> workers<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">();</span>
                        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>s <span style="color:#f92672">&gt;</span> largestPoolSize<span style="color:#f92672">)</span>
                            largestPoolSize <span style="color:#f92672">=</span> s<span style="color:#f92672">;</span> 
                        workerAdded <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
                    <span style="color:#f92672">}</span>
                <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
                    mainLock<span style="color:#f92672">.</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>
                <span style="color:#f92672">}</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>workerAdded<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    t<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>                   <span style="color:#75715e">// 启动这个线程，开始工作
</span><span style="color:#75715e"></span>                    workerStarted <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span> workerStarted<span style="color:#f92672">)</span>
                addWorkerFailed<span style="color:#f92672">(</span>w<span style="color:#f92672">);</span>
            <span style="color:#75715e">// 创建线程失败，则执行 addWorkerFailed(w)
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> workerStarted<span style="color:#f92672">;</span>         <span style="color:#75715e">// 返回是否成功创建线程并开始任务
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="如何做到线程复用">如何做到线程复用</h3>
<p>再看下 Worker 类，在调用它的构造器的时候会新建一个线程，并且它实现了 Runnable 接口，是一个线程任务，所以当 <code>addWorker(Runnable firstTask, boolean core)</code> 方法调用 <code>t.start()</code> 时，会调用 Worker 中的 run() 及 <code>runWorker(Worker w)</code> 方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Worker</span>
        <span style="color:#66d9ef">extends</span> AbstractQueuedSynchronizer
        <span style="color:#66d9ef">implements</span> Runnable      <span style="color:#75715e">// 实现了 Runnable 接口
</span><span style="color:#75715e"></span>    <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">final</span> Thread thread<span style="color:#f92672">;</span>
        Runnable firstTask<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">long</span> completedTasks<span style="color:#f92672">;</span>
        
        Worker<span style="color:#f92672">(</span>Runnable firstTask<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            setState<span style="color:#f92672">(-</span>1<span style="color:#f92672">);</span> <span style="color:#75715e">// inhibit interrupts until runWorker
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">firstTask</span> <span style="color:#f92672">=</span> firstTask<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">thread</span> <span style="color:#f92672">=</span> getThreadFactory<span style="color:#f92672">().</span><span style="color:#a6e22e">newThread</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">);</span>  <span style="color:#75715e">// 调用构造器时，会新开一个线程
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>       <span style="color:#75715e">// 线程开始工作时调用这个 run 
</span><span style="color:#75715e"></span>            runWorker<span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>

	<span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">runWorker</span><span style="color:#f92672">(</span>Worker w<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Thread wt <span style="color:#f92672">=</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">();</span>
        Runnable task <span style="color:#f92672">=</span> w<span style="color:#f92672">.</span><span style="color:#a6e22e">firstTask</span><span style="color:#f92672">;</span>
        w<span style="color:#f92672">.</span><span style="color:#a6e22e">firstTask</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        w<span style="color:#f92672">.</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span> <span style="color:#75715e">// allow interrupts
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">boolean</span> completedAbruptly <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>task <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>task <span style="color:#f92672">=</span> getTask<span style="color:#f92672">())</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 执行自己的任务或者从任务队列中取出一个任务
</span><span style="color:#75715e"></span>                w<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span>
                <span style="color:#75715e">// 将 Worker 自身上锁
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>runStateAtLeast<span style="color:#f92672">(</span>ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(),</span> STOP<span style="color:#f92672">)</span> <span style="color:#f92672">||</span>
                     <span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">interrupted</span><span style="color:#f92672">()</span> <span style="color:#f92672">&amp;&amp;</span>
                      runStateAtLeast<span style="color:#f92672">(</span>ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(),</span> STOP<span style="color:#f92672">)))</span> <span style="color:#f92672">&amp;&amp;</span>
                    <span style="color:#f92672">!</span>wt<span style="color:#f92672">.</span><span style="color:#a6e22e">isInterrupted</span><span style="color:#f92672">())</span>
                    wt<span style="color:#f92672">.</span><span style="color:#a6e22e">interrupt</span><span style="color:#f92672">();</span>
                <span style="color:#75715e">// 检测线程池状态，若线程池处于中断状态，当前线程将中断
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                    beforeExecute<span style="color:#f92672">(</span>wt<span style="color:#f92672">,</span> task<span style="color:#f92672">);</span>       <span style="color:#75715e">// 执行 beforeExecute
</span><span style="color:#75715e"></span>                    Throwable thrown <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
                    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                        task<span style="color:#f92672">.</span><span style="color:#a6e22e">run</span><span style="color:#f92672">();</span>       <span style="color:#75715e">// 执行任务
</span><span style="color:#75715e"></span>                    <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>RuntimeException x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        thrown <span style="color:#f92672">=</span> x<span style="color:#f92672">;</span> <span style="color:#66d9ef">throw</span> x<span style="color:#f92672">;</span>
                    <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>Error x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        thrown <span style="color:#f92672">=</span> x<span style="color:#f92672">;</span> <span style="color:#66d9ef">throw</span> x<span style="color:#f92672">;</span>
                    <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>Throwable x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        thrown <span style="color:#f92672">=</span> x<span style="color:#f92672">;</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error<span style="color:#f92672">(</span>x<span style="color:#f92672">);</span>
                    <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
                        afterExecute<span style="color:#f92672">(</span>task<span style="color:#f92672">,</span> thrown<span style="color:#f92672">);</span>      <span style="color:#75715e">// 执行 afterExecute
</span><span style="color:#75715e"></span>                    <span style="color:#f92672">}</span>
                <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span> n
                    task <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
                    w<span style="color:#f92672">.</span><span style="color:#a6e22e">completedTasks</span><span style="color:#f92672">++;</span>
                    w<span style="color:#f92672">.</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>   <span style="color:#75715e">// 解锁 Worker
</span><span style="color:#75715e"></span>                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
            completedAbruptly <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
            processWorkerExit<span style="color:#f92672">(</span>w<span style="color:#f92672">,</span> completedAbruptly<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
        

</code></pre></div><p>⾸先去执⾏创建这个 worker 时就有的任务，当执⾏完这个任务后，worker 的⽣命周期并没有结束，在 while 循环中，worker 会不断地调⽤ <code>getTask()</code> ⽅法从阻塞队列中获取任务然后调⽤ <code>task.run()</code> 执⾏任务，从⽽达到 <strong>复⽤线程</strong> 的⽬的。只要 getTask() ⽅法不返回 null，此线程就不会退出。</p>
<p>当然，核⼼线程池中创建的线程想要拿到阻塞队列中的任务，先要判断线程池的状态，如果 STOP 或 TERMINATED，返回 null 。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">private</span> Runnable <span style="color:#a6e22e">getTask</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">boolean</span> timedOut <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span> <span style="color:#75715e">// Did the last poll() time out?
</span><span style="color:#75715e"></span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(;;)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">int</span> rs <span style="color:#f92672">=</span> runStateOf<span style="color:#f92672">(</span>c<span style="color:#f92672">);</span>

            <span style="color:#75715e">// Check if queue empty only if necessary.
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>rs <span style="color:#f92672">&gt;=</span> SHUTDOWN <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span>rs <span style="color:#f92672">&gt;=</span> STOP <span style="color:#f92672">||</span> workQueue<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()))</span> <span style="color:#f92672">{</span>
                decrementWorkerCount<span style="color:#f92672">();</span>
                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>

            <span style="color:#66d9ef">int</span> wc <span style="color:#f92672">=</span> workerCountOf<span style="color:#f92672">(</span>c<span style="color:#f92672">);</span>

            <span style="color:#75715e">// Are workers subject to culling?
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">boolean</span> timed <span style="color:#f92672">=</span> allowCoreThreadTimeOut <span style="color:#f92672">||</span> wc <span style="color:#f92672">&gt;</span> corePoolSize<span style="color:#f92672">;</span>
            <span style="color:#75715e">// allowCoreThreadTimeOut 变量默认是 false，核⼼线程即使空闲也不会被销毁
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 如果为 true，核⼼线程在 keepAliveTime 内仍空闲则会被销毁。
</span><span style="color:#75715e"></span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>wc <span style="color:#f92672">&gt;</span> maximumPoolSize <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>timed <span style="color:#f92672">&amp;&amp;</span> timedOut<span style="color:#f92672">))</span>
                <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span>wc <span style="color:#f92672">&gt;</span> 1 <span style="color:#f92672">||</span> workQueue<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()))</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>compareAndDecrementWorkerCount<span style="color:#f92672">(</span>c<span style="color:#f92672">))</span>
                    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
            <span style="color:#75715e">// 如果运⾏线程数超过了最⼤线程数，但是缓存队列已经空了，这时递减 worker 数量。
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 如果有设置允许线程超时或者线程数量超过了核⼼线程数量，
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 并且线程在规定时间内均未 poll 到任务，且队列为空则递减 worker 数量
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">continue</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>

            <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                Runnable r <span style="color:#f92672">=</span> timed <span style="color:#f92672">?</span>
                    workQueue<span style="color:#f92672">.</span><span style="color:#a6e22e">poll</span><span style="color:#f92672">(</span>keepAliveTime<span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">NANOSECONDS</span><span style="color:#f92672">)</span> <span style="color:#f92672">:</span>
                    workQueue<span style="color:#f92672">.</span><span style="color:#a6e22e">take</span><span style="color:#f92672">();</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>r <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                    <span style="color:#66d9ef">return</span> r<span style="color:#f92672">;</span>
                timedOut <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException retry<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                timedOut <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>核⼼线程的会 <strong>⼀直</strong> 卡在 workQueue.take() ⽅法，被阻塞并挂起，不会占⽤ CPU 资源，直到拿到 Runnable 然后返回（当然如果 allowCoreThreadTimeOut 设置为 true，那么核⼼线程就会去调⽤ poll ⽅法，因为 poll 可能会返回 null，所以这时候核⼼线程满⾜超时条件也会被销毁）。</p>
<p>⾮核⼼线程会 workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) ，如果超时还没有拿到，下⼀次循环判断 compareAndDecrementWorkerCount 就会返回 true，导致 getTask() 返回 null，Worker 对象的 run() ⽅法循环体的判断为 null，就会执行 <code>processWorkerExit(w, completedAbruptly)</code> 线程被系统回收。</p>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>Chenghao.Zheng </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://nervousorange.github.io/2020/java-threadpool/>https://nervousorange.github.io/2020/java-threadpool/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a> 进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://nervousorange.github.io/tags/java/">
                    #Java</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://nervousorange.github.io/">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://nervousorange.github.io/2020/database-mysql/" class="prev" rel="prev" title="Database：MySQL 数据库"><i class="iconfont icon-left"></i>&nbsp;Database：MySQL 数据库</a>
         
        
        <a href="https://nervousorange.github.io/2020/deploy/" class="next" rel="next" title="Java：程序的部署和 Nginx 负载均衡">Java：程序的部署和 Nginx 负载均衡&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2019 - 2021</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://nervousorange.github.io/">Chenghao.Zheng</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>













    
     <link href="//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css" rel="stylesheet">  
      
     <script src="/js/vendor_gallery.min.js" async="" ></script>
    
  



     </div>
  </body>
</html>
