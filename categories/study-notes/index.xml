<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Study notes on 人间一场大梦</title>
    <link>http://chenghao.monster/categories/study-notes/</link>
    <description>Recent content in Study notes on 人间一场大梦</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 12 Jan 2020 14:49:47 +0100</lastBuildDate>
    
	<atom:link href="http://chenghao.monster/categories/study-notes/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java：初识多线程、原理及实现</title>
      <link>http://chenghao.monster/2020/java%E5%88%9D%E8%AF%86%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sun, 12 Jan 2020 14:49:47 +0100</pubDate>
      
      <guid>http://chenghao.monster/2020/java%E5%88%9D%E8%AF%86%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</guid>
      <description>多线程原理 1. 为什么需要多线程 1.1 Java 代码的执行是同步阻塞模型 Java 代码在执行的时候，是从 main 代码块开始逐行执行，但当当前代码耗时过长时，下一行的代码就必须等待当前任务执行完毕，代码才能继续往下执行。
1.2 CPU的运算实在太快了 取主频为 3GHz CPU 为例，CPU 执行单个指令所需的时间约为 0.3ns；与之相对的，在内存中进行读取1MB大小文件所需时间大概为 250us，SSD随机读取耗时约为 1ms，HDD约为 20ms。（推荐阅读：我是一个CPU：这个世界慢！死！了！）
相比与内存，硬盘，网络传输，CPU 的运算实在是太快了，但是由于阻塞模型，如若当前代码执行的是较为耗时的 IO 操作，线程中的下一个任务就必须等待当前任务结束才能继续执行。使得单线程的代码执行非常没有效率，另外也浪费了 CPU 的运算性能。
2. Java 线程简介 2.1 多线程的方法栈 一般的 Java 程序都是从启动类的 main 函数入口开始执行，随着 main 函数的结束而停止. 这条执行路径就是 Java 程序的主线程。Java 虚拟机允许拥有同时运行多个线程，当新线程运行时，就会在栈中生成一个新的方法栈，新线程独享单独的执行流和局部变量，而静态变量则是被所有线程共享的。
2.2 多线程的性能 使用多线程就只有好处没有坏处吗？并不是，使用多线程是要付出代价的，如果没有耗时的任务，使用多线程，效率反而更低，因为CPU 在线程间的切换也需要耗费时间。引用知乎上看到的一句话：
 多线程在 CPU 密集型的作业下的确不能提高性能甚至更浪费时间，但是在 IO 密集型的作业下则可以提升性能（或者更准确点说叫平均响应时间）。
 由上得出的结论是，正确的使用多线程可以提高程序的运行效率。
3. 多线程问题的来源 3.1 多线程下的数据安全问题 多线程同时对一个共享的全局变量进行非原子操作将会引发严重的数据安全问题。
  原子操作可理解为不可分隔的操作，而非原子操作例如 i++ 则可以分解为 temp = i; temp = temp + 1; i = temp; 这样的取值、运算、赋值三个独立的操作。</description>
    </item>
    
    <item>
      <title>Java：Collection、Map 工具类及常见方法</title>
      <link>http://chenghao.monster/2020/javacollectionsarrays%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%8F%8A%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 02 Jan 2020 16:11:47 +0100</pubDate>
      
      <guid>http://chenghao.monster/2020/javacollectionsarrays%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%8F%8A%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/</guid>
      <description>本篇介绍 Java 中的集合类框架的基础知识，其源码实现、相关面试题会在之后更新，敬请期待。
一、Collection 继承体系 1. 集合 Collection 介绍  为什么需要集合？  集合使 Java 可以处理多个同类型的对象（List / Set），亦或是多个键值对类型的数据（Map）。   集合的常用功能：  添加：add(Object obj)、addAll(Collection c)； 删除：clear()、remove(Object)、removeAll(Collection)； 判断包含：isEmpty()、contains(Object)、containsAll(Collection)；  contains 方法进行判定时，会调用 equals 方法，所以在用集合存储引用对象（非原生数据类型）时需要重写 equals 和 HashCode 方法。   遍历获取：Iteratoriterator()； 长度：size()； 交集：retainAll(Collection c)； 若有元素被移除，此操作会改变原有实例集合。   迭代器（Iterator）：  以内部类的方式遍历集合中的元素，有以下方法：  hasNext()； next()； remove()；   构造思路：  写一个 iterator() 方法返回一个自己的迭代器， 创建一个自己的迭代器继承 Iterator 接口，重写接口的三个方法。 使用时：用 iterator() 创建迭代器，再用迭代器去调用其中的三个方法。      2. List：对付顺序的好帮手  List 是插入有序的，元素可重复的。 List 有个自己的迭代器 ListIterator ，比普通的迭代器多出几个功能：向前遍历、添加元素、设置元素等。 List 常用的实现类有  ArrayList ：底层数据结构是数组，线程不安全。 LinkedList ：底层数据结构是链表，线程不安全。 Vector ：底层数据结构是数组，线程安全。    3.</description>
    </item>
    
    <item>
      <title>Maven：包管理与冲突解决</title>
      <link>http://chenghao.monster/2019/maven%E5%8C%85%E7%AE%A1%E7%90%86%E4%B8%8E%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/</link>
      <pubDate>Sun, 29 Dec 2019 23:37:47 +0100</pubDate>
      
      <guid>http://chenghao.monster/2019/maven%E5%8C%85%E7%AE%A1%E7%90%86%E4%B8%8E%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/</guid>
      <description>Maven 作为一个强大的项目管理工具，可以自动管理 Java 包的传递性依赖，解决包的依赖冲突并对依赖的 scope 进行控制。 本篇对其功能和用法做简单的介绍。
一、包管理的必要性  JVM 的作用就是执行一个类的字节码，当它需要加载一个新的类时，就会去 Classpath 中寻找这个类。包的 全限定类名 是包的唯一标识，当 Classpath 中出现（不同版本的）同名包时，JVM 会选择 Classpath中出现最早的包 进行加载（Classpath Hell）。 包的调用存在传递性依赖，即你所调用的包同时还调用了其他别的包，这会导致一个项目的实现需要调用相当数量的第三方包，使包的管理与更新成了一个很大的难题。（同时也使自己的代码在别人的机器上不能正常的运行）  二、Maven：包管理工具 1. 包的约定与语义化版本  Maven 收录了几乎所有的 Java 包保存在其远程的 中央仓库，并对包的 ID 给出了三个约定，分别为 Groupid、Artifactid、version ，用结构化的方式，把包分门别类的放到一起，实现了方便检索的目的。 同时，包的版本号受到了语义化版本控制规范   2. 自动化包管理  当在 pom.xml 中引入一个第三方包的时候，Maven 就知道去哪里下载了，并且把它的传递性依赖也同时下载至本地 ~\.m2。你可以删除该文件夹中的包，但在 maven 刷新 后，maven 会为你自动下载所需要的包，这也方便了在他人机器上跑自己的代码，或是在团队项目中便捷地管理所需要的包。 Maven 为包提供了三种 Scope：  compile、test、及 provided（只在编译有效，运行无效，适合运行时由他人提供 jar 包的场景）    三、Maven：包的冲突与解决 1. 包的冲突  当项目的不同位置调用了 不同版本 的某个类库时，就可能会发生包的冲突。因为 JVM 会自动调用在 Classpath 中出现的早的那个版本类库，导致运行时调用了错误版本的类库产生错误，同时我们也不能很好的去管理调用类库的版本。 常见的包冲突异常有：  NoSuchMethodError - AbstractMethodError - NoClassDefFoundError - ClassNotFoundError - LinkageError 等。    2.</description>
    </item>
    
    <item>
      <title>Git 与 Github 使用指北</title>
      <link>http://chenghao.monster/2019/git-%E4%B8%8E-github-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/</link>
      <pubDate>Thu, 26 Dec 2019 21:49:47 +0100</pubDate>
      
      <guid>http://chenghao.monster/2019/git-%E4%B8%8E-github-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/</guid>
      <description>本篇介绍实用的工具 Git 及 Github 的常用功能及其操作，如：代码的版本控制，远程备份，团队项目协作等。
一、Git 本地仓库 Git 工作流程：
0. 应用场景  代码版本管理 / 多版本代码开发 / 多版本代码合并  1. 安装 Git 参考伯克利课程 CS61b 中的教程安装 Git
2. 配置 Git git config --global user.name + 你的英文名 git config --global user.email + 你的邮箱 git config --global push.default simple git config --global core.quotepath false // 不会对0×80以上的字符进行quote，中文显示正常。 git config --global core.editor &amp;#34;code --wait&amp;#34; git config --global core.autocrlf input git config --global --list // 查看当前配置列表 vi ~/.</description>
    </item>
    
  </channel>
</rss>