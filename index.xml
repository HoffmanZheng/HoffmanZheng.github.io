<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>人间一场大梦</title>
    <link>https://hoffmanzheng.github.io/</link>
    <description>人间一场大梦</description>
    <generator>Hugo 0.156.0 &amp; FixIt v0.4.3-20260130042349-e23a50d7</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 09 Nov 2022 13:19:47 +0100</lastBuildDate>
    <atom:link href="https://hoffmanzheng.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>HTTP/2：漫谈 RFC 7540</title>
      <link>https://hoffmanzheng.github.io/2022/net-http-2/</link>
      <pubDate>Wed, 09 Nov 2022 13:19:47 +0100</pubDate>
      <guid>https://hoffmanzheng.github.io/2022/net-http-2/</guid>
      <category domain="https://hoffmanzheng.github.io/categories/reading-notes/">Reading Notes</category>
      <description>&lt;p&gt;HTTP/2 在引入头部字段压缩和允许单连接并发交换后，使更加高效的网络资源使用和更低的接收延迟成为可能。同时也引入了从服务端到客户端的主动推送。本篇结合 &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7540&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;RFC 7540&lt;/a&gt; 谈谈 HTTP version 2。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;前言&#34;&gt;&lt;span&gt;前言&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%89%8d%e8%a8%80&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;超文本传输协议是一个大获成功的协议，尽管如此，HTTP/1.1 使用的基础传输却有着会对当下的 &lt;strong&gt;应用性能&lt;/strong&gt; 造成不利影响的特性。具体地讲，HTTP/1.0 只允许在单个 TCP 连接中处理 &lt;strong&gt;一个&lt;/strong&gt; 请求，在 HTTP/1.1 新增请求管道后，也只实现了部分的并发请求，并仍遭受着头部阻塞。因此，HTTP/1.0 和 HTTP/1.1 的客户端为了实现并发并降低延迟，需要使用多个与服务端的连接来发送多个请求。此外，HTTP 头部字段经常是重复且冗余的，导致了不必要的网络流量，且拥塞窗口会被快速填充。这将在单个 TCP 连接处理多个请求时导致过度的延迟。&lt;/p&gt;&#xA;&lt;p&gt;HTTP/2 通过在基础连接中定义一个更优的 HTTP 语义映射来处理这些问题。具体地，它允许在同个连接中多个请求和响应消息的交织，并对 HTTP 头部字段采用了高效的编码。它还支持请求的优先级，让一些更重要的请求能够更快地完成，以此来提升性能。生成的协议对网络更加友好，因为相比 HTTP/1.x 只需使用更少的连接。这也意味着与其他流和长连接之间更少的竞争，反过来能更好地利用可用的网络容量。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;http-2-协议概览&#34;&gt;&lt;span&gt;HTTP 2 协议概览&lt;/span&gt;&#xA;  &lt;a href=&#34;#http-2-%e5%8d%8f%e8%ae%ae%e6%a6%82%e8%a7%88&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;HTTP/2 给 HTTP 语义提供了一个改良的传输，它支持 HTTP/1.1 的所有核心特征，但旨在某些方面变得更加高效。HTTP/2 的基础协议单元是一个帧 &lt;code&gt;frame&lt;/code&gt;，每个帧类型服务一个不同的目的。例如，&lt;code&gt;HEADERS&lt;/code&gt; 和 &lt;code&gt;DATA&lt;/code&gt; 帧组成了 HTTP 请求和响应的基础，其他帧类型如 &lt;code&gt;SETTINGS&lt;/code&gt;、&lt;code&gt;WINDOW_UPDATE&lt;/code&gt; 和 &lt;code&gt;PUSH_PROMISE&lt;/code&gt; 被用来支持 HTTP/2 的其他特性。&lt;/p&gt;&#xA;&lt;p&gt;请求的多路复用通过让每个 HTTP 请求/响应与它自己的流交换来实现。流是 &lt;strong&gt;各自独立&lt;/strong&gt; 的，因此一个被阻塞的请求或响应不会阻止其他流的进程。流的控制和优先级使使用多路的流成为可能。流的控制保证了被接收者使用的数据被传输了。优先级保证了有限的资源能被首先引导至更重要的流上。&lt;/p&gt;&#xA;&lt;p&gt;HTTP/2 增加了一个新的交互模式，借此一个服务可以向客户端推送响应。服务推送允许一个服务在权衡网络使用和潜在的延迟收益后，向客户端任意的发送（预计它将会需要的）数据。服务端通过合成一个发送 &lt;code&gt;PUSH_PROMISE&lt;/code&gt; 帧的请求来完成这个。随后服务端就能在一个独立的流中给这个合成的请求发送一个响应。因为在连接中使用的 HTTP 头部字段可能包含了大量多余的数据，包含它们的帧可以被压缩。这对通常情况下的请求大小有着特殊的优势，且允许许多请求被压缩在一个包里。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;http-2-连接&#34;&gt;&lt;span&gt;HTTP 2 连接&lt;/span&gt;&#xA;  &lt;a href=&#34;#http-2-%e8%bf%9e%e6%8e%a5&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;一个 HTTP/2 连接是一个运行在 TCP 连接之上的应用层协议。客户端是 TCP 连接的初始化器。HTTP/2 使用与 HTTP/1.1 相同的 http 和 https URI 帧。HTTP/2 共享着相同的默认端口，http URIs 80，https URIs 443。因此，对于目标资源比如 “http://example.org/foo” 或者 “https://example.com/bar” 的 URLs 的请求实现被要求首先判断（客户端希望立即与之建立连接的）上游服务是否支持 HTTP/2。&lt;/p&gt;&#xA;&lt;p&gt;客户端可以在没有先验知识的情况下通过 HTTP &lt;strong&gt;升级&lt;/strong&gt; 机制，在 HTTP/1.1 请求中包含一个带有 h2c 令牌的升级头字段和一个 &lt;code&gt;HTTP2-Settings&lt;/code&gt; 头字段来支持 HTTP/2。（基于 TLS 的 HTTP/2 使用 &lt;code&gt;h2&lt;/code&gt; 作为协议标识符）&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;GET / HTTP/1.1&#xA;Host: Server.example.com&#xA;Connection: Upgrade, HTTP2-Settings&#xA;Upgrade: h2c&#xA;HTTP2-Settings: &amp;lt;base64url encoding of HTTP/2 SETTINGS payload&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个不支持 HTTP/2 的服务端能够在缺少升级头字段的情况下响应请求。而支持 HTTP/2 的服务会给出一个 101 交换协议的响应。在一个结束 101 响应的空行后，服务可以开始发送 HTTP/2 帧。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 不支持 HTTP/2 的服务&#xA;HTTP/1.1 200 OK&#xA;Content-Length: 243&#xA;Content-Type: text/html&#xA;...&#xA;&#xA;// 支持 HTTP/2 的服务&#xA;HTTP/1.1 101 Switching Protocols&#xA;Connection: Upgrade&#xA;Upgrade: h2c&#xA;&#xA;[ HTTP/2 connection ... ]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个提前发送来升级的请求会被认定为流 1，在 HTTP/2 连接开始后，流 1 会被用来作响应。因为升级只会应用在接下来的连接，客户端在发送 HTTP2-Settings 头字段时必须也发送 HTTP2-Settings 作为连接头字段的连接选项来防止请求被转发。&lt;/p&gt;&#xA;&lt;p&gt;在有先验知识的情况下，客户端必须发送连接引语和 HTTP/2 帧，服务器就可以通过连接引语来识别这些连接。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;头部压缩与解压&#34;&gt;&lt;span&gt;头部压缩与解压&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%a4%b4%e9%83%a8%e5%8e%8b%e7%bc%a9%e4%b8%8e%e8%a7%a3%e5%8e%8b&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;与在 HTTP/1 中相同，一个 HTTP/2 的头部字段是一个名字对应一个或者多个值。头部字段被用在 HTTP 请求和响应的消息中，在服务推送操作中也是。头部列表是许多头部字段的集合，当在连接中传送时，头部列表会被 HTTP 头部 &lt;strong&gt;压缩序列化&lt;/strong&gt; 成一个头部块。序列化后的头部块随后被划分成一个或多个八位序列，称头部块片段，并在 HEADERS, PUSH_PROMISE 或者 CONTINUATION 帧中被传送。&lt;/p&gt;&#xA;&lt;p&gt;接收节点将通过拼接片段来装配头部块，随后解压头部块来重现这个头部列表。头部压缩是有状态的，一个压缩和解压的上下文会在整个连接中被使用。一个在头部块的解压错误会被当作是一个压缩错误的连接异常。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;流与多路复用&#34;&gt;&lt;span&gt;流与多路复用&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%b5%81%e4%b8%8e%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;在 HTTP/2 连接中流是一个在客户端和服务端之间，独立且双向的帧交换序列。一个 HTTP/2 连接能够包含 &lt;strong&gt;多个&lt;/strong&gt; 并发的流，它可以被客户端或服务端单方面地创建和使用或者共享。帧们在流中被发送的顺序非常重要，接收者会按照顺序处理帧们。&#xA;下图展示了流的状态转变图，节点与流的创建并不相关，它们可以由各个节点单方面地创建。流有以下几种状态：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;空闲： 所有的流都从空闲状态开始，发送或者接收一个 HEADERS 帧会导致流变成开放状态。在另一个流发出 PUSH_PROMISE 会预留一个空闲的流，并使其变成本地预留状态。在收到另一个流的 PUSH_PROMISE 后会预留一个空闲的流，并使其称为远程预留状态。&lt;/li&gt;&#xA;&lt;li&gt;开放：处于开放状态的流被用来在同辈间发送任意类型的帧。在发送 END_STREAM 标识后将进入本地半关闭的流状态，在收到 END_STREAM 标识后将进入远程半关闭的状态。&lt;/li&gt;&#xA;&lt;li&gt;本地预留：通过发送 PUSH_PROMISE 允诺的流，PUSH_PROMISE 通过将被远程同辈初始化的流与一个开放的流关联来预留一个空闲的流。在这个状态，节点可以发送一个 HEADERS 帧，这会导致流以远程半关闭状态打开。&lt;/li&gt;&#xA;&lt;li&gt;远程预留：远程预留状态的流是被一个远程同辈预留的，在这个状态下，在收到一个 HEADERS 帧后会导致这个流转变到本地半关闭状态。&lt;/li&gt;&#xA;&lt;li&gt;本地半关闭：可在接收或者发送包含 RST_STREAM 标识的流或者发送 END_STREAM 后变成关闭状态。&lt;/li&gt;&#xA;&lt;li&gt;远程半关闭：可在接收或者发送包含 RST_STREAM 标识的流或者接收 END_STREAM 后变成关闭状态。&lt;/li&gt;&#xA;&lt;li&gt;关闭：关闭是一个终止状态。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/http-2-stream.png&#39; alt=&#34;/images/http-2-stream.png&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;流的并发&#34;&gt;&lt;span&gt;流的并发&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%b5%81%e7%9a%84%e5%b9%b6%e5%8f%91&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;最大并发的流数量由各个节点设置且只应用于收到这个设置的同辈。也就是说，客户端指定服务端可以初始化的最大并发流数量，服务端指定客户端能够初始化的最大并发流的数量。这个流的数量指在开放状态和半关闭状态的流，而在预留状态的流则不受这个限制。想要降低最大流并发数的节点可以关闭多余的流或者。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;流的控制&#34;&gt;&lt;span&gt;流的控制&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%b5%81%e7%9a%84%e6%8e%a7%e5%88%b6&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;使用流实现多路复用会在 TCP 连接上引入冲突，导致流被阻塞。流的控制可以保证在同个连接上的流不会破坏性地相互影响。HTTP/2 通过使用 &lt;code&gt;WINDOW_UPDATE&lt;/code&gt; 帧来提供流的控制。HTTP/2 流控旨在不改动协议的前提下允许使用一个流控算法的变种。流控是针对单个连接的，接收者会广播他们准备在一个流和整个连接上接收多少个八位字节（初始为 65535），而发送者必须尊重接收者强加的流控限制。&lt;/p&gt;&#xA;&lt;p&gt;只有 DATA 帧需要遵守流的控制，其他帧并不会消耗流控窗口的空间，这保证了重要的控制帧不会被流的控制阻塞。HTTP/2 只定义了 WINDOW_UPDATE 帧的格式和术语，并没有指定具体的实现，可以选择任何满足需求的算法。实现还应负责管理请求和响应根据优先级发送，避免请求的头部行阻塞，管理新的流的创建。&lt;/p&gt;&#xA;&lt;p&gt;流控被设计用来保护那些 &lt;strong&gt;资源有限&lt;/strong&gt; 的节点，比如一个需要在许多连接间共享内存，且拥有一个较慢的上游连接和一个较快的下游连接的代理。流控着手于接收者无法在一个流上处理数据，但仍想继续在这个连接的其他流上处理数据的场景。不需要此功能的开发可以将通告将流控窗口设置为最大值 2^31-1，并在接收到任何数据后都发送这个 WINDOW_UPDATE 帧来更新窗口，这会使接收者的流控失效。相反地，发送方会遵守接收者建议的流控窗口。资源受限（比如内存）的开发可以使用流控来限制同辈节点消耗的内存量，然而，如果在缺少带宽延迟产品知识的情况下使用流控会导致网络资源次优的使用可用性。即使拥有当前带宽延迟产品的全部知识，实现流控也会相当 &lt;strong&gt;困难&lt;/strong&gt;。当在使用流控时，接收者必须及时读取 TCP 接收缓冲，否则可能导致死锁。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;流的优先级&#34;&gt;&lt;span&gt;流的优先级&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%b5%81%e7%9a%84%e4%bc%98%e5%85%88%e7%ba%a7&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;客户端可以在 HEADERS 帧给一个流指定一个优先级，此外可以使用 &lt;code&gt;PRIORITY&lt;/code&gt; 帧来改变一个流的优先级。使用优先级可以让节点处理并发流的时候有侧重地分配资源，更重要的是，优先级可以在发送量受限时选择要传输的帧。可以将流标记其依赖其他流的完成来提高它的优先级，每个依赖指定一个相对比重，用来决定分配给依赖同个流的流们可用资源的相对比例。它并不会保证流与流之间特殊的处理或传输顺序，因此优先级只是一个建议。&lt;/p&gt;&#xA;&lt;p&gt;依赖同个父流的两个流之间并没有一个排序，比如流 B 和 C 都依赖流 A，这时创建一个同样依赖流 A 的流 D，其结果是流 A 被流 B, C, D 分别依赖。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/http-2-stream-dependency.jpg&#39; alt=&#34;/images/http-2-stream-dependency.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;独家 &lt;code&gt;excluse&lt;/code&gt; 标识可以让一个流变成其父流的单独依赖，在上述例子中，如果流 D 被创建成为流 A 的独家依赖，这会使流 D 变成流 B 和 C 的父依赖。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/http-2-stream-dependency-2.jpg&#39; alt=&#34;/images/http-2-stream-dependency-2.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;服务端推送&#34;&gt;&lt;span&gt;服务端推送&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%8e%a8%e9%80%81&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;HTTP/2 允许服务端向客户端端推送响应，这在客户端需要这些响应来处理原始请求时会很有用。PUSH_PROMISE 帧会被服务端发送在任一客户端初始的流上，其中包含完整的请求头字段，且推送的响应要与具体的客户端请求相关联。&lt;/p&gt;&#xA;&lt;p&gt;发送 &lt;code&gt;PUSH_PROMISE&lt;/code&gt; 帧将为服务端创建一个本地预留状态的流，给客户端一个远程预留的流。随后客户端可以开始递送响应，并将服务端侧流置为远程半关闭状态，客户端侧的流置为本地半关闭状态，在推送以 &lt;code&gt;END_STREAM&lt;/code&gt; 帧结束后，再将流置为已关闭状态。如果客户端决定不想接收服务端的推送或者服务端在开始推送时花费过长的时间，客户端可以发送一个 &lt;code&gt;RST_STREAM&lt;/code&gt; 帧。&lt;/p&gt;&#xA;&lt;p&gt;客户端在收到推送后必须鉴权服务端或者提供推送的代理，比如一个只给 example.com 提供证书的服务端并不被允许推送一个响应到 &lt;a href=&#34;https://www.example.org/doc&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;https://www.example.org/doc&lt;/a&gt;。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>重构：改善既有代码的设计</title>
      <link>https://hoffmanzheng.github.io/2022/code-refactor/</link>
      <pubDate>Mon, 02 May 2022 03:19:47 +0100</pubDate>
      <guid>https://hoffmanzheng.github.io/2022/code-refactor/</guid>
      <category domain="https://hoffmanzheng.github.io/categories/reading-notes/">Reading Notes</category>
      <description>&lt;p&gt;不知道大家有没有发现，编程活动的许多方面，都很难一次做对。可能是对代码的进一步理解，亦或是用户需求的又一次变化，当前的设计可能不再适合于需求。如果容许瑕疵存在，并进一步累积，代码就会变得越来越 &lt;strong&gt;复杂&lt;/strong&gt;。在这之后对代码进行的理解、修改或调试，就会变得益发困难起来。&lt;/p&gt;&#xA;&lt;p&gt;所谓重构，是在 &lt;strong&gt;不改变&lt;/strong&gt; 代码外在行为的前提下，对程序内部结构的修改，对其设计的改进。虽然重构并不是一件做起来轻松的事，它却能使软件工程拥有更长的生命力。本篇结合 &lt;a href=&#34;https://book.douban.com/subject/30468597/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;《重构 (第 2 版)》&lt;/a&gt; 从一个开发者的角度讲讲重构，包括但不限于：察觉代码的坏味道、如何安全地重构以及几种重构的场景。本篇不会事无巨细地介绍所有的重构手法，而旨在指出一些值得参考的重构思想。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;先聊聊测试&#34;&gt;&lt;span&gt;先聊聊测试&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%85%88%e8%81%8a%e8%81%8a%e6%b5%8b%e8%af%95&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;重构并 &lt;strong&gt;不总是安全&lt;/strong&gt; 的，正如代码的其他改动一样，重构也有可能引入新的 bug。如果当前的工程项目还没有覆盖自动测试，那笔者极力推荐在开始重构之前，先补全对于待重构代码的单元测试。&lt;/p&gt;&#xA;&lt;p&gt;在没有自动测试的情况下，开发者不得不频繁地在做出改动后手动调试测试程序的功能。这将花费很多时间和精力，并且也不够安全。编写 &lt;strong&gt;自动测试&lt;/strong&gt;，可以让计算机来帮我们执行规律且重复的测试动作，测试代码片段对传入参数做出的响应是否符合预期或发生变化。在每一次完成代码重构后，都可以从容地运行测试，来帮助我们检查代码的行为是否受到了影响。&lt;/p&gt;&#xA;&lt;p&gt;笔者曾就职于国内某民营企业，其部门的项目代码竟没有任何的测试代码，开发者只能在功能上线后再进行手动测试。就算这样，线上事故也频频发生，既存在新上线的功能无法达到预期的问题，也会有老的功能受到代码修改带来的影响。其实有很多的事故，在有了充足的自动测试后，都能被及早的发现，并且可以在很大程度上避免将这些问题暴露给我们的用户。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;代码的可读性&#34;&gt;&lt;span&gt;代码的可读性&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e4%bb%a3%e7%a0%81%e7%9a%84%e5%8f%af%e8%af%bb%e6%80%a7&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;作为优秀的程序员，我们的目的从来不只是写出计算机可以理解的代码，而是写出人类容易理解的代码。大多数开发者都认为，代码被阅读和被修改的次数远远多于它被编写的次数，而保持代码易读、易修改是重构努力的方向之一。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;提炼函数&#34;&gt;&lt;span&gt;提炼函数&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%8f%90%e7%82%bc%e5%87%bd%e6%95%b0&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;旧的项目大多都存在一些 &lt;strong&gt;重复代码&lt;/strong&gt;，在阅读时得加倍仔细，留意它们之间细微的差异，在修改时也必须找出所有的副本，这让开发者痛苦不已。对此，通常我们需要先尝试移动语句，将相似的部分放在一起，再提炼成一个函数并给它一个具有意义的名字。&lt;/p&gt;&#xA;&lt;p&gt;往往活得长的程序，其中的函数都比较短。可能初学者会觉得小函数的程序满是无穷无尽的委托调用，但和这种程序共处一段时间后，就能体会到它带来的好处 —— 更好的阐释力、且更易于分享。小函数让人易于理解的关键在于良好的命名，使代码的阅读者可以通过名字快速了解函数的作用。&lt;/p&gt;&#xA;&lt;p&gt;每当感觉需要用 &lt;strong&gt;注释&lt;/strong&gt; 来说明点什么的时候，我们也可以把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。注释通常能指出代码用途和实现手法之间的语义差异。如果代码前方有一行注释，可能就是在提醒你：可以将这段代码替换成一个函数，并在注释的基础上给这个函数命名。&lt;/p&gt;&#xA;&lt;p&gt;有的开发者会在代码复用时使用提炼函数，但更为合理的是，我们可以用提炼函数将代码的 &lt;strong&gt;意图&lt;/strong&gt; 与实现分开。如果一段代码需要花一段时间游览才能弄明白它到底在干什么，就应该将其提炼到一个函数中，并根据它所做的事为其命名。提炼函数的示例代码如下：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;function printOwing(invoice) {&#xA;  let outstanding = 0;&#xA;&#xA;  console.log(&amp;#34;***********************&amp;#34;);&#xA;  console.log(&amp;#34;**** Customer Owes ****&amp;#34;);&#xA;  console.log(&amp;#34;***********************&amp;#34;);&#xA;&#xA;  // calculate outstanding&#xA;  for (const o of invoice.orders) {&#xA;      outstanding &amp;#43;= o.amount;&#xA;  }&#xA;&#xA;  // record due date&#xA;  const today = Clock.today;&#xA;  invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() &amp;#43; 30);&#xA;&#xA;  // print details&#xA;  console.log(`name: ${invoice.customer}`);&#xA;  console.log(`amount: ${outstanding}`);&#xA;  console.log(`due: ${invoice.dueDate.toLocaleDateString()}`);&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过提炼代码，可以得到以下代码，代码的可读性得到的显著提高：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;function printOwing(invoice) {&#xA;  printBanner();&#xA;  const outstanding = calculateOutstanding(invoice);&#xA;  recordDueDate(invoice);&#xA;  printDetails(invoice, outstanding);&#xA;}&#xA;&#xA;function printBanner() {&#xA;  console.log(&amp;#34;***********************&amp;#34;);&#xA;  console.log(&amp;#34;**** Customer Owes ****&amp;#34;);&#xA;  console.log(&amp;#34;***********************&amp;#34;);&#xA;}&#xA;&#xA;function calculateOutstanding(invoice) {&#xA;  let result = 0;&#xA;  for (const o of invoice.orders) {&#xA;    result &amp;#43;= o.amount;&#xA;  }&#xA;  return result;&#xA;}&#xA;&#xA;function recordDueDate(invoice) {&#xA;  const today = Clock.today;&#xA;  invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() &amp;#43; 30);&#xA;}&#xA;&#xA;function printDetails(invoice, outstanding) {&#xA;  console.log(`name: ${invoice.customer}`);&#xA;  console.log(`amount: ${outstanding}`);&#xA;  console.log(`due: ${invoice.dueDate.toLocaleDateString()}`);&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;h4 class=&#34;heading-element&#34; id=&#34;函数变量改名&#34;&gt;&lt;span&gt;函数/变量改名&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%87%bd%e6%95%b0%e5%8f%98%e9%87%8f%e6%94%b9%e5%90%8d&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;命名可以说是编程中最难的事之一了，好的名字能让函数、模块、变量和类清晰地表名自己的功能和用法。很多开发者经常不愿意给程序元素改名，觉得不值得费这个劲，但好的名字能节省未来用来 &lt;strong&gt;猜谜&lt;/strong&gt; 上的大把时间。如果想不到一个好名字，说明背后很可能潜藏着更深的设计问题。&lt;/p&gt;&#xA;&lt;p&gt;比如有以下一段看起来不是很好理解的代码：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;function price(order) {&#xA;  // price is base price - quantity discount &amp;#43; shipping&#xA;  return order.quantity * order.itemPrice -&#xA;    Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 &amp;#43; &#xA;    Math.min(order.quantity * order.itemPrice * 0.1, 100);&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对其使用提炼变量就能使代码更容易理解，同时注释也就不需要了：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;function price(order) {&#xA;  const basePrice = order.quantity * order.itemPrice;&#xA;  const quantityDiscount = Math.max(0, order.quantity - 500) * order.itemPrice *0.05;&#xA;  const shipping = Math.min(basePrice * 0.1, 100);&#xA;  return basePrice - quantityDiscount &amp;#43; shipping;&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在函数命名时也有个小窍门：先写一句注释描述这个函数的用途，再把这句注释变成函数的名字。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;过长的参数列表&#34;&gt;&lt;span&gt;过长的参数列表&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e8%bf%87%e9%95%bf%e7%9a%84%e5%8f%82%e6%95%b0%e5%88%97%e8%a1%a8&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;有时候我们可以在代码中看到一些带着很多参数的函数，&lt;strong&gt;过长的参数列表&lt;/strong&gt; 显然并不是一个好的工程实践，通常也会困扰代码的阅读者。如果一组数据项总是结伴同行，出没于一个又一个函数，我们可以将其组织成新的数据对象，这样既可以缩短函数的参数列表，也能使所有使用该数据对象的函数都使用同样的名字来访问其中的元素，提升代码的一致性。如果可以通过查询获取另一个参数的值，也可以使用以查询取代参数来减少参数的个数。&lt;/p&gt;&#xA;&lt;p&gt;有时我们会使用标志位 &lt;code&gt;flag&lt;/code&gt; 来区分函数的行为，标记参数会影响函数内部的控制流，但它却通常无法清晰地传达自己的含义，对此可以使用移除标记参数。如果明确用一个函数来完成一项单独的任务，其含义就会清晰得多（见下述代码）。如果一个函数有多个标记参数，说明这个函数可能做得太多，应该考虑是否能用更简单的函数来组合出完整的逻辑。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;function deliveryDate(anOrder, isRush) {&#xA;  let result;&#xA;  let deliveryTime;&#xA;  if (anOrder.deliveryState === &amp;#34;MA&amp;#34; || anOrder.deliveryState === &amp;#34;CT&amp;#34;) {&#xA;      deliveryTime = isRush ? 1 : 2;&#xA;  } else if (anOrder.deliveryState === &amp;#34;NY&amp;#34; || anOrder.deliveryState === &amp;#34;NH&amp;#34;) {&#xA;      deliveryTime = 2;&#xA;    if (anOrder.deliveryState === &amp;#34;NH&amp;#34; &amp;amp;&amp;amp; !isRush) {&#xA;        deliveryTime = 3;&#xA;    }&#xA;  } else if (isRush) {&#xA;      deliveryTime = 3;&#xA;  } else if (anOrder.deliveryState === &amp;#34;ME&amp;#34;) {&#xA;      deliveryTime = 3;&#xA;  } else {&#xA;      deliveryTime = 4;&#xA;  }&#xA;  result = anOrder.placedOn.plusDays(2 &amp;#43; deliveryTime);&#xA;  if (isRush) result = result.minusDays(1);&#xA;  return result;&#xA;}&#xA;&#xA;// 针对 isRush 标志位，可以在 deliveryDate 上添加两个函数&#xA;// 替换调用后，限制原函数的可见性，让人一见即知不应直接使用这个函数&#xA;function rushDeliveryDate(anOrder) {&#xA;    return deliveryDate(anOrder, true);&#xA;}&#xA;function regularDeliveryDate(anOrder) {&#xA;    return deliveryDate(anOrder, false);&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;h3 class=&#34;heading-element&#34; id=&#34;再谈谈封装&#34;&gt;&lt;span&gt;再谈谈封装&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%86%8d%e8%b0%88%e8%b0%88%e5%b0%81%e8%a3%85&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;上文有提到通过引入参数对象来减小函数的参数列表，而记录型结构有两种类型：一种需要声明合法的字段名，另一种可以随便用任何字段名。后者有哈希表、字典、数组等，使用这类结构时虽然方便但也有缺陷，那就是一条记录上 &lt;strong&gt;持有什么字段&lt;/strong&gt; 往往不够直观。只能通过查看它的创建点和使用点来获取其维护的字段，如果这种记录只在程序的一个小范围里使用，那问题还不大，但如果其使用范围变宽，数据结构不直观就会造成更多的困扰。&lt;/p&gt;&#xA;&lt;p&gt;虽然封装是 OOP 三点特性之一，笔者在初写 Java 的时候也时常困惑：为什么要声明一个又一个的数据类，又把其字段都用 private 封装起来，最后对外暴露 &lt;code&gt;getter, setter&lt;/code&gt; 函数。这看起来有些多此一举的行为却也蕴含着封装的思想。试想一下，当想要对结构体中某个字段进行改名的时候，我们往往需要找到并同步修改所有引用这个字段的地方，但如果不够仔细，或者存在外部引用就无法保证操作的安全性。不过，在将字段的访问封装起来后，我们就可以渐进地完成对字段的改名：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;声明一个新字段，以及它的 getter, setter 函数&lt;/li&gt;&#xA;&lt;li&gt;将旧字段的 getter, setter 函数作为转发函数，调用新声明字段的函数&lt;/li&gt;&#xA;&lt;li&gt;渐进式地修改所有调用老字段的地方，改为调用新字段的函数&lt;/li&gt;&#xA;&lt;li&gt;在完成所有对老字段的引用的修改后，删除老的字段&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;类似地，在给函数重命名时，需要考虑是否能一步到位地修改其所有的调用者。如果函数还有外部的调用者（比如客户端，或者是来自其他服务的调用），也可以采用 &lt;strong&gt;渐进式&lt;/strong&gt; 地修改函数声明：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;使用提炼函数将函数体提炼成一个新函数，给予新的命名&lt;/li&gt;&#xA;&lt;li&gt;在旧函数中使用内联函数，调用新的函数&lt;/li&gt;&#xA;&lt;li&gt;对外声明旧函数为废弃 &lt;code&gt;deprecated&lt;/code&gt;，并告知应使用的新函数&lt;/li&gt;&#xA;&lt;li&gt;在客户端完成调用修改后，将旧函数删除&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;优化条件逻辑&#34;&gt;&lt;span&gt;优化条件逻辑&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e4%bc%98%e5%8c%96%e6%9d%a1%e4%bb%b6%e9%80%bb%e8%be%91&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;条件逻辑可以提升程序的威力，同时也会引入一定的复杂度。复杂的条件逻辑是编程中最难理解的东西之一，我们可以用以卫语句取代嵌套条件表达式来清晰表达 &amp;ldquo;在主要处理逻辑之前先做检查&amp;rdquo; 的意图，也可以用以多态取代条件表达式来处理 switch 的多种情况。&lt;/p&gt;&#xA;&lt;p&gt;条件表达式中，如果两个条件分支都属于正常行为，就应该使用形如 if&amp;hellip;else&amp;hellip; 的条件表达式，来表现出对两个分支同等的重视。但如果一个分支是正常行为，另一个分支是罕见或者异常的行为，就应该单独检查该条件，并在该条件为真时立刻从函数中返回，这样的单独检查常常被称为 &amp;ldquo;卫语句&amp;rdquo; &lt;code&gt;guard clauses&lt;/code&gt;。卫语句可以告诉代码的阅读者，这种情况不是本函数的核心逻辑，如果它真发生了，请做一些必要的整理工作，然后退出。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;function payAmount(employee) {&#xA;  let result;&#xA;  if (employee.isSeparated) {&#xA;      result = {amount: 0, reasonCode: &amp;#34;SEP&amp;#34;};&#xA;  }&#xA;  else {&#xA;    if (employee.isRetired) {&#xA;        result = {amount: 0, reasonCode: &amp;#34;RET&amp;#34;};&#xA;    }&#xA;    else {&#xA;        // logic to compute amount&#xA;      lorem.ipsum(dolor.sitAmet);&#xA;      consectetur(adipiscing).elit();&#xA;      sed.do.eiusmod = tempor.incididunt.ut(labore) &amp;amp;&amp;amp; dolore(magna.aliqua);&#xA;      ut.enim.ad(minim.veniam);&#xA;      result = someFinalComputation();&#xA;    }&#xA;  }&#xA;  return result;&#xA;}&#xA;&#xA;// 使用卫语句后，单独检查罕见条件，并处理提前返回&#xA;function payAmount(employee) {&#xA;  if (employee.isSeparated) return {amount: 0, reasonCode: &amp;#34;SEP&amp;#34;};&#xA;  if (employee.isRetired) return {amount: 0, reasonCode: &amp;#34;RET&amp;#34;};&#xA;  // logic to compute amount&#xA;  lorem.ipsum(dolor.sitAmet);&#xA;  consectetur(adipiscing).elit();&#xA;  sed.do.eiusmod = tempor.incididunt.ut(labore) &amp;amp;&amp;amp; dolore(magna.aliqua);&#xA;  ut.enim.ad(minim.veniam);&#xA;  return someFinalComputation();&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然使用条件逻辑本身的结构就足以表达不同的场景，但使用类和 &lt;strong&gt;多态&lt;/strong&gt; 能把逻辑的拆分表述得更清晰。比如针对 switch 语句中的每种分支逻辑创建一个类，用多态来承载各个类型特有的行为，从而去除重复的分支逻辑。下面有这样一个例子，有一家评级机构，要根据航程本身的特征和船长过往的航行历史，对远洋航船的航行进行投资评级。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;function rating(voyage, history) {&#xA;  const vpf = voyageProfitFactor(voyage, history);&#xA;  const vr = voyageRisk(voyage);&#xA;  const chr = captainHistoryRisk(voyage, history);&#xA;  if (vpf * 3 &amp;gt; (vr &amp;#43; chr *2)) return &amp;#34;A&amp;#34;;&#xA;  else return &amp;#34;B&amp;#34;;&#xA;}&#xA;function voyageRisk(voyage) {&#xA;  let result = 1;&#xA;  if (voyage.length &amp;gt; 4) result &amp;#43;= 2;&#xA;  if (voyage.length &amp;gt; 8) result &amp;#43;= voyage.length -8;&#xA;  if ([&amp;#34;china&amp;#34;, &amp;#34;east-indies&amp;#34;].includes(voyage.zone)) result &amp;#43;= 4;&#xA;  return Math.max(result, 0);&#xA;}&#xA;function captainHistoryRisk(voyage, history) {&#xA;  let result = 1;&#xA;  if (history.length &amp;lt; 5) result &amp;#43;= 4;&#xA;  result &amp;#43;= history.filter(v =&amp;gt; v.profit &amp;lt; 0).length;&#xA;  if (voyage.zone === &amp;#34;china&amp;#34; &amp;amp;&amp;amp; hasChina(history)) result -= 2;&#xA;  return Math.max(result, 0);&#xA;}&#xA;function hasChina(history) {&#xA;  return history.some(v =&amp;gt; &amp;#34;china&amp;#34; === v.zone);&#xA;}&#xA;function voyageProfitFactor(voyage, history) {&#xA;  let result = 2;&#xA;  if (voyage.zone === &amp;#34;china&amp;#34;) result &amp;#43;= 1;&#xA;  if (voyage.zone === &amp;#34;east-indies&amp;#34;) result &amp;#43;= 1;&#xA;  if (voyage.zone === &amp;#34;china&amp;#34; &amp;amp;&amp;amp; hasChina(history)) {&#xA;    result &amp;#43;= 3;&#xA;    if (history.length &amp;gt; 10) result &amp;#43;= 1;&#xA;    if (voyage.length &amp;gt; 12) result &amp;#43;= 1;&#xA;    if (voyage.length &amp;gt; 18) result -= 1;&#xA;  }&#xA;  else {&#xA;    if (history.length &amp;gt; 8) result &amp;#43;= 1;&#xA;    if (voyage.length &amp;gt; 14) result -= 1;&#xA;  }&#xA;  return result;&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码中有两处同样的条件逻辑，都在询问 &amp;ldquo;是否有到中国的航程&amp;rdquo; 以及 &amp;ldquo;船长是否曾去过中国&amp;rdquo;，我们可以使用继承和多态将处理 &amp;ldquo;中国因素&amp;rdquo;（会混淆视听）的逻辑从基础逻辑中分离出来。在重构后可以得到一个基本的 Rating 类，其中放着基础逻辑，不考虑与 &amp;ldquo;中国经验&amp;rdquo; 相关的复杂性：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;class Rating {&#xA;  constructor(voyage, history) {&#xA;    this.voyage = voyage;&#xA;    this.history = history;&#xA;  }&#xA;  get value() {&#xA;    const vpf = this.voyageProfitFactor;&#xA;    const vr = this.voyageRisk;&#xA;    const chr = this.captainHistoryRisk;&#xA;    if (vpf * 3 &amp;gt; (vr &amp;#43; chr *2)) return &amp;#34;A&amp;#34;;&#xA;    else return &amp;#34;B&amp;#34;;&#xA;  }&#xA;  get voyageRisk() {&#xA;    let result = 1;&#xA;    if (voyage.length &amp;gt; 4) result &amp;#43;= 2;&#xA;    if (voyage.length &amp;gt; 8) result &amp;#43;= voyage.length -8;&#xA;    if ([&amp;#34;china&amp;#34;, &amp;#34;east-indies&amp;#34;].includes(voyage.zone)) result &amp;#43;= 4;&#xA;    return Math.max(result, 0);&#xA;  }&#xA;  function captainHistoryRisk(voyage, history) {&#xA;    let result = 1;&#xA;    if (history.length &amp;lt; 5) result &amp;#43;= 4;&#xA;    result &amp;#43;= history.filter(v =&amp;gt; v.profit &amp;lt; 0).length;&#xA;    return Math.max(result, 0);&#xA;  }&#xA;  function voyageProfitFactor(voyage, history) {&#xA;    let result = 2;&#xA;    if (voyage.zone === &amp;#34;china&amp;#34;) result &amp;#43;= 1;&#xA;    if (voyage.zone === &amp;#34;east-indies&amp;#34;) result &amp;#43;= 1;&#xA;       result &amp;#43;= this.historyLengthFactor;&#xA;    result &amp;#43;= this.voyageLengthFactor;&#xA;    return result;&#xA;  }&#xA;  get voyageLengthFactor() {&#xA;    return (voyage.length &amp;gt; 14) ? -1 : 0;&#xA;  }&#xA;  get historyLengthFactor() {&#xA;    reutrn (history.length &amp;gt; 8) ? 1 : 0;&#xA;  }&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与 &amp;ldquo;中国经验&amp;rdquo; 相关的代码则清晰表述出在基本逻辑之上的一系列变体逻辑：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;class ExperienceChinaRating extends Rating {&#xA;  get captainHistoryRisk() {&#xA;    const result = super.captainHistoryRisk - 2;&#xA;    return Math.max(result, 0);&#xA;  }&#xA;  get voyageLengthFactor() {&#xA;    let result = 0;&#xA;    if (this.voyage.length &amp;gt; 12) result &amp;#43;= 1;&#xA;    if (this.voyage.length &amp;gt; 18) result -= 1;&#xA;    return result;&#xA;  }&#xA;  get historyLengthFactor() {&#xA;      return (this.history.length &amp;gt; 10) ? 1 : 0;&#xA;  }&#xA;  get voyageProfitFactor() {&#xA;    return super.voyageProfitFactor &amp;#43; 3;&#xA;  }&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;h3 class=&#34;heading-element&#34; id=&#34;改善继承关系&#34;&gt;&lt;span&gt;改善继承关系&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%94%b9%e5%96%84%e7%bb%a7%e6%89%bf%e5%85%b3%e7%b3%bb&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;继承作为 OOP 里最为人熟知的特性十分实用，却也经常被误用，而且常得等到你用上一段时间，才能察觉到误用所在。超类中会处理所有的通用逻辑，如果某个函数/字段在各个子类中都相同，就可以通过函数/字段上移将它上升到超类中。同样地，如果超类中的某个函数/字段只与一个（或少数几个）子类有关，那么最好将其从超类中挪走，放到真正关心它的子类中去。&lt;/p&gt;&#xA;&lt;p&gt;如果一个字段仅仅作为 &lt;strong&gt;类型码&lt;/strong&gt; 使用，根据其值来触发不同的行为，那么可以通过以子类取代类型码来重构，如此就可以用多态来处理条件逻辑。例如员工类已经有 &amp;ldquo;全职员工&amp;rdquo; 和 &amp;ldquo;兼职员工&amp;rdquo; 两个子类了，无法根据员工类别再创建不同的子类，就可以使用间接继承的方式：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;Class Employee {&#xA;  constructor(name, type) {&#xA;    this.validateType(type);&#xA;    this._name = name;&#xA;    this._type = type;&#xA;  }&#xA;  validateType(arg) {&#xA;    if (![&amp;#34;engineer&amp;#34;, &amp;#34;manager&amp;#34;, &amp;#34;salesman&amp;#34;].includes(arg)) &#xA;      throw new Error(`Employee cannot be of type ${arg}`);&#xA;  }&#xA;  get type() {return this._type};&#xA;  set type(arg) {this._type = arg};&#xA;  get capitalizedType() {&#xA;    return this._type.chatAt(0).toUpperCase() &amp;#43; this._type.substr(1).toLowerCase();&#xA;  }&#xA;  toString() {&#xA;    return `${this._name} (${this.capitalizedType})`;&#xA;  }&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以用对象取代基本类型，使用类 EmployeeType 来取代 Employ 中的 type 属性。然后使用以子类取代类型码，把员工类别代码变成子类：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;class EmployeeType {&#xA;  constructor(aString) {&#xA;    this._value = aString;&#xA;  }&#xA;  toString() {return this._value;}&#xA;}&#xA;class Engineer extends EmployType {&#xA;  toString() {return &amp;#34;emgineer&amp;#34;;}&#xA;}&#xA;class Manager extends EmployType {&#xA;  toString() {return &amp;#34;manager&amp;#34;;}&#xA;}&#xA;class Salesman extends EmployeeType {&#xA;  toString() {return &amp;#34;salesman&amp;#34;;}&#xA;}&#xA;&#xA;// 在原先的员工类中使用工厂方法&#xA;class Employee {&#xA;  ...&#xA;  set type(arg) {this._type = Employee.createEmployeeType(arg);}&#xA;    static createEmployeeType(aString) {&#xA;      switch(aString) {&#xA;        case &amp;#34;engineer&amp;#34;: return new Engineer();&#xA;        case &amp;#34;manager&amp;#34;: return new Manager();&#xA;        case &amp;#34;salesman&amp;#34;: return new Salesman();&#xA;        default: throw new Error(`Employee cannot be of type ${aString}`);&#xA;      }&#xA;    }&#xA;  ...&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然继承在面向对象的语言中很容易实现，但继承也有短板。其一是继承这张牌只能打一次，只能用于处理超类在一个方向上的变化。其二是继承给类之间引入了非常紧密的关系，任何在超类上的修改，都可能破坏子类。这两个问题用 &lt;strong&gt;委托&lt;/strong&gt; 都能解决，对于不同的变化原因，我们可以委托给不同的类。与继承相比，使用委托关系时接口更清晰、耦合更少。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;class Order {&#xA;  get daysToShip() {&#xA;    return this._warehouse.daysToShip;&#xA;  }&#xA;}&#xA;class PriorityOrder extends Order {&#xA;  get daysToShip() {&#xA;    return this._priorityPlan.daysToShip;&#xA;  }&#xA;}&#xA;&#xA;// 使用委托后&#xA;class Order {&#xA;  get daysToShip() {&#xA;    return (this.priorityDelegate) &#xA;      ? this._prorityDelegate.daysToShip&#xA;      : this._warehouse.daysToShip;&#xA;  }&#xA;}&#xA;class PriorityOrderDelegate {&#xA;  get daysToShip() {&#xA;    return this._priorityPlan.daysToShip;&#xA;  }&#xA;}&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Devops：[译] 日志聚合系统 Grafana Loki </title>
      <link>https://hoffmanzheng.github.io/2022/devops-loki/</link>
      <pubDate>Thu, 21 Apr 2022 03:19:47 +0100</pubDate>
      <guid>https://hoffmanzheng.github.io/2022/devops-loki/</guid>
      <category domain="https://hoffmanzheng.github.io/categories/reading-notes/">Reading Notes</category>
      <description>&lt;p&gt;原文地址：&lt;a href=&#34;https://docs.google.com/document/d/11tjK_lvp1-SVsFZjgOTr1vV3-q6vBAsZYIQ5ZeYBkyM/view&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;The original design doc of Loki&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;本篇旨在解释 Grafana Loki 服务的动机和设计。本文档并不试图深入描述设计的每一个可能的细节，但希望能解释关键点，并让我们提前发现任何明显的错误。本文档不仅回答我们如何打算构建它的问题，而且还回答我们为什么构建它，它将用来做什么，以及谁将使用它的问题。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;背景与动机&#34;&gt;&lt;span&gt;背景与动机&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e8%83%8c%e6%99%af%e4%b8%8e%e5%8a%a8%e6%9c%ba&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;h4 class=&#34;heading-element&#34; id=&#34;事件响应--上下文切换&#34;&gt;&lt;span&gt;事件响应 &amp;amp; 上下文切换&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e4%ba%8b%e4%bb%b6%e5%93%8d%e5%ba%94--%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;虽然 &lt;a href=&#34;https://grafana.com/metrics/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Metrics&lt;/a&gt; 和 Alerts 可以在时间序列上预警发生的事件，但它们只能用来暴露预先定义好的行为。为了得到事件的全貌，工程师通常通过日志来获取更多的细节信息。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/loki-incident-response.png&#39; alt=&#34;/images/loki-incident-response.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;通常事件发生时会首先引起警报，并伴随着仪表盘出现特定的表象。在定位异常来源的具体服务或实例前，工程师会尝试在服务/实例的日志中寻找其根本原因。而现状是，Metrics 和 logs 被存储在两个分离的系统中，工程师需要将查询从一种语言和接口转换到另一个。因此设计 Loki 的第一个设想是减少在 logs 和 metrics 之间切换上下文的开销，来更快地响应事件而改善用户体验。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;现存的解决方案&#34;&gt;&lt;span&gt;现存的解决方案&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e7%8e%b0%e5%ad%98%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;日志聚合并不是一个新的概念，就像时序监控一样，有许多 SaaS 供应商和开源项目都在竞争这个市场。几乎所有的现存方案都使用了全文搜索系统来索引日志，乍一看，这似乎是显而易见的解决方案，具有丰富而强大的功能集，允许进行复杂的查询。&lt;/p&gt;&#xA;&lt;p&gt;而这些现存方案因太过复杂而难以扩展，资源占用高，操作困难。如上所述，一种越来越普遍的模式是结合使用时间序列监控和日志聚合——因此查询工具提供的灵活性和复杂性通常 &lt;strong&gt;没有&lt;/strong&gt; 被使用； 大多数查询只关注时间范围和一些简单的参数（主机、服务等）。 使用这些系统进行日志聚合类似于使用大锤来敲开坚果。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/loki-existing-solution.png&#39; alt=&#34;/images/loki-existing-solution.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;现有系统的挑战和运营开销已导致许多买家落入 SaaS 运营商手中。 因此，设计 Loki 的第二个设想是，可以在易于操作和查询语言的复杂性之间进行不同的权衡，并且使其便于操作。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;成本效益&#34;&gt;&lt;span&gt;成本效益&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%88%90%e6%9c%ac%e6%95%88%e7%9b%8a&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;随着向 SaaS 日志聚合的迁移，此类系统的过高成本越发突显。 这种成本不仅来自用于实现全文搜索的技术 —— 对倒排索引进行扩展和分片也很困难； 要么写入触及的每个分片，要么必须从每个分片读取；此外操作也具有一定的复杂性。&lt;/p&gt;&#xA;&lt;p&gt;买家寻求日志聚合系统的的一个常见经验是，在收到超出他们预算的基于现有日志负载的初始报价后，转向工程师并要求他们减少日志记录。 由于日志记录的存在是为了覆盖意外的错误（见上文），工程师的典型反应是难以置信 —— “如果我必须知道我该记录什么，那么记录日志又有什么意义？”。&lt;/p&gt;&#xA;&lt;p&gt;最近出现的一些系统在这点上提供了不同的权衡。 Peter Bourgon 的开源 &lt;a href=&#34;https://github.com/oklog/oklog&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;OKLOG 项目&lt;/a&gt;（现已存档）避开了基于时间的所有形式的索引，并采用最终一致的基于网格的分发策略。 这两个设计决策提供了巨大的成本节约和从根本上更简单的操作，但我们认为不符合我们的其他设计要求 —— 查询不够表现力且过于昂贵。 然而，我们确实认识到这是一个有吸引力的本地解决方案。&lt;/p&gt;&#xA;&lt;p&gt;因此第三个设想是，一个显着更具成本效益的解决方案，具有稍微不同的索引权衡，将是一个非常大的问题&amp;hellip;&amp;hellip;&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;kubernetes&#34;&gt;&lt;span&gt;Kubernetes&lt;/span&gt;&#xA;  &lt;a href=&#34;#kubernetes&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;一个有趣的需要考虑的问题是日志记录如何适用于现代云原生/微服务/容器化的工作负载中。 现在的标准模式是应用程序只需将日志写入 &lt;code&gt;STDOUT&lt;/code&gt; 或 &lt;code&gt;STDERR&lt;/code&gt;。 Kubernetes 和 Docker 等平台以此为基础提供有限的日志聚合功能； 日志被存储在本地节点上，可以使用标签选择器按需获取和聚合。&lt;/p&gt;&#xA;&lt;p&gt;但是对于这些简单的系统，当 pod 或节点消失时，日志通常会 &lt;strong&gt;丢失&lt;/strong&gt;。 这通常是买家意识到他们需要日志聚合的触发因素之一 —— 一个 pod 或节点神秘地死亡，并且没有可用的日志来诊断原因。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;prometheus-and-cortex&#34;&gt;&lt;span&gt;Prometheus and Cortex&lt;/span&gt;&#xA;  &lt;a href=&#34;#prometheus-and-cortex&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;最后值得一提的是普罗米修斯是如何融入的。 Prometheus 是一个以时间序列数据库为中心的监控系统。 TSDB 使用一组键值对索引样本集合（时间序列）。 可以通过指定这些标签的子集（匹配器）来查询这些时间序列，返回与这些标签匹配的所有时间序列。其与传统 Graphite 分层标签之类的区别是，可以对新的或变化的标签的存在与否进行查询。&lt;/p&gt;&#xA;&lt;p&gt;在 Prometheus（和 Cortex）中，这些标签存储在倒排索引中，使针对这些标签的查询更快速。Cortex 中的这种倒排索引存在于内存中以存储最近的数据，并存在于分布式 KV 存储（BigTable、DynamoDB 或 Cassandra）中以存储历史数据。 Cortex 索引能够根据余量和吞吐量线性扩展，但其会在设计上受限于给定标签的基数。&lt;/p&gt;&#xA;&lt;p&gt;Prometheus 系统包含许多组件，但值得在本次讨论中注意的一个组件是 mtail (&lt;a href=&#34;https://github.com/google/mtail&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;https://github.com/google/mtail&lt;/a&gt;)。 Mtail 允许您“从应用程序日志中提取白盒监控数据以收集到时间序列数据库中”。 这允许您为不公开任何本机指标的应用程序构建时间序列监控和警报。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;提出方案&#34;&gt;&lt;span&gt;提出方案&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%8f%90%e5%87%ba%e6%96%b9%e6%a1%88&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;我们将构建一个托管的日志聚合系统，它索引与这些日志流相关的 &lt;strong&gt;元数据&lt;/strong&gt;，而不是索引日志流本身的内容。 该元数据将采用 Prometheus 风格的多维标签。 这些标签将与从任务中提取的时间序列/指标相关联的标签一致，以便可以使用相同的标签从任务中查找日志，也可以用于从所述任务中查找时间序列，从而在用户界面实现快速的上下文切换。&lt;/p&gt;&#xA;&lt;p&gt;该系统并不会解决许多通常与日志聚合相关的复杂分布式系统和存储挑战，而是会将它们转移给现有的分布式数据库和对象存储系统中。 这将通过让大多数系统服务成为无状态和短暂的，并允许系统操作员使用云供应商提供的托管服务来降低操作复杂性。&lt;/p&gt;&#xA;&lt;p&gt;通过 &lt;strong&gt;仅索引&lt;/strong&gt; 与日志流相关的元数据，系统将索引负载减少多个数量级 —— 我预计 100MB 的日志数据有大约 1KB 的元数据。实际的日志数据将存储在托管对象存储服务（S3、GCS 等）中，由于供应商之间的竞争，这些服务面临着巨大的成本下行压力。 我们将通过转嫁这些成本，并以比竞争对手低几个数量级的价格提供该系统。 例如，GCS 的成本为 0.026 美元/GB/月，而 Loggly 的成本约为 100 美元/GB/月。&lt;/p&gt;&#xA;&lt;p&gt;由于这是一个托管系统，因此在客户端主机或 pod 故障后，也很容易获得日志。代理将部署到客户端系统中的每个节点，以将日志发送到我们的服务，并确保元数据与指标一致。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;架构&#34;&gt;&lt;span&gt;架构&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%9e%b6%e6%9e%84&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;h4 class=&#34;heading-element&#34; id=&#34;代理&#34;&gt;&lt;span&gt;代理&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e4%bb%a3%e7%90%86&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;第一个挑战是获取与时间序列/指标相关的元数据一致的可靠元数据。为了实现这一点，我们将使用与 Prometheus 相同的服务发现和标签重新标记库。这将被打包在一个守护进程中，其发现目标、生成元数据标签并跟踪日志文件以生成日志流，这些日志会暂时缓冲在客户端，然后被发送到服务。鉴于对节点故障时的最新日志的要求，它可以执行的批处理量有一个基本限制。（这个组件已经存在，叫做 &lt;a href=&#34;https://github.com/grafana/loki/tree/main/clients/pkg/promtail&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Promtail&lt;/a&gt;）&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;写入请求的一生&#34;&gt;&lt;span&gt;写入请求的一生&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%86%99%e5%85%a5%e8%af%b7%e6%b1%82%e7%9a%84%e4%b8%80%e7%94%9f&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;写入路径上的服务器端组件镜像了 Cortex 架构：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;写入将首先命中分发器，分发器负责将写入分发和复制到摄取者。因为日志流没有方便的指标名称，我们将使用 Cortex 一致性的哈希环；将基于（包括用户 ID 的）整个元数据的散列来分配写入。&lt;/li&gt;&#xA;&lt;li&gt;接着写入将命中一个“日志摄取器”，它将内存中相同流的写入批处理成“日志块”。当块达到预定义的大小或年龄时，它们会定期刷新到 Cortex 块存储。&lt;/li&gt;&#xA;&lt;li&gt;Cortex 块存储将被更新以减少在读写路径上块数据的复制，并添加对写入 GCS 块的支持。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;日志块&#34;&gt;&lt;span&gt;日志块&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%97%a5%e5%bf%97%e5%9d%97&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;块的格式对系统的成本和性能很重要。 块是给定标签集在特定时期内的所有日志。块必须支持追加、查找和流式读取。假设一个节点平均每天将产生 10 GB 的日志，并且平均运行 30 个容器，那么每个日志流将以 4 KB/s 的速度写入。日志数据的预期压缩率应该是 10 倍左右。&lt;/p&gt;&#xA;&lt;p&gt;在选择最佳的块大小时，我们需要考虑：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每次操作的成本与存储成本；当块对象较小时，每次操作的成本占主导地位，并且将它们存储在数据库（例如 Bigtable）中更便宜。&lt;/li&gt;&#xA;&lt;li&gt;每个块索引的负载 —— 每个块都需要索引其中的条目；运行 Cortex 的经验告诉我们，这是运行系统的最大成本组件，但考虑到更大的块大小，我怀疑这里不会出现这种情况。&lt;/li&gt;&#xA;&lt;li&gt;构建块的内存成本和丢失风险。这可能是限制因素。我们应该期望能够为每台机器处理 1000 台主机的流，以便能够经济高效地运行服务；如果每个流需要 1MB 的内存并且每个主机需要 30 个流，这意味着每个摄取者需要 30GB 的内存（WAL 类似）。1000 台主机也意味着 130MB/s 的入站和出站带宽以及入站压缩，这是一种推动。&lt;/li&gt;&#xA;&lt;li&gt;压缩效率 —— 在非常小的尺寸（10s 字节）下，压缩是无效的；日志行将需要一起批处理以实现更接近最佳压缩。（&lt;a href=&#34;https://docs.google.com/spreadsheets/d/1zTtln0kKspSWsHtwmamZzSnsHspHQigd-1jotZ8l9gc/edit#gid=0&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;在示例日志数据上尝试的各种压缩方案和块大小&lt;/a&gt;）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;例如，12 小时的日志数据将产生约 100 MB 未压缩和约 10 MB 压缩的块。12 小时也是我们在 Cortex 中使用的块长度的上限。考虑到构建这些的内存要求，接近 1 MB（压缩）的块大小看起来更有可能。&lt;/p&gt;&#xA;&lt;p&gt;该提议是由一系列块 blocks 组成的块 chunk；第一个块是 gorilla 风格的时间索引，随后的块包含压缩的日志数据。一旦产生了足够多的块 blocks 以形成足够大的块 chunk，它们将被附加在一起以形成一个块。需要进行一些实验才能找到正确的块格式，欢迎在此处输入。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;查询请求的一生&#34;&gt;&lt;span&gt;查询请求的一生&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%9f%a5%e8%af%a2%e8%af%b7%e6%b1%82%e7%9a%84%e4%b8%80%e7%94%9f&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;由于块比 Prometheus/Cortex 块大许多数量级（Cortex 块的大小最大为 1KB），因此无法加载它们并对其进行整体解压缩。 因此，我们需要支持流式传输和遍历它们，只解压缩我们需要的部分。 同样，这里有很多细节需要解决，但我怀疑积极使用 gRPC 流和堆将是有序的（请参阅新的 Cortex 遍历查询 PR）。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;未来的设想&#34;&gt;&lt;span&gt;未来的设想&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%9c%aa%e6%9d%a5%e7%9a%84%e8%ae%be%e6%83%b3&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;ul&gt;&#xA;&lt;li&gt;我们可能在摄取时从日志中提取额外的元数据，以包含在索引中，例如日志级别。我们需要留心基数爆炸。&lt;/li&gt;&#xA;&lt;li&gt;我想在特定服务/实例上应用实时的日志流，以便更熟悉它的行为方式或检查假设。 这可能适用于刚刚上线的新实例，也可能来自已经运行的实例。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Couchbase: Blazing Fast. Surprisingly Affordable.</title>
      <link>https://hoffmanzheng.github.io/2022/database-couchbase/</link>
      <pubDate>Mon, 21 Feb 2022 13:19:47 +0100</pubDate>
      <guid>https://hoffmanzheng.github.io/2022/database-couchbase/</guid>
      <category domain="https://hoffmanzheng.github.io/categories/reading-notes/">Reading Notes</category>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.couchbase.com/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Couchbase&lt;/a&gt; 是为企业应用设计的现代分布式文档数据库，具有强大的搜索引擎和内置的操作和分析能力。它拥有 NoSQL 的强大功能，并提供快速、高效的数据双向同步。&lt;/p&gt;&#xA;&lt;p&gt;本篇基于 &lt;a href=&#34;https://docs.couchbase.com/home/server.html&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Couchbase 官网文档&lt;/a&gt; 介绍其数据模型、内存存储、服务与搜索、集群可用性等。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;数据&#34;&gt;&lt;span&gt;数据&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%95%b0%e6%8d%ae&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;Couchbase 中的每个数据都是一个键值对型的 item，它拥有在 bucket 中唯一的键，它的值可以是任何形式的二进制或者 JSON (可以包含基本/复杂的数据类型)。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;{&#xA;  &amp;#34;a1&amp;#34; : number,&#xA;  &amp;#34;a2&amp;#34; : &amp;#34;string&amp;#34;,&#xA;  &amp;#34;a3&amp;#34; : {   // nested array&#xA;    &amp;#34;b1&amp;#34; : [ number, number, number ]&#xA;    },&#xA;  &amp;#34;a4&amp;#34; : [   // array contains objects&#xA;    { &amp;#34;c1&amp;#34; : &amp;#34;string&amp;#34;, &amp;#34;c2&amp;#34; : number },&#xA;    { &amp;#34;c1&amp;#34; : &amp;#34;string&amp;#34;, &amp;#34;c2&amp;#34; : number }&#xA;  ]&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;h4 class=&#34;heading-element&#34; id=&#34;数据模型&#34;&gt;&lt;span&gt;数据模型&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;JSON 提供了快速的序列化与反序列化，并且是大多数 REST API 的返回类型。文档通常被认为等效于关系型数据库中的行记录，但它可以存储嵌套文档或数组，提供了更多的灵活性。&lt;/p&gt;&#xA;&lt;p&gt;文档可以包含嵌套结构，这让开发者可以在不使用引用或连接表的情况下表达多对多的数据关系，并自然地展示分层数据。一个支持用户根据日期检索的在线航班预订应用，它的关系模型需要多张表 —— 航班、航线、日程，如下图所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/couchbase-relationalDataModel.png&#39; alt=&#34;/images/couchbase-relationalDataModel.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;相对地，文档模型却只需要一个嵌套了所有航班日程的文档：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/couchbase-jsonDataModel.png&#39; alt=&#34;/images/couchbase-jsonDataModel.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;因此在文档模型中，每个文档都可以 &lt;strong&gt;高度自包含&lt;/strong&gt;。这将支持应用需求的快速实现，并且对可扩展性和延迟都具有重要意义：可以在不访问其他文档的情况下原子地复制或更改一个文档；消除了负责的节点间协调需求，并减少了征用。&lt;/p&gt;&#xA;&lt;p&gt;在文档模型中，schema 是应用结构化文档数据的结果，它完全由应用定义和管理。Couchbase 并 &lt;strong&gt;不强求一致性&lt;/strong&gt;，文档结构可以在文档间存有差异，这允许数据以一种高效的方式被呈现。schema 也可以逐渐被应用进化：属性和结构可以被添加到文档，而无需同时更新其它文档（这个灵活性对于大型长期应用是一个特别的优势）。&lt;/p&gt;&#xA;&lt;p&gt;Couchbase 对文档操作提供了原子性、一致性、隔离性和持久性。单个写操作被保证为完全成功或失败，操作不会导致文档处于部分更新的状态。在 &lt;strong&gt;设计文档结构&lt;/strong&gt; 时需要考虑性能和可扩展性：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;有的时候定义较少嵌套复杂信息的富文档比较合适，这允许信息在单个操作中被读取/写入。因为独立的对象间只有较少的关联，可扩展性也因此被加强。这也使分组属性较为容易的维持在一个相互一致的状态。&lt;/li&gt;&#xA;&lt;li&gt;当访问模式可预测且数据量较少时，定义大量相互引用的文档可能较为合适，可以减少网络带宽的消耗。文件可以通过 key 相互引用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;n1ql&#34;&gt;&lt;span&gt;N1QL&lt;/span&gt;&#xA;  &lt;a href=&#34;#n1ql&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;在关系型数据库中，数据以一致的结构存储在表中，并通过主键相互关联。相比之下，Couchbase 使用 JSON 这种更灵活的数据模式，以及针对 JSON 增强的 SQL N1QL。N1QL 将数据作为格式自由的文档处理，并将数据聚集在一个称作 &lt;code&gt;keyspaces&lt;/code&gt; 的大集合中。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;(HRData keyspace)&#xA; {&#xA;     &amp;#39;Name&amp;#39;: &amp;#39;Jamie&amp;#39;&#xA;     &amp;#39;SSN&amp;#39;: 234&#xA;     &amp;#39;Wage&amp;#39;: 123&#xA;     &amp;#39;History&amp;#39;:   // 在关系型数据库中，这数组会存在另一个关联表中&#xA;      [&#xA;       [&amp;#39;Yahoo&amp;#39;, 2005, 2006],&#xA;       [&amp;#39;Oracle&amp;#39;, 2006, 2012],&#xA;     ]&#xA; },&#xA;&#xA; {&#xA;     &amp;#39;Name&amp;#39;: Steve&#xA;     &amp;#39;SSN&amp;#39;:  123,&#xA;     &amp;#39;Wage&amp;#39;: 456,&#xA; }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;N1QL 中的 &lt;code&gt;FROM&lt;/code&gt; 被用来在不同的数据源 keyspaces 中检索。同样每个文档也会视自身为一个数据源，并在其嵌套元素中执行查询。嵌套元素可以通过点操作符 &lt;code&gt;.&lt;/code&gt; 进入，数组元素通过中括号 &lt;code&gt;[]&lt;/code&gt; 来索引。检索出的属性可以通过 &lt;code&gt;AS&lt;/code&gt; 操作符来重命名：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;SELECT firstjob FROM HRData.History[0] AS firstjob&#xA;{&#xA;     &amp;#39;firstjob&amp;#39;: [&amp;#39;Yahoo&amp;#39;, 2005, 2006]&#xA;}&#xA;&#xA;SELECT firstjob[2] FROM HRData.History[0] AS firstjob&#xA;{&#xA;     &amp;#39;firstjob[2]&amp;#39;: 2006&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此外，N1QL 在实现多表关联时有不同的实现方式，它只支持 loopup doc 主键形式 left-to-right 关联，关联的左表需要能够生成右表文档的主键：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;SELECT &amp;lt;select_list&amp;gt;&#xA;FROM Table_A A&#xA;LEFT JOIN Table_B B&#xA;ON KEYS &amp;lt;keys-clause(A)&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考：&lt;a href=&#34;https://dzone.com/articles/visually-explaining-n1ql-joins&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Visually Explaining N1QL JOINs&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;buckets-内存与存储&#34;&gt;&lt;span&gt;Buckets, 内存与存储&lt;/span&gt;&#xA;  &lt;a href=&#34;#buckets-%e5%86%85%e5%ad%98%e4%b8%8e%e5%ad%98%e5%82%a8&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;Couchbase 将数据保存在 Bucket 中，Couchbase buckets 在内存和硬盘中都有，而 Ephemeral bucket 作为暂时 bucket 只存在于内存中。bucket 可以设置以 &lt;strong&gt;压缩&lt;/strong&gt; 形式存储数据来最大化资源效率，文档也可以（像 Redis 那样）设置一个过期时间。&lt;/p&gt;&#xA;&lt;p&gt;Couchbase 使用内存来保证高性能和可扩展性：内存中会存放经常被请求的数据，最近没被使用的数据会被从内存中驱逐出去。多线程的读取和写入提供了数据的同时读取和写入，来保证交高的吞吐量。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;buckets&#34;&gt;&lt;span&gt;Buckets&lt;/span&gt;&#xA;  &lt;a href=&#34;#buckets&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;Bucket 是在逻辑上用来分组键值对的集合，共有三种 bucket 类型：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Couchbase bucket&#xA;&lt;ul&gt;&#xA;&lt;li&gt;持久存储数据，且存在于内存中。&lt;/li&gt;&#xA;&lt;li&gt;允许数据被自动复制来保证高可用，可以通过跨数据中心复制 XDCR 在集群中动态扩容。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Ephemeral bucket&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当数据持久性不被要求时可作为 Couchbase buchet 的候选，用于在硬盘高度负载时提供高度一致的内存性能；也可用于更快的节点重平衡/重启&lt;/li&gt;&#xA;&lt;li&gt;当 bucket 的内存限额被超过时，会根据创建时的配置拒绝接收新的数据，或者逐出老数据。因为 Ephemeral bucket 中的数据只存在内存中，被逐出的数据将不能被再次检索&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Memcached bucket&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过缓存常用数据来减少数据服务必须执行的请求数量，并不会持久化到磁盘上。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;code&gt;vBuckets&lt;/code&gt; （有时也被称作分片 &lt;code&gt;shards&lt;/code&gt;）是集群中高效分散数据的虚拟 buckets，并且支持在多个节点间复制。Couchbase / Ephemeral bucket 都实现了 vBuckets，每个 bucket 拥有 1024 个 vBuckets 均分集群的内存和存储。写入操作会在 active vBuckets 中执行，大多数读取操作也会在 active vBuckets 中执行，当必要时数据可以从 replica vBuckets 中读取。&lt;/p&gt;&#xA;&lt;p&gt;对象在写入或检索时会先根据它的 key 用 &lt;code&gt;CRC32&lt;/code&gt; 哈希算法计算出对象存储的 vBuckets 下标值，再通过 vBuckets map 在集群中找到映射的单个节点，最后在那个服务节点上执行操作，其结构关系如下图所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/couchbase-vbucketToNodeMapping.png&#39; alt=&#34;/images/couchbase-vbucketToNodeMapping.png&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;内存&#34;&gt;&lt;span&gt;内存&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%86%85%e5%ad%98&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;Couchbase 服务器完全集成了缓冲层，提供高速数据访问。需要写入 Couchbase bucket 中的数据，会先进去缓冲层，然后同时放入磁盘队列和复制队列（示意如下图），因此 replica bucket 可以被更新。由于配置了内存限额，缓冲层中不常用的对象会被写入磁盘，然后从内存中被移出来释放空间，这个异步过程被称为 &lt;code&gt;ejection&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/couchbase-createDocSequence3.png&#39; alt=&#34;/images/couchbase-createDocSequence3.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;每个 bucket 的可用内存由 &lt;code&gt;mem_low_wat&lt;/code&gt; 和 &lt;code&gt;mem_high_wat&lt;/code&gt; 来管理，当 bucket 中的数据持续地被加载到内存中，且数量达到 mem_low_wat 时，不会触发任何动作。如有更多数据被加载，数量达到 mem_high_wat 时，对象可被 eject 出去，直到内存数量下降至 mem_low_wat。如果 ejection 过程无法释放足够的空间，数据服务将停止吸收数据，并向客户端发送异常信息。&lt;/p&gt;&#xA;&lt;p&gt;Ejection 基于 NRU (Not Recently Used) 算法，最近没有被访问的数据对象都可能从内存中 eject 出去。随着时间推移，Couchbase 服务器内存就变的碎片化了，这将导致内存无法被高效利用，为此 Couchbase 提供了 &lt;code&gt;Acitve Memory Defragmenter&lt;/code&gt; ，它会定期扫描缓存，来识别较少使用的页，然后将这些页上的对象们重新打包，来释放空间。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/couchbase-tunableMemory.png&#39; alt=&#34;/images/couchbase-tunableMemory.png&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;存储&#34;&gt;&lt;span&gt;存储&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%ad%98%e5%82%a8&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;Couchbase 会将数据对象压缩后存储在磁盘，当有客户端请求的时候，对象会重新从磁盘恢复到内存来响应访问。需要注意的是，Ephemeral bucket 中的对象只会维持在内存中，而不会被存储在磁盘上。&lt;/p&gt;&#xA;&lt;p&gt;磁盘的读取和写入 I/O 是后台任务，并不会阻塞客户端的交互。多线程的读取和写入将提供磁盘上同时高性能的读写操作，线程间冲突将通过将线程分配给 1024 个 vBuckets 的特定子集来避免。&lt;/p&gt;&#xA;&lt;p&gt;磁盘上的对象也会由于删除操作或过期时间而被删除，Couchbase 会在删除对象会保持对象的墓碑 &lt;code&gt;tombstone&lt;/code&gt;（对象的元信息），以此在节点和集群间提供最终一致性。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;服务与索引&#34;&gt;&lt;span&gt;服务与索引&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%9c%8d%e5%8a%a1%e4%b8%8e%e7%b4%a2%e5%bc%95&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;服务会在管理员初始化节点时配置和部署，每个节点可以选择服务的一个子集，并给它们分配各自的内存限额。每种服务支持一种特殊形式的数据访问，在多个集群节点部署服务将支持较高的工作负荷，并保证最高的性能和资源可用性。&lt;/p&gt;&#xA;&lt;p&gt;查询和分析服务将依赖索引服务提供的索引，搜索服务提供了自己内置的索引。设计巧妙的索引将对搜索操作提供显著的性能提升。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;服务&#34;&gt;&lt;span&gt;服务&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%9c%8d%e5%8a%a1&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;Couchbase 服务器提供了数据、查询、索引、搜索、分析、事件六大服务，通过多维度扩展，这些服务可以被相互独立地部署、维护，来满足业务场景的高效响应和紧急的工作负荷需求。&lt;/p&gt;&#xA;&lt;p&gt;服务可以在每个节点上单独设置并分配内存配额（除了查询服务），每个节点可以运行每种服务的至多一个实例。如果一个集群只用作开发或测试，可以快速地为每个服务设置相同的内存配额，如下图所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/couchbase-cbClusterWithServicesDevelopment.png&#39; alt=&#34;/images/couchbase-cbClusterWithServicesDevelopment.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;服务可以被分配更大的内存配额，并且可能作为节点上的唯一服务来处理更大的工作量。如果一个特别的服务需要在生产环境处理大量数据，要被密集索引，并通过查询和搜索来解决，下图的配置会更有效：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/couchbase-cbClusterWithServicesProduction.png&#39; alt=&#34;/images/couchbase-cbClusterWithServicesProduction.png&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;索引&#34;&gt;&lt;span&gt;索引&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e7%b4%a2%e5%bc%95&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;与关系型数据库一样，Couchbase 也拥有基于每个对象唯一 key 的主键索引和基于文档内属性的二级索引（也被称作全局二级索引 GSI）。GSI 可以被独立（不依赖于 vBuckets 的划分）划分在有索引服务的集群节点，也就是说，数据对象和它的索引可以有不同的划分下标，对应不同的集群节点。GSI 可以被复制到其他的集群节点来实现高可用性和高性能（负载均衡）。&lt;/p&gt;&#xA;&lt;p&gt;应用和数据库驱动会将 N1QL 查询提交到集群中其中一个可用的查询节点，查询节点会分析语句，规划出最优的执行计划。根据执行计划将查询递交给索引节点或数据节点来执行，其流程如下图所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/couchbase-query_execution.png&#39; alt=&#34;/images/couchbase-query_execution.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;有关索引对查询性能的优化可以参考另一篇博文：&lt;a href=&#34;https://hoffmanzheng.github.io/2020/database-index/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Database：高性能 MySQL - 索引&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;全文搜索&#34;&gt;&lt;span&gt;全文搜索&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%85%a8%e6%96%87%e6%90%9c%e7%b4%a2&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;Couchbase 使用基于 &lt;a href=&#34;http://blevesearch.com/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Bleve&lt;/a&gt; 的全文搜索，首先要在执行搜索的 bucket 上创建全文索引，默认的 &lt;code&gt;default&lt;/code&gt; 的 Type Mappings 指可以对 bucket 内的所有文档进行搜索，如下图所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/couchbase-defaultFullTextIndex.png&#39; alt=&#34;/images/couchbase-defaultFullTextIndex.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;当然也可以只索引 bucket 中某个类型的文档，这样有助于减少空间和内存使用。例如指定文档 ID 下划线前的字符串为类型，hotel 为类型映射，然后将 default type mappings 取消即可，如下图所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/couchbase-typeMapping.png&#39; alt=&#34;/images/couchbase-typeMapping.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;此外还可以仅索引文档中的某个字段，如下图所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/couchbase-searchField.png&#39; alt=&#34;/images/couchbase-searchField.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在网页管理员控制台测试搜索功能后，就可以用 REST API 来实现搜索：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;curl -u Administrator:password -X POST -H &amp;#34;Content-Type: application/json&amp;#34; \&#xA;http://localhost:8094/api/index/travel-FTS/query \&#xA;-d &amp;#39;{&#xA;  &amp;#34;explain&amp;#34;: true,&#xA;  &amp;#34;fields&amp;#34;: [&#xA;    &amp;#34;*&amp;#34;&#xA;  ],&#xA;  &amp;#34;highlight&amp;#34;: {},&#xA;  &amp;#34;query&amp;#34;: {&#xA;    &amp;#34;query&amp;#34;: &amp;#34;hotel&amp;#34;&#xA;  }&#xA;}&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;h3 class=&#34;heading-element&#34; id=&#34;集群与可用性&#34;&gt;&lt;span&gt;集群与可用性&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e9%9b%86%e7%be%a4%e4%b8%8e%e5%8f%af%e7%94%a8%e6%80%a7&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;Couchbase 集群包含一个或多个 Couchbase 服务器的实例，每个实例都运行在一个独立的节点上，数据和服务在集群中被共享。当一个 Couchbase 服务器被配置到一个节点上时，它可以被指定为一个新的集群或者作为一个已有集群的参与者。Couchbase 集群管理员运行在集群的每个节点上，并在节点间通信，保证所有节点的健康。&lt;/p&gt;&#xA;&lt;p&gt;数据会在不影响应用的情况下自动分散在集群中。每个 bucket 会被数据服务存储为 1024 个 vBuckets（虚拟 bucket），并平均分散在所有可用的数据服务节点。vBuckets 可以被跨集群间复制，并将其副本存于其他的节点。Couchbase 会在保证没有数据丢失的前提下自动处理节点的新增、删除和失效。在监测到配置变化时，vBuckets 和它的副本会在可用的节点上进行重新分配。跨数据中心复制 XDCR 可以将数据选择性地复制到一个远端节点，以此实现高可用性。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;新增移除节点&#34;&gt;&lt;span&gt;新增/移除节点&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%96%b0%e5%a2%9e%e7%a7%bb%e9%99%a4%e8%8a%82%e7%82%b9&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;添加节点时，会在持续处理现有的工作量的同时完成数据的重新分布 &lt;code&gt;redistribution&lt;/code&gt;：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;用现有的集群配置更新新的节点&lt;/li&gt;&#xA;&lt;li&gt;初始化 rebalance，重新计算 vBucket 映射表&lt;/li&gt;&#xA;&lt;li&gt;节点开始从现有节点接收每个 vBuckets 的复制流，生成新的 vBuckets 副本&lt;/li&gt;&#xA;&lt;li&gt;随着 vBuckets 的数据被复制，索引也被更新，会发生从老的 vBucket 到新的 vBucket 的原子切换&lt;/li&gt;&#xA;&lt;li&gt;新节点上的新 vBuckets 会被激活，新的 vBucket 映射表被交流给其他的节点。重复上述过程直到再平衡完成。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;移除一个数据服务节点的过程与新增的过程相似：在要维护的节点上创建 vBuckets，并将要移除的节点 vBucket 上的数据复制到那里。当节点上不再有 vBuckets 时，节点就会从集群中移除。当新增或移除一个没有数据服务的节点时，则无需移动数据。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;节点失效&#34;&gt;&lt;span&gt;节点失效&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e8%8a%82%e7%82%b9%e5%a4%b1%e6%95%88&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;在 Couchbase 服务集群中的节点会通过心跳机制提供它们的健康状态。所有实例都会定期提供心跳，其中包含了节点状态的基础统计信息。如果在一个默认时期内不再收到某个节点的心跳，集群会自动转移该故障节点。共有两种故障转移 &lt;code&gt;Failover&lt;/code&gt; 的类型：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Graceful: 这是一个在线操作，要求零停机时间。当要移除的节点包含数据服务时，在剩下的集群节点上的副本 vBuckets 会被提升为激活状态，而要移除的节点上的活跃 vBuckets 会是 dead 状态。在整个过程中，数据服务节点会被主动、有序地移除，集群为每个 bucket 保持所有 1024 个活跃的 vBuckets。&lt;/li&gt;&#xA;&lt;li&gt;Hard: 当节点失效时自动采取的故障转移过程，被动地从集群中移去节点，因为节点已经变得不可用或不稳定。当失去的节点曾运行数据服务，这个过程会从剩下的集群节点中将副本 vBuckets 提升激活，直到每个 bucket 有 1024 个活跃的 vBuckets。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Hard Failover 应该只在某个节点变成不可用时被使用，当失效节点曾有数据服务时，集群会进入一个降级状态。部分副本 vBuckets 会被升级成活跃 vBuckets，集群则因减少的副本 vBuckets 缺少再一次对抗节点停电的资源。如果失效的节点运行着集群中唯一一个索引服务，索引会在强制故障转移期间变得不可用。ref: &lt;a href=&#34;https://docs.couchbase.com/server/6.0/learn/clusters-and-availability/hard-failover.html#hard-failover-example&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Hard Failover Example&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;集群内复制&#34;&gt;&lt;span&gt;集群内复制&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e9%9b%86%e7%be%a4%e5%86%85%e5%a4%8d%e5%88%b6&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;bucket 可以拥有至多三个副本，bucket 数据允许在副本中维护和更新。当节点故障时，就可以激活故障节点维护的数据副本。为了在节点故障时保证最大的数据可用性，集群会计算并在可用节点上实施最优的 vBuckets 分配，来减少在单个节点故障时的数据损失，如下图所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/couchbase-vBucketReplication.png&#39; alt=&#34;/images/couchbase-vBucketReplication.png&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;跨数据中心复制&#34;&gt;&lt;span&gt;跨数据中心复制&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e8%b7%a8%e6%95%b0%e6%8d%ae%e4%b8%ad%e5%bf%83%e5%a4%8d%e5%88%b6&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;Cross Data Center Replication (XDCR) 能够在集群间复制数据，来避免数据中心故障，并提供分布全球的高性能数据访问。&lt;/p&gt;&#xA;&lt;p&gt;XDCR 支持跨集群单向 &lt;code&gt;Unidirectionally&lt;/code&gt; 复制，在源 bucket 中存储的数据会被复制到指定的目标 bucket。尽管被复制的数据可以用来提供服务，但这事实上是设计用作容灾恢复的备份。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/couchbase-unidirectional-xdcr.png&#39; alt=&#34;/images/couchbase-unidirectional-xdcr.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;Bidirectionally&lt;/code&gt; 双向复制：源 bucket 中的数据可以被复制到目标 bucket，相反地，目标 bucket 中的数据也可以被复制回源 bucket。这让两个 buckets 都可以提供数据服务，在不同地区提供更快的数据访问。需要注意的是，XDCR 只提供了基础的单向复制机制，双向复制是通过实施两个相反的单向复制来实现的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/couchbase-bidirectional-xdcr.png&#39; alt=&#34;/images/couchbase-bidirectional-xdcr.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;当双向复制的数据被不同地区的应用所修改时，可能会引起 &lt;strong&gt;XDCR 冲突&lt;/strong&gt;，即文档数据在同一时刻或多或少被不同地修改了。XDCR 提供了基于序列号或时间戳的冲突解决方法：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;序列号是每个文档都会维护，并随着每一次文档更新而递增的。冲突时会比较源文档与目标文档的序列号，文档修订数较多的胜出。比如一个网站的点击计数，在冲突时，拥有更多计数的文档更能反应真实的计数值，在这种情况下就可以选择基于序列号的冲突解决。&lt;/li&gt;&#xA;&lt;li&gt;文档最后一次写入的时间戳也可以被用来在冲突时比较，拥有最近更新时间戳的文档胜出。如果新的值持续地被写入到同一个 key，且我们更关注 &amp;ldquo;当前值&amp;rdquo; 时，就应该使用基于时间戳的冲突解决，它保证了文档拥有最新的版本。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>分布式：[译] 基于 Redis 的分布式锁 </title>
      <link>https://hoffmanzheng.github.io/2022/distribute-redlock/</link>
      <pubDate>Wed, 19 Jan 2022 03:19:47 +0100</pubDate>
      <guid>https://hoffmanzheng.github.io/2022/distribute-redlock/</guid>
      <category domain="https://hoffmanzheng.github.io/categories/reading-notes/">Reading Notes</category>
      <description>&lt;p&gt;原文地址：&lt;a href=&#34;https://redis.io/topics/distlock&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Distributed locks with Redis&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;当不同的进程必须以互斥的方式操作共享的资源时，分布式锁是一个非常实用的原始功能。&lt;/p&gt;&#xA;&lt;p&gt;有很多组件库和博客都描述了如何去实现一个基于 Redis 的分布式锁管理器，但是每个库使用的实现方式不尽相同，其中许多库使用了一种简单的方式，它相比稍微复杂的设计只能提供更少的保障。&lt;/p&gt;&#xA;&lt;p&gt;本篇尝试提供一种更加规范的算法来实现基于 Redis 的分布式锁。我们提出了一种叫做 &lt;code&gt;Redlock&lt;/code&gt; 的算法，它可以实现一个分布式锁管理器（我们相信它比普通的单实例方法更加安全）。我们希望社区将分析它，提供反馈，并且将它作为更复杂/替代设计的基础。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;实现&#34;&gt;&lt;span&gt;实现&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%ae%9e%e7%8e%b0&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;在描述这个算法之前，现在已经有一些可用的实现链接供参考：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/antirez/redlock-rb&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Redlock-rb&lt;/a&gt; (Ruby 实现). 还有一个 &lt;a href=&#34;https://github.com/leandromoreira/redlock-rb&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Redlock-rb&lt;/a&gt; 的分支，它为了方便分发新增了一个 gem 包，也许还有其他的。&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/SPSCommerce/redlock-py&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Redlock-py&lt;/a&gt; (Python 实现).&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/brainix/pottery#redlock&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Pottery&lt;/a&gt; (Python 实现).&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/joanvila/aioredlock&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Aioredlock&lt;/a&gt; (Asyncio Python 实现).&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/ronnylt/redlock-php&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Redlock-php&lt;/a&gt; (PHP 实现).&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/malkusch/lock#phpredismutex&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;PHPRedisMutex&lt;/a&gt; (further PHP 实现)&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/cheprasov/php-redis-lock&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;cheprasov/php-redis-lock&lt;/a&gt; (PHP 锁的库)&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/rtckit/reactphp-redlock&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;rtckit/react-redlock&lt;/a&gt; (Async PHP 实现)&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/go-redsync/redsync&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Redsync&lt;/a&gt; (Go 实现).&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/mrniko/redisson&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Redisson&lt;/a&gt; (Java 实现).&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/sbertrang/redis-distlock&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Redis::DistLock&lt;/a&gt; (Perl 实现).&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/jacket-code/redlock-cpp&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Redlock-cpp&lt;/a&gt; (C++ 实现).&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/kidfashion/redlock-cs&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Redlock-cs&lt;/a&gt; (C#/.NET 实现).&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/samcook/RedLock.net&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;RedLock.net&lt;/a&gt; (C#/.NET 实现). 包含异步和锁的扩展支持&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/psibernetic/scarletlock&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;ScarletLock&lt;/a&gt; (C# .NET 实现 可配置数据源)&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/LiZhenNet/Redlock4Net&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Redlock4Net&lt;/a&gt; (C# .NET 实现)&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/mike-marcacci/node-redlock&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;node-redlock&lt;/a&gt; (NodeJS 实现). 包含锁扩展的支持&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;安全和可用保障&#34;&gt;&lt;span&gt;安全和可用保障&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%ae%89%e5%85%a8%e5%92%8c%e5%8f%af%e7%94%a8%e4%bf%9d%e9%9a%9c&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;我们将使用三个特性模型化我们的设计，在我们看来，它们是高效地使用分布式锁的最低保障。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;安全性：互斥，任一时刻只有一个客户端能够持有锁&lt;/li&gt;&#xA;&lt;li&gt;可用性 A：无死锁，即使锁住资源的客户端崩溃了或者被隔离分区，（其他客户端）也要能够获取锁&lt;/li&gt;&#xA;&lt;li&gt;可用性 B：容错，只要大部分 Redis 节点存活，客户端就能够获取和释放锁&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;基于故障转移的实现的不足&#34;&gt;&lt;span&gt;基于故障转移的实现的不足&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%9f%ba%e4%ba%8e%e6%95%85%e9%9a%9c%e8%bd%ac%e7%a7%bb%e7%9a%84%e5%ae%9e%e7%8e%b0%e7%9a%84%e4%b8%8d%e8%b6%b3&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;为了理解我们想要改善的东西，让我们先分析下大多数基于 Redis 分布式锁的库的现状。&lt;/p&gt;&#xA;&lt;p&gt;使用 Redis 锁住一个资源最简单的方式是在实例中创建一个 key。利用 Redis 的过期特性，这个 key 会在一个有限的时间内存活，所以它最终会被释放（特性二）。当客户端想要释放资源的时候，它会删除这个 key。&lt;/p&gt;&#xA;&lt;p&gt;表面上这样可以正常工作，但是存在一个问题：系统的单点故障。如果 Redis 的主节点宕机会发生什么？当然我们可以增加一个从节点，并且在主节点不可用时使用它。不幸的是，因为 Redis 的复制是 &lt;strong&gt;异步&lt;/strong&gt; 的，这样做我们无法保证互斥的安全性。&lt;/p&gt;&#xA;&lt;p&gt;这个模型存在一个明显的竞态条件：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;客户端 A 获取主节点的锁&lt;/li&gt;&#xA;&lt;li&gt;主节点在将 key 传播给从节点之前宕机&lt;/li&gt;&#xA;&lt;li&gt;从节点被提升为主节点&lt;/li&gt;&#xA;&lt;li&gt;客户端 B 获取之前被 A 锁住的资源对应的锁，&lt;strong&gt;违反了安全规定&lt;/strong&gt;！&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;如果多个客户端在特殊情况下，比如故障期间，同时持有一个锁是完全可以的。那么你可以使用基于从节点的解决方案。否则我们建议实施本文描述的解决方案。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;单实例的正确实现&#34;&gt;&lt;span&gt;单实例的正确实现&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%8d%95%e5%ae%9e%e4%be%8b%e7%9a%84%e6%ad%a3%e7%a1%ae%e5%ae%9e%e7%8e%b0&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;在突破上文描述的单实例限制之前，让我们看看在这个简单的情况下该如何正确地做。因为这对于可以接受时不时出现竞态条件的应用实际上是一个可行的解决方案，并且着眼于单实例也是我们讨论分布式算法的基础。&lt;/p&gt;&#xA;&lt;p&gt;下述是一个获取锁的方法：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;SET resource_name my_random_value NX PX 30000&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个命令将会在 key 不存在时（NX 选项）设置这个 key，伴随着 30000 毫秒的过期时间（PX 选项）。这个键的值将被设置为随机值，并且在所有的客户端和锁请求中保持唯一性。&lt;/p&gt;&#xA;&lt;p&gt;本质上随机值是用来安全地释放锁的，伴随着脚本告诉 Redis：只有当键存在并且它的值与存储的值相符时才移除这个键。通过下述的 Lua 脚本来实现：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;if redis.call(&amp;#34;get&amp;#34;,KEYS[1]) == ARGV[1] then&#xA;    return redis.call(&amp;#34;del&amp;#34;,KEYS[1])&#xA;else&#xA;    return 0&#xA;end&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;避免移除一个被其他客户端创建的锁是重要的。比如一个客户端可能获取锁，被阻塞的时长超过锁的有效（过期）时长，随后清除这些已经被其他客户端获取的锁。只使用 &lt;code&gt;DEL&lt;/code&gt; 是 &lt;strong&gt;不安全&lt;/strong&gt; 的，客户端可能清除其他客户端的锁。用上文的脚本并且每个锁都用一个随机字符串签名，这样锁就只能被当初设置它的客户端清除。&lt;/p&gt;&#xA;&lt;p&gt;这个随机字符串应该是什么？我假设它是从 /dev/urandom 来的 20 字符，但是你可以用更高效的方式来保证它对于你的任务的唯一性。比如一个安全的选择是使用 /dev/urandom 作为 RC4 的种子，从中生成一个伪随机的流。一个更简单的解决方案是使用微秒级的 unix  时间，附加上客户端 ID，这不是那么安全，但可能在大多数环境中都可以胜任。&lt;/p&gt;&#xA;&lt;p&gt;我们设置的 key 的存活时间，被称作锁的有效时间。它既是自动释放的时间，也是客户端在锁被别的客户端再次获取之前，（保证技术上不违反互斥性）去执行所需操作的时间。互斥保证 &lt;strong&gt;仅限于&lt;/strong&gt; 从锁的那一刻开始的这个给定的时间窗口。&lt;/p&gt;&#xA;&lt;p&gt;因此现在我们有了一个好的方式去获取和释放锁。这个由始终可用的单实例组成的非分布式系统被论证为是安全的。让我们将这个概念扩展到一个没有此类保障的分布式系统。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;redlock-算法&#34;&gt;&lt;span&gt;Redlock 算法&lt;/span&gt;&#xA;  &lt;a href=&#34;#redlock-%e7%ae%97%e6%b3%95&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;在算法的分布式版本中，我们假设有 N 个 Redis 主节点。这些节点完全独立，我们并没有使用复制或者其他的辅助系统。我们已经描述过如何在单个实例中安全地获取和释放锁。我们也理所当然地认为算法会使用那个方法在单个实例中获取和释放锁。在我们的例子中，我们设置 N = 5，它是一个合理的值，因此我们需要在不同的计算器或虚拟机上运行 5 个 Redis 主节点来确保它们会以各自的方式宕机。&lt;/p&gt;&#xA;&lt;p&gt;为了获取锁，客户端将执行以下操作：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;获取毫秒级的当前时间&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;使用相同的键名和随机的值，依次在所有 N 个实例中获取锁。在第二步往每个实例设置锁的时候，客户端使用了一个小于锁自动释放时间的 &lt;code&gt;timeout&lt;/code&gt; 去获取锁。比如锁的自动释放为 10 秒，这个 timeout 可以在 5-50 毫秒的范围。这可以防止客户端与一个宕机的 Redis 节点维持过长的阻塞状态：如果一个实例不可用，我们应当尽快与下一个节点通信。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;客户端通过减去第一步中获取的时间戳计算出为了获取锁花费的时间。只有当客户端能够在大多数实例（至少 3 个）获取锁，并且花费的时间少于锁的有效时间时，才认为锁被获取了。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果锁被获取了，它的有效时间将是初始有效时间减去花费的时间，就如第三步计算的那样。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果客户端因为某些原因获取锁失败（要么是不能在 N/2+1 个实例中获取锁，要么是有效时间为负的），它会尝试 unlock 所有的实例（甚至是它认为不能锁的实例）。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;算法是异步的吗&#34;&gt;&lt;span&gt;算法是异步的吗？&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e7%ae%97%e6%b3%95%e6%98%af%e5%bc%82%e6%ad%a5%e7%9a%84%e5%90%97&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;这个算法依赖了假设 ，进程之间没有一个同步的锁，并且每个进程中的当地时钟以大致相同的速率流动，与锁的自动释放时间相比，误差很小。这个假设看起来像一个真实世界的计算机，每个计算机有一个当地时钟，我们可以依赖不同计算机来获取一个较小的时间偏移。&lt;/p&gt;&#xA;&lt;p&gt;在这点上我们需要明确指出我们的 &lt;strong&gt;互斥性规则&lt;/strong&gt;：只要持有锁的客户端在锁的有效时间（在第三步中得到的）（减去一些毫秒为了补偿不同计算机之间的时间偏移）内结束它的工作，就能保证互斥性。&lt;/p&gt;&#xA;&lt;p&gt;更多有关需要绑定时钟偏移的类似系统的信息，这个论文是一个有趣的参考：&lt;a href=&#34;http://dl.acm.org/citation.cfm?id=74870&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Leases: an efficient fault-tolerant mechanism for distributed file cache consistency&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;错误重试&#34;&gt;&lt;span&gt;错误重试&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e9%94%99%e8%af%af%e9%87%8d%e8%af%95&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;当一个客户端无法获取锁，它应该在一个 &lt;strong&gt;随机延迟&lt;/strong&gt; 后重试，来避免多个客户端在同一时刻尝试获取同一个资源的锁（这可能会导致脑裂，没有人胜出）。同时一个客户端在大多数 Redis 实例中获取锁越快，脑裂的窗口越小（重试的需要也是），因此理想情况下客户端应该尝试在同一时刻使用多路复用发送 SET 命令到 N 个实例。&lt;/p&gt;&#xA;&lt;p&gt;值得强调的是，当客户端们获取大多数锁失败时，尽快（部分地）释放获取的锁是多么的重要，如此就没有必要去等待锁过期才能被再次获取（然而如果网络被隔离，客户端不再能与 Redis 实例通信时，将因等待锁过期产生可用性损失）。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;安全论证&#34;&gt;&lt;span&gt;安全论证&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%ae%89%e5%85%a8%e8%ae%ba%e8%af%81&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;这个算法安全吗？我们可以尝试在不同场景下理解发生的事情。&lt;/p&gt;&#xA;&lt;p&gt;开始我们假设一个客户端能够在大多数实例中获取锁。所有的实例都包含一个有相同存活时间的 key。然而，key 在不同的时间被设置，因此 key 们会在不同的时间过期。但是如果第一个 key 在时间 T1 被设置（极端情况，我们联系第一个服务器之前的时间），最后一个 key 在 T2 被设置（极端情况，我们从最后一个服务器得到响应的时间），我们确信集合中第一个过期的 key 至少会存活 &lt;code&gt;MIN_VALIDITY=TTL-(T2-T1)-CLOCK_DRIFT&lt;/code&gt;。所有其他的键将随后过期，因此我们确信至少这一次所有的键会被同时设置。&lt;/p&gt;&#xA;&lt;p&gt;在大多数 key 被设置的过程中，其他客户端将不能获取这把锁，因为 N/2+1 个 SET NX 操作在 N/2+1 个 key 已经存在的情况下无法成功。因此如果一个锁已经被获取，它就没有可能在同一时刻被再次获取（违背了互斥性）。&lt;/p&gt;&#xA;&lt;p&gt;然而我们想要确保多个客户端不能在同一时刻同时获取锁。&lt;/p&gt;&#xA;&lt;p&gt;如果一个客户端用近乎或者大于锁有效时间（我们用 SET 时指定的存活时长）的时长锁住了大多数实例，它会认为锁失效并 unlock 所有的实例，因此我们只需要考虑客户端能够在有效时间内锁住大部分实例的情况。在这种情况下对于上文表述的论点，应该没有客户端能在 &lt;code&gt;MIN_VALIDITY&lt;/code&gt; 内再次获取锁。因此多个客户端只有用超过存活时间的时长去锁大部分实例，才能在同一时刻锁住 N/2+1 个实例，这样会让锁失效。&lt;/p&gt;&#xA;&lt;p&gt;你能否针对现有或类似算法，提供一个安全性的正式证明，或找到一个 bug？我们将不胜感激。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;可用性论证&#34;&gt;&lt;span&gt;可用性论证&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%8f%af%e7%94%a8%e6%80%a7%e8%ae%ba%e8%af%81&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;系统的可用性基于三个主要特性：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;锁的自动释放（键的过期）：最终键们可以被再次上锁&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;客户端通常在锁没有被获取时（获取失败），或者当锁被获取且工作结束时清除锁，我们不必等待键的过期就能够重新获取锁。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;客户端需要重试一把锁时会等待一段（超过获取大部分锁所需的时间的）时长，为了能在资源争用期间使脑裂不太可能。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;然而我们会在网络隔离时付出等同于存活时间的 &lt;strong&gt;可用性损失&lt;/strong&gt;，因此如果发生连续的网络隔离，我们可能无限期地付出这个损失。每一次客户端获取了一把锁，在能够清除锁之前被隔离时，都会发生这种情况。&lt;/p&gt;&#xA;&lt;p&gt;本质上如果存在无限连续的网络隔离，系统会在一段无限的时间内变的不可用。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;性能崩溃恢复和-fsync&#34;&gt;&lt;span&gt;性能、崩溃恢复和 fsync&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%80%a7%e8%83%bd%e5%b4%a9%e6%ba%83%e6%81%a2%e5%a4%8d%e5%92%8c-fsync&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;许多用户使用 Redis 作为一个锁服务，需要较高的性能去获取和释放锁，并且每秒钟可能执行许多获取和释放操作。为了满足这个需求，与 N 个 Redis 服务对话来降低延迟的策略显然是采用多路复用（或者说是穷人的多路复用，也就是把 socket 设为非阻塞模式，发送所有的命令，之后再读取所有的命令，假设客户端和各个实例之间的 RTT 是相似的）。&lt;/p&gt;&#xA;&lt;p&gt;然而，如果我们想要以崩溃恢复系统模型为模型，就还有一个关于持有型的注意事项。&lt;/p&gt;&#xA;&lt;p&gt;为了在这里看清这个问题，让我们假设我们没有配置 Redis 的持有化。一个客户端获取了 3/5 个实例的锁。其中一个能被客户端获取锁的实例被 &lt;strong&gt;重启&lt;/strong&gt; 了，此时又有三个实例能让我们为相同的资源上锁，并且其他的客户端可以再次锁住它，这违反了锁互斥的安全特性。&lt;/p&gt;&#xA;&lt;p&gt;如果我们开启 AOF 持久化，情况就能改善很多。比如我们可以通过发送 SHUTDOWM 来升级一个服务器并重启。因为 Redis 的过期是语义上实现的，因此在服务器离线时时间仍会流逝，所有我们的需求都很好。然而只要它是干净的关闭，一切都很好。停电怎么办？ 如果 Redis 默认配置为每秒在磁盘上 fsync 一次，那么重启后我们的密钥可能会丢失。 理论上，如果我们想在任何类型的实例重启时保证锁的安全性，我们需要在持久化设置中启用 &lt;code&gt;fsync=always&lt;/code&gt;。 这反过来又会完全破坏与传统上用于以安全方式实现分布式锁的 CP 系统相同级别的性能。&lt;/p&gt;&#xA;&lt;p&gt;然而，事情比乍看之下要好。 基本上只要实例在崩溃后重新启动，算法就保持安全，它不再参与任何当前处于活动状态的锁。因此实例重新启动时当前处于活动状态的锁的集合，在被获取时排除了重新加入系统的这个实例。&lt;/p&gt;&#xA;&lt;p&gt;为了保证这一点，我们只需要在崩溃后使实例在至少比使用的最大存活时间多一点的时间内不可用，即实例崩溃时所有存在的键失效被自动释放所需的时间。&lt;/p&gt;&#xA;&lt;p&gt;即使没有任何可用的 Redis 持久性，使用延迟重启也基本上可以实现安全，但是请注意，这可能会转化为可用性损失。例如，如果大多数实例崩溃，系统将在存活时间内全局不可用（这里全局意味着在此期间根本没有资源可被锁定）。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;更加可靠的算法锁的扩展&#34;&gt;&lt;span&gt;更加可靠的算法：锁的扩展&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%9b%b4%e5%8a%a0%e5%8f%af%e9%9d%a0%e7%9a%84%e7%ae%97%e6%b3%95%e9%94%81%e7%9a%84%e6%89%a9%e5%b1%95&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;如果客户端执行的工作由小步骤组成，则可以默认使用较小的锁有效时间，并可以扩展一个实现锁扩展机制的算法。 基本上客户端，如果在计算过程中锁有效性（有效时间）接近一个低值，可以通过向所有实例发送一个 Lua 脚本来扩展锁的存活时间（如果 key 存在并且它的值仍然是获取锁时客户端分配的随机值）。&lt;/p&gt;&#xA;&lt;p&gt;如果客户端能够在有效时间内将锁扩展到大多数实例，（基本上使用的算法与获取锁时使用的算法非常相似），客户端应该只考虑重新获取锁。&lt;/p&gt;&#xA;&lt;p&gt;然而，这在技术上并没有改变算法，因此应该限制重新获取锁的最大尝试次数，否则会违反可用性属性之一。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;redlock-的分析&#34;&gt;&lt;span&gt;Redlock 的分析&lt;/span&gt;&#xA;  &lt;a href=&#34;#redlock-%e7%9a%84%e5%88%86%e6%9e%90&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;Martin Kleppmann &lt;a href=&#34;https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;在这里分析了 Redlock&lt;/a&gt;。我不同意这分析，且在这里对他的分析提出了&lt;a href=&#34;http://antirez.com/news/101&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;我的回复&lt;/a&gt;。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Ruby：版本管理 RVM、Gem 与 Bundler</title>
      <link>https://hoffmanzheng.github.io/2021/ruby-bundler/</link>
      <pubDate>Sun, 10 Oct 2021 13:19:47 +0100</pubDate>
      <guid>https://hoffmanzheng.github.io/2021/ruby-bundler/</guid>
      <category domain="https://hoffmanzheng.github.io/categories/study-notes/">Study Notes</category>
      <description>&lt;p&gt;本篇介绍在 Ruby 项目中版本及包管理的工程实践，包括使用 &lt;a href=&#34;https://rubygems.org/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;RubyGems&lt;/a&gt; 管理 Ruby 的组件，使用 &lt;a href=&#34;https://bundler.io/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Bundler&lt;/a&gt; 来解决项目中 gem 组件的依赖问题，使用 &lt;a href=&#34;https://rvm.io/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;RVM&lt;/a&gt; 管理不同版本的 Ruby 环境等。&lt;/p&gt;&#xA;&lt;p&gt;推荐阅读：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://ruby-china.org/topics/28453&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Bundler 到底是怎么工作的(暨 Ruby 依赖管理历史回顾)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://ruby-china.org/topics/26655&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Ruby Gemfile 详解&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;rubygems&#34;&gt;&lt;span&gt;RubyGems&lt;/span&gt;&#xA;  &lt;a href=&#34;#rubygems&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;Ruby 主要通过 &lt;code&gt;require&lt;/code&gt; 函数来引入外部的库文件，参数可以传文件名，相对路径或是绝对路径。当参数是文件名时，Ruby 会去 &lt;code&gt;$LOAD_PATH&lt;/code&gt; 这个全局变量定义的路径中搜索库文件。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ ruby -e &amp;#34;puts $:&amp;#34; &#xA;/usr/local/lib/ruby/site_ruby/2.7.0&#xA;/usr/local/lib/ruby/site_ruby/2.7.0/x86_64-darwin20&#xA;/usr/local/lib/ruby/site_ruby&#xA;/usr/local/lib/ruby/vendor_ruby/2.7.0&#xA;/usr/local/lib/ruby/vendor_ruby/2.7.0/x86_64-darwin20&#xA;/usr/local/lib/ruby/vendor_ruby&#xA;/usr/local/Cellar/ruby@2.7/2.7.4/lib/ruby/2.7.0&#xA;/usr/local/Cellar/ruby@2.7/2.7.4/lib/ruby/2.7.0/x86_64-darwin20&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;$LOAD_PATH 是一个数组变量，里面存放依赖路径字符串，可以看到其中的目录可以分成三大类：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;site_ruby 默认优先级最高，安装本机相关库&lt;/li&gt;&#xA;&lt;li&gt;vendor_ruby 操作系统供应商进行定制用的，一般为空&lt;/li&gt;&#xA;&lt;li&gt;2.7.4 ruby 标准库目录，比如 date, csv 库&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;require 会按照 $LOAD_PATH 数组里面的路径顺序进行查找，找到了就不继续往下找了。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://rubygems.org/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;RubyGems&lt;/a&gt; 是用来寻找并管理 Ruby 组件的工具，让你可以轻松下载别人的代码，它重写了 require 函数的实现，并将 gem 安装到和 site_ruby 平级的 &lt;code&gt;gems&lt;/code&gt; 目录下。gem 工具允许你用一个单一命令完成下载以及安装，允许你一键卸载，并且中心化管理所有安装了的库。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;gem install rails -v 4.1&#xA;gem uninstall&#xA;gem list rails&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但 RubyGems 也有没有解决的问题，一个大问题就是没有依赖的版本控制，并且大多数 gem 都被安装进的同一个路径下，如果系统中存在多个需要 gem 的 Ruby 项目，又该如何对依赖的 gem 版本进行分别管理呢？&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;bundler&#34;&gt;&lt;span&gt;Bundler&lt;/span&gt;&#xA;  &lt;a href=&#34;#bundler&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;Bundler 的出现修复了 RubyGems 没有解决的问题，它让项目可以根据定义来使用 gem，并且在安装 gem 时就进行版本冲突的解析。Ruby 的开发者只需要列出他所需要的 Gem，然后 Bundler 就会找出合适的版本让它们在一起工作，并且把一个可行解（但不一定是最优解）放入 Gemfile.lock。这个文件保证了共享代码或者部署到服务器时能够安装到正确的依赖版本。&lt;/p&gt;&#xA;&lt;p&gt;Bundler 的工作原理，See: &lt;a href=&#34;https://bundler.io/rationale.html&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Bundler&amp;rsquo;s Purpose and Rationale&lt;/a&gt;。在应用根目录 &lt;code&gt;Gemfile&lt;/code&gt; 文件里声明依赖后，Bundler 会去 source 指定的 &lt;code&gt;https://rubygems.org&lt;/code&gt; 上寻找 gem&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;source &amp;#39;https://rubygems.org&amp;#39;&#xA;&#xA;gem &amp;#39;rails&amp;#39;, &amp;#39;4.1.0.rc2&amp;#39;&#xA;gem &amp;#39;rack-cache&amp;#39;&#xA;gem &amp;#39;nokogiri&amp;#39;, &amp;#39;~&amp;gt; 1.6.1&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;项目第一次安装依赖时可以执行 &lt;code&gt;bundle install --path=vendor/bundle&lt;/code&gt; 把 gem 安装到项目的 vendor/bundle 目录下，再在 git 中忽略此目录，这样做就不会因为多个项目安装 gem 到系统目录，而导致系统里的 gem 冲突。&lt;/p&gt;&#xA;&lt;p&gt;因为在 Gemfile 中声明的依赖有它们自己的依赖，所以运行 bundle install 会安装相当多的 gem。如果任何需要的 gem 已经被安装了，bundler 会直接使用它们。在所有需要的 gem 被成功安装后，bundler 会写一个所有这些 gem 和它们的版本号的快照到 &lt;code&gt;Gemfile.lock&lt;/code&gt; 中。&lt;/p&gt;&#xA;&lt;p&gt;如果开发的是个 Rails 应用，默认就有可以可以运行 bundler 的代码了。对于其他的应用（比如基于 Sinatra 的应用），需要在引用任何 gem 之前配置一下 bundler。比如在 &lt;code&gt;require &#39;sinatra&#39;&lt;/code&gt; 的那个文件的第一行加入以下代码：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;require &amp;#39;rubygems&amp;#39;               // Ruby 1.8 以后的版本不再需要这句&#xA;require &amp;#39;bundle/setup&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样 bundler 就能将 gem 的地址加入到 &lt;code&gt;$LOAD_PATH&lt;/code&gt; 中，以此来让 require 正常工作。&lt;/p&gt;&#xA;&lt;p&gt;Gemfile 和 Gemfile.lock 应该被一起放到 &lt;strong&gt;版本管理&lt;/strong&gt; 中，这样版本库中就有了应用最后一次确定能正常工作时所有的 gem 及版本号的记录。当在别的机器上获取应用代码并执行 bundle install 时，bundler 会找到 Gemfile.lock，跳过解决依赖的步骤并按照之前记录的依赖版本号获取 gem。仅在 Gemfile 确切地指定依赖的第三方版本并 &lt;strong&gt;不能保证&lt;/strong&gt; 应用使用正确的依赖版本，因为 gem 通常给它们自己的依赖声明一个版本号的范围。&lt;/p&gt;&#xA;&lt;p&gt;Bundle install 会 &lt;strong&gt;保守&lt;/strong&gt; 地执行依赖升级，不会更新在 Gemfile 中没有显式更改的 gem（或者它们的依赖）。举个例子，rails 依赖了 actionpack，actionpack 又依赖了 rack，与此同时 rack-cache 也依赖了 rack，如果在更新 rails 的同时也更新了依赖的 rack，没有得到更新的 rack-cache 就可能与新版的 rack 出现不可预见的兼容问题。对此，如果 Gemfile 中的 rack-cache 没有被修改，bundler 就会把它和它的依赖 (rack) 当成一个不可修改的整体。&lt;/p&gt;&#xA;&lt;p&gt;可以使用 &lt;code&gt;bundle update&lt;/code&gt; 命令（不推荐），在不修改 Gemfile 的情况下更新 gem，但这个命令会从头开始解决依赖并忽略掉 Gemfile.lock，需要做好全面的测试和 &lt;code&gt;git reset --hard&lt;/code&gt; 的准备。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;bundle update rack-cache        // 更新 rack-cache 到 Gemfile 里允许的最新版本&#xA;bundle update                   // 升级所有 Gemfile 里的 gem 到最新能用的版本&lt;/code&gt;&lt;/pre&gt;&lt;h3 class=&#34;heading-element&#34; id=&#34;ruby-environment-manager&#34;&gt;&lt;span&gt;Ruby enVironment Manager&lt;/span&gt;&#xA;  &lt;a href=&#34;#ruby-environment-manager&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;RVM 支持管理多个 Ruby 应用环境并且支持切换。对 Ruby 版本管理的方法如下（See: &lt;a href=&#34;https://rvm.io/rvm/basics&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;The Basics of RVM&lt;/a&gt;）：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ rvm install 2.7.4             // 安装并使用指定版本&#xA;$ rvm list                      // 列举 RVM 安装过的 Ruby 版本  &#xA;# =* - current &amp;amp;&amp;amp; default&#xA; * ruby-2.6.3 [ x86_64 ]        #  * - default&#xA;=&amp;gt; ruby-2.7.4 [ x86_64 ]        # =&amp;gt; - current&#xA;$ ruby -v                       // 当前使用的 Ruby 版本&#xA;$ which ruby                    // 当前使用的 Ruby 的路径&#xA;/Users/hoffman.zheng/.rvm/rubies/ruby-2.7.4/bin/ruby   // 注意放在~/.rvm 目录下&#xA;$ rvm --default use 2.7.4       // 设置默认的 Ruby 版本&#xA;$ rvm use 2.6.3                 // 设置当前的 Ruby 版本&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;RVM 会隔离当前操作系统中已经安装的 Ruby 版本，如需切换回系统的 Ruby，可以让 RVM 撤销已经应用的环境更改：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ rvm use system                // 切换回系统的 Ruby&#xA;$ which ruby&#xA;/usr/local/opt/ruby@2.7/bin/ruby     // 切换回的系统 Ruby 的路径&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;RVM 会为每个版本的 Ruby 创建一个完全隔离的 Gem 目录，此外还可以根据项目/应用将 Gem 依赖们进一步分开（See: &lt;a href=&#34;https://rvm.io/gemsets/basics&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Named Gem Sets&lt;/a&gt;）：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ which ruby                    // 当前使用的 Ruby 的路径&#xA;/Users/hoffman.zheng/.rvm/rubies/ruby-2.7.4/bin/ruby   // 注意放在~/.rvm 目录下&#xA;$ rvm gemdir                    // 当前版本 Ruby 的 Gem 目录&#xA;/Users/hoffman.zheng/.rvm/gems/ruby-2.7.4&#xA;$ rvm 2.6.3@testing --create    // 为 2.6.3@test 创建一个隔离的 gems 文件夹&#xA;$ rvm gemdir&#xA;/Users/hoffman.zheng/.rvm/gems/ruby-2.6.3@test&#xA;$ rvm gemset create alias1 alias2     // 为当前版本 Ruby 创建两个 gems 环境&#xA;$ rvm 2.6.3@alias1              // 切换使用的 gems 环境&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以在文件资源管理器中看到，RVM 为 2.6.3 版本的 Ruby 又创建了一个单独的 gems 文件夹（如果根本没有使用 RVM 的 gemset，会从 default 目录获取 gems；一个具名的 gemset 将会从 global 中继承 gems，或者说 global 文件夹允许用户共享 gems）：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/ruby-namedGemsets.png&#39; alt=&#34;/images/ruby-namedGemsets.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;如果仍对 RVM 的工作流不熟悉，可以参考下官方给的 workflow：&lt;a href=&#34;https://rvm.io/workflow/examples&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Examples of using RVM&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>深入解析 Spring 架构与设计</title>
      <link>https://hoffmanzheng.github.io/2021/java-spring/</link>
      <pubDate>Thu, 26 Aug 2021 13:19:47 +0100</pubDate>
      <guid>https://hoffmanzheng.github.io/2021/java-spring/</guid>
      <category domain="https://hoffmanzheng.github.io/categories/reading-notes/">Reading Notes</category>
      <description>&lt;p&gt;&lt;a href=&#34;https://spring.io/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Spring&lt;/a&gt; 在 Java 开发中，有着不可替代的作用和地位。Spring 的目标在于让 Java EE 的开发变得更容易，这也意味着 Spring 框架的使用也应该是容易的。相比与 EJB 模型引入的过度的复杂性，Spring 提供了 IoC 容器和 AOP 支持，来降低框架对应用的 &lt;strong&gt;侵入性&lt;/strong&gt;。在处理与现有优秀解决方案的关系时，Spring 不会与这些第三方的解决方案发生竞争，而是致力于为应用提供使用优秀方案的集成平台，真正地把 Spring 定位在应用平台的地位，使得自己成为一个兼容并包的开放体系。&lt;/p&gt;&#xA;&lt;p&gt;本篇结合 &lt;a href=&#34;https://book.douban.com/subject/10470970/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;《Spring技术内幕（第2版）》&lt;/a&gt; 从源代码的角度讲解 Spring 的各个主要功能模块的设计和实现原理。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;ioc-容器的实现&#34;&gt;&lt;span&gt;IoC 容器的实现&lt;/span&gt;&#xA;  &lt;a href=&#34;#ioc-%e5%ae%b9%e5%99%a8%e7%9a%84%e5%ae%9e%e7%8e%b0&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;如果每个对象都需要靠自身实现去获取它所 &lt;strong&gt;依赖&lt;/strong&gt; 的对象，会引起代码的高度耦合并且难以测试。很多对象并不会经常发生变化，它们之间的相互依赖关系也是比较稳定的，不会随着应用的 &lt;strong&gt;运行状态&lt;/strong&gt; 的改变而改变，这些特性使得这些对象依赖关系的建立和维护可以交由容器来统一完成。&lt;/p&gt;&#xA;&lt;p&gt;IoC 容器的出现使得对象的依赖注入可以从代码中 &lt;strong&gt;解耦&lt;/strong&gt; 出来，把对依赖的 &lt;strong&gt;控制权&lt;/strong&gt; 从具体业务对象手中转交到平台或者框架中，有效地解决了面对对象系统设计的复杂性和系统的可测试性。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;beanfactory-对-ioc-容器的功能定义&#34;&gt;&lt;span&gt;BeanFactory 对 IoC 容器的功能定义&lt;/span&gt;&#xA;  &lt;a href=&#34;#beanfactory-%e5%af%b9-ioc-%e5%ae%b9%e5%99%a8%e7%9a%84%e5%8a%9f%e8%83%bd%e5%ae%9a%e4%b9%89&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;以 BeanFactory 的实现类 &lt;code&gt;XmlBeanFactory&lt;/code&gt; 为例，它继承了 DefaultListableBeanFactory 并在其基础上增加了功能，从名字上可以猜到，它是一个可以读取以 XML 文件方式定义的 &lt;code&gt;BeanDefinition&lt;/code&gt;（管理了对象之间的相互依赖关系） 的 IoC 容器。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/XmlBeanFactory.png&#39; alt=&#34;/images/XmlBeanFactory.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;DefaultListableBeanFactory&lt;/code&gt; 是一个很重要的 IoC 实现，其他的 IoC 容器比如 ApplicationContext，也是通过持有或者扩展 DefaultListableBeanFactory 来获得基本的 IoC 容器的功能的。BeanDefinition 的信息来源被封装在 &lt;code&gt;Resource&lt;/code&gt; 中，对 XML 文件定义信息的具体处理又委托给了 &lt;code&gt;XmlBeanDefinitionReader&lt;/code&gt; 来实现。它们间相互关系的伪代码如下：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;ClassPathResource res = new ClassPathResource(&amp;#34;beans.xml&amp;#34;);    // IoC 配置文件的抽象资源&#xA;DefaultListableBeanFactory factory = new DefaultListableBeanFactory();&#xA;XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);  // BeanDefinition 读取器&#xA;reader.loadBeanDefinitions(res);  // 载入和注册 Bean&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;ApplicationContext&lt;/code&gt; 是一个高级形态意义的 IoC 容器，它除了提供 BeanFactory 的基本功能外，还为用户提供了附加服务，比如支持不同的信息源（国际化），支持不同的访问资源，支持应用事件。这些丰富的附加功能，使得 ApplicationContext 以一种更加面向框架的方式工作以及对上下文进行分层和实现继承。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;ioc-容器的初始化&#34;&gt;&lt;span&gt;IoC 容器的初始化&lt;/span&gt;&#xA;  &lt;a href=&#34;#ioc-%e5%ae%b9%e5%99%a8%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;IoC 容器的初始化（一般不包含 Bean 依赖注入的实现）包括 BeanDefinition 的 Resouce 定位、载入和注册这三个基本的过程。值得注意的是，Spring在实现中是把这三个过程分开并使用不同的模块来完成的，这样可以让用户更加灵活地对这三个过程进行剪裁和扩展。&lt;/p&gt;&#xA;&lt;p&gt;以 &lt;code&gt;ClassPathXmlApplicationContext&lt;/code&gt; 为例，它通过继承 DefaultResourceLoader 具备了读入 Resource 的能力，在构造函数中通过 &lt;code&gt;refresh&lt;/code&gt; 来启动 IoC 容器的初始化：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;public class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext {&#xA;    ...&#xA;    // configLocations 支持一个或多个 BeanDefinition 所在的文件路径&#xA;    // 还允许指定自己的双亲 IoC 容器&#xA;    // 在对象的初始化过程中，调用 refresh 函数，启动了 BeanDefinition 的载入过程（后文分析）&#xA;    public ClassPathXmlApplicationContext(String[] configLocations, &#xA;        boolean refresh, @Nullable ApplicationContext parent) throws BeansException {&#xA;        super(parent);&#xA;        setConfigLocations(configLocations);&#xA;        if (refresh) {&#xA;            refresh();&#xA;        }&#xA;    }&#xA;    &#xA;    // clazz - 加载资源的类（基于给定路径）&#xA;    public ClassPathXmlApplicationContext(String[] paths, Class&amp;lt;?&amp;gt; clazz, &#xA;        @Nullable ApplicationContext parent) throws BeansException {&#xA;        super(parent);&#xA;        Assert.notNull(paths, &amp;#34;Path array must not be null&amp;#34;);&#xA;        Assert.notNull(clazz, &amp;#34;Class argument must not be null&amp;#34;);&#xA;        this.configResources = new Resource[paths.length];&#xA;        for (int i = 0; i &amp;lt; paths.length; i&amp;#43;&amp;#43;) {&#xA;            this.configResources[i] = new ClassPathResource(paths[i], clazz);&#xA;        }&#xA;        refresh();&#xA;    }&#xA;    ...&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;AbstractApplicationContext 中的 refresh 函数会触发整个 BeanDefinition 的载入过程，然后调用  AbstractRefreshableApplicationContext 实现的 &lt;code&gt;refreshBeanFactory&lt;/code&gt; ，最后委托给 XmlBeanDefinitionReader 执行 &lt;code&gt;loadBeanDefinitions&lt;/code&gt;，具体的流程见下图：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/spring-refreshBeanFactory.png&#39; alt=&#34;/images/spring-refreshBeanFactory.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;通过代码看一下容器初始化的具体实现：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// AbstractRefreshableApplicationContext&#xA;protected final void refreshBeanFactory() throws BeansException {&#xA;    if (hasBeanFactory()) {  // shutting down the previous bean factory (if any)&#xA;        destroyBeans();&#xA;        closeBeanFactory();&#xA;    }&#xA;    try {&#xA;        // initializing a fresh bean factory&#xA;        DefaultListableBeanFactory beanFactory = createBeanFactory(); &#xA;        beanFactory.setSerializationId(getId());&#xA;        customizeBeanFactory(beanFactory);&#xA;        // 调用 loadBeanDefinitions 载入 BeanDefinition 的信息&#xA;        loadBeanDefinitions(beanFactory);&#xA;        synchronized (this.beanFactoryMonitor) {&#xA;            this.beanFactory = beanFactory;&#xA;        }&#xA;    }&#xA;    catch (IOException ex) {&#xA;        throw new ApplicationContextException(&amp;#34;I/O error parsing bean definition source for &amp;#34; &amp;#43; getDisplayName(), ex);&#xA;    }&#xA;}&#xA;&#xA;// loadBeanDefinitions 通过一个抽象函数把具体的实现委托给子类来完成&#xA;protected abstract void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException;&#xA;&#xA;// AbstractXmlApplicationContext&#xA;protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {&#xA;    // Create a new XmlBeanDefinitionReader for the given BeanFactory.&#xA;    XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);&#xA;&#xA;    // Configure the bean definition reader with this context&amp;#39;s resource loading environment.&#xA;    beanDefinitionReader.setEnvironment(this.getEnvironment());&#xA;    beanDefinitionReader.setResourceLoader(this);&#xA;    beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));&#xA;&#xA;    // Allow a subclass to provide custom initialization of the reader,&#xA;    // then proceed with actually loading the bean definitions.&#xA;    initBeanDefinitionReader(beanDefinitionReader);&#xA;    loadBeanDefinitions(beanDefinitionReader);&#xA;}&#xA;&#xA;protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {&#xA;    // 获取需要的 Rescource 集合或者配置文件集合，使用 reader 去解析文件&#xA;    Resource[] configResources = getConfigResources();&#xA;    if (configResources != null) {&#xA;        reader.loadBeanDefinitions(configResources);&#xA;    }&#xA;    String[] configLocations = getConfigLocations();&#xA;    if (configLocations != null) {&#xA;        reader.loadBeanDefinitions(configLocations);&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Spring 可以处理不同形式的 BeanDefinition，由于这里使用的是XML方式的定义，所以需要使用XmlBeanDefinitionReader。接下来看一下 BeanDefinition 的具体解析和载入过程：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/spring-loadBeanDefinition.png&#39; alt=&#34;/images/spring-loadBeanDefinition.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;AbstractBeanDefinitionReader 会委托 &lt;code&gt;ResourceLoader&lt;/code&gt; 来获取 BeanDefinition 的 Resource，&#xA;随后调用的 &lt;code&gt;loadBeanDefinitions(Resource res)&lt;/code&gt; 在 BeanDefinitionReader 中是一个接口方法，&#xA;具体的实现在 XmlBeanDefinitionReader 中。这个 Resource 对象封装了对 XML文件的 IO 操作，&#xA;读取器会在读取后委托 DefaultDocumentLoader 执行 &lt;strong&gt;通用的 XML 解析&lt;/strong&gt; 获取 Document 对象，&#xA;随后在 registerBeanDefinitions(doc, resource) 中就可以按照 Spring 的 Bean 定义规则来对这个 XML 的文档树进行解析并转化为容器内部的数据结构了（这一步实现委托给了 DefaultBeanDefinitionDocumentReader）。&lt;/p&gt;&#xA;&lt;p&gt;具体的 Spring BeanDefinition 的解析是在 &lt;code&gt;BeanDefinitionParserDelegate&lt;/code&gt; 中完成的，这个类里包含了各种 Spring Bean 定义规则的处理。id、name、aliase 等属性元素的值会被从 XML 文件相应的元素的属性中读取出来，然后被设置到生成的 &lt;code&gt;BeanDefinitionHolder&lt;/code&gt; 中去，其他的属性比如 beanClass、description、lazyInit 等也会在这里被处理。经过逐层地解析，在 XML 文件中定义的 BeanDefinition 就被整个给载入到了 IoC 容器中，并在容器中建立了数据映射。IoC 容器至此大致完成了管理 Bean 对象的 &lt;strong&gt;数据准备&lt;/strong&gt; 工作（或者说是初始化过程）。但是重要的依赖注入实际上在这个时候还没有发生，要完全发挥容器的作用，还需完成数据向容器的注册。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/spring-BeanDefinitionReader.png&#39; alt=&#34;/images/spring-BeanDefinitionReader.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;向容器中注册 Bean 即是将 beanName 与 BeanDefinition 的映射关系写入到 DefaultListableBeanFactory 内部的哈希表中。如果遇到同名的 BeanDefinition，进行处理的时候需要依据 allowBeanDefinitionOverriding 的配置来完成。完成注册后，BeanDefinition 就可以被容器使用了，这些信息是容易建立依赖反转的基础。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;ioc-容器的依赖注入&#34;&gt;&lt;span&gt;IoC 容器的依赖注入&lt;/span&gt;&#xA;  &lt;a href=&#34;#ioc-%e5%ae%b9%e5%99%a8%e7%9a%84%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;依赖注入的过程通常是用户第一次向 IoC 容器索要 Bean 时触发的，也就是 BeanFactory 的 getBean&#xA;接口，其具体实现在 AbstractBeanFactory 中：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/spring-getBean.png&#39; alt=&#34;/images/spring-getBean.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;对于 IoC 容器的使用，Spring 提供了许多参数的配置，每一个参数配置实际上代表了一个 IoC&#xA;容器的实现特性，这些特性的实现很多都需要在依赖注入的过程中或者对 Bean&#xA;进行生命周期管理的过程中来完成&lt;/p&gt;&#xA;&lt;p&gt;createBean 不但生成了需要的 Bean，还对 Bean 初始化进行了处理，比如实现了在 BeanDefinition&#xA;中的 init-method 属性定义，Bean 后置处理器的实现，等等&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;容器的其他特性&#34;&gt;&lt;span&gt;容器的其他特性&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%ae%b9%e5%99%a8%e7%9a%84%e5%85%b6%e4%bb%96%e7%89%b9%e6%80%a7&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;h3 class=&#34;heading-element&#34; id=&#34;spring-aop-的实现&#34;&gt;&lt;span&gt;Spring AOP 的实现&lt;/span&gt;&#xA;  &lt;a href=&#34;#spring-aop-%e7%9a%84%e5%ae%9e%e7%8e%b0&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;h3 class=&#34;heading-element&#34; id=&#34;spring-mvc-与-web-环境&#34;&gt;&lt;span&gt;Spring MVC 与 Web 环境&lt;/span&gt;&#xA;  &lt;a href=&#34;#spring-mvc-%e4%b8%8e-web-%e7%8e%af%e5%a2%83&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;h3 class=&#34;heading-element&#34; id=&#34;数据库操作组件的实现&#34;&gt;&lt;span&gt;数据库操作组件的实现&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%95%b0%e6%8d%ae%e5%ba%93%e6%93%8d%e4%bd%9c%e7%bb%84%e4%bb%b6%e7%9a%84%e5%ae%9e%e7%8e%b0&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;h3 class=&#34;heading-element&#34; id=&#34;spring-事务处理的实现&#34;&gt;&lt;span&gt;Spring 事务处理的实现&lt;/span&gt;&#xA;  &lt;a href=&#34;#spring-%e4%ba%8b%e5%8a%a1%e5%a4%84%e7%90%86%e7%9a%84%e5%ae%9e%e7%8e%b0&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;</description>
    </item>
    <item>
      <title>Database：Redis 设计与实现</title>
      <link>https://hoffmanzheng.github.io/2021/database-redis/</link>
      <pubDate>Sat, 08 May 2021 13:19:47 +0100</pubDate>
      <guid>https://hoffmanzheng.github.io/2021/database-redis/</guid>
      <category domain="https://hoffmanzheng.github.io/categories/reading-notes/">Reading Notes</category>
      <description>&lt;p&gt;Redis 是一个开源的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件，支持多种类型的数据结构和范围查询。 Redis 内置了复制（replication）、事务（transactions）和不同级别的磁盘持久化（persistence），并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（high availability）。&lt;/p&gt;&#xA;&lt;p&gt;本篇将结合 &lt;a href=&#34;https://book.douban.com/subject/25900156/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;《Redis 设计与实现》&lt;/a&gt; 讲解 Redis 的内部机制、单机特性以及多机特性。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;redis-数据结构&#34;&gt;&lt;span&gt;Redis 数据结构&lt;/span&gt;&#xA;  &lt;a href=&#34;#redis-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;Redis 有五种不同的 &lt;strong&gt;对象类型&lt;/strong&gt;，包括字符串、列表、哈希、集合和有序集合，每种对象都用到了至少一种数据结构，这样就可以根据不同的使用场景，为对象设置不同的数据结构（内部编码）实现，从而优化对象在不同场景下的使用效率。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/redis-data-structure.jpg&#39; alt=&#34;/images/redis-data-structure.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;如上图所示，可以看到每种数据结构都有 2 种以上的 &lt;strong&gt;内部编码实现&lt;/strong&gt;，例如 String 数据结构就包含了 raw、int 和 embstr 三种内部编码。同时，有些内部编码可以作为多种外部数据结构的内部实现，例如 ziplist 就是 hash、list 和 zset 共有的内部编码，而 set 的内部编码可能是 hashtable 或者 intset。&lt;/p&gt;&#xA;&lt;p&gt;Redis 使用对象来表示数据库中的键和值，每次当我们在 Redis 数据库中新创建一个键值对时，我们至少会创建两个对象，一个键对象，一个值对象。每个对象都由一个 &lt;code&gt;redisObject&lt;/code&gt; 结构表示：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;typedef struct redisObject {&#xA;&#x9;unsigned type : 4;        // 类型&#xA;&#x9;unsigned encoding : 4;    // 编码&#xA;&#x9;void *ptr;                // 指向底层实现数据结构的指针&#xA;&#x9;// ...&#xA;} robj;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为 C 语言并不具备自动内存回收功能，所以 Redis 在自己的对象系统中构建了一个 &lt;strong&gt;引用计数&lt;/strong&gt; 技术实现的内存回收机制。对象的引用计数属性还带有 &lt;strong&gt;对象共享&lt;/strong&gt; 的作用，不仅字符串键可以使用共享对象，那么在数据结构中嵌套了字符串对象的对象都可以使用这些共享对象。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;字符串&#34;&gt;&lt;span&gt;字符串&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%ad%97%e7%ac%a6%e4%b8%b2&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;Redis 中的字符串对象是 &lt;strong&gt;可以修改&lt;/strong&gt; 的，称为 SDS &lt;code&gt;Simple Dynamic String&lt;/code&gt;，简单动态字符串。它有三种不同的编码实现：int、raw、embstr。当一个 key 的 value 是整型时，Redis 就将其编码为 int 类型，这种编码类型节省了内存。Redis 默认会缓存 10000 个整型值（#define OBJSHAREDINTEGERS 10000），这就意味着，如果有 10 个不同的 KEY，其 value 都是 10000 以内的值，事实上全部都是 &lt;strong&gt;共享同一个对象&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; set msg 9999&#xA;OK&#xA;127.0.0.1:6379&amp;gt; object encoding msg&#xA;&amp;#34;int&amp;#34;&#xA;127.0.0.1:6379&amp;gt; set msg hello&#xA;OK&#xA;127.0.0.1:6379&amp;gt; object encoding msg&#xA;&amp;#34;embstr&amp;#34;&#xA;127.0.0.1:6379&amp;gt; set story &amp;#34;long, long, long ago there lived a king.&amp;#34;&#xA;OK&#xA;127.0.0.1:6379&amp;gt; strlen story&#xA;(integer) 40&#xA;127.0.0.1:6379&amp;gt; object encoding story&#xA;&amp;#34;raw&amp;#34;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;embstr&lt;/code&gt; 和 raw 编码的长度界限是 39，长度超过 39 字节以后，就是 raw 编码类型。embstr 编码将创建字符串对象所需的 &lt;strong&gt;空间分配的次数&lt;/strong&gt; 从 raw 编码的两次降低为一次。因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起 raw 编码的字符串对象能更好地利用缓存带来的优势，并且释放 embstr 编码的字符串对象只需要调用一次内存释放函数，而释放 raw 编码对象的字符串对象需要调用两次内存释放函数。&lt;/p&gt;&#xA;&lt;p&gt;raw 编码的 SDS 数据结构如下：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;struct sdshdr {&#xA; int len;    // buf 数组中已使用的字节数量&#xA; int free;   // buf 数组中未使用的字节数量&#xA; char buf[];&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;相比 C 字符串，SDS 具有以下优点：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;O(1) 复杂度获取字符串长度，C 字符串需要遍历获取，复杂度为 0(N)&lt;/li&gt;&#xA;&lt;li&gt;杜绝了因忘记重分配内存而导致的缓冲区溢出&lt;/li&gt;&#xA;&lt;li&gt;通过 &lt;strong&gt;空间预分配&lt;/strong&gt;（小于 1MB，分配 2 * len + 1，大于等于 1MB 分配 1MB 的未使用空间）&#xA;和 &lt;strong&gt;惰性空间释放&lt;/strong&gt;（free 记录未使用空间代替内存回收）减少了修改字符串时所需的 &lt;strong&gt;内存重分配&lt;/strong&gt; 次数&lt;/li&gt;&#xA;&lt;li&gt;使用 len 属性值而不是空字符判断结尾，可以保存任意格式的二进制数据&lt;/li&gt;&#xA;&lt;li&gt;兼容部分 C 字符串函数&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;列表&#34;&gt;&lt;span&gt;列表&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%88%97%e8%a1%a8&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;列表对象的编码可以是 ziplist 或者 linkedlist。&lt;code&gt;linkedlist&lt;/code&gt; 就是我们非常熟悉的双向链表，特征有：双端、无环、带表头和表尾指针、带长度计数器、多态。当列表保存的所有字符串元素长度都小于 64 字节，并且列表长度小于 512 时，列表使用 &lt;code&gt;ziplist&lt;/code&gt; 编码：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; rpush numbers 1 three 5&#xA;(integer) 3&#xA;127.0.0.1:6379&amp;gt; type numbers&#xA;list&#xA;127.0.0.1:6379&amp;gt; object encoding numbers&#xA;&amp;#34;ziplist&amp;#34;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;压缩列表是 Redis 为了 &lt;strong&gt;节约内存&lt;/strong&gt; 而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构，其结构为：&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;&amp;lt;zlbytes&amp;gt;&amp;lt;zltail&amp;gt;&amp;lt;zllen&amp;gt;&amp;lt;entry&amp;gt;&amp;lt;entry&amp;gt; ... &amp;lt;entry&amp;gt;&amp;lt;zlend&amp;gt;&lt;/code&gt;&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;属性&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;长度(字节)&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;用途&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;zlbytes&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;4&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;表示这个 ziplist 占用了多少字节，其中包括了 zlbytes 本身占用的 4 个字节：在对压缩列表进行内存重分配，或者计算 zlend 的位置时使用&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;zltail&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;4&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;表示到 ziplist 中最后一个元素的偏移量，有了这个值，pop 操作的时间复杂度就是 O(1) 了，即不需要遍历整个 ziplist&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;zllen&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;2&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;表示 ziplist 中有多少个 entry，即保存了多少个元素。由于这个字段占用 16 位，所以最大值是2^16-1，当这个值等于 UNIT16_MAX(65535) 时，节点的真实数量需要遍历整个压缩列表才能计算得出&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;entryX&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;不定&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;压缩列表包含的各个节点，节点的长度由保存的内存决定&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;zlend&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;1&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;特殊值 0xFF(255)，用于标记压缩列表的末端&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;每个压缩列表节点都是由 previous_entry_length、encoding、content 三个部分组成，&lt;code&gt;previous_entry_length&lt;/code&gt; 记录了前一个节点的长度，程序可以通过指针运算，根据当前节点的起始地址来 &lt;strong&gt;计算出前一个节点的起始地址&lt;/strong&gt;，从而实现从表尾向表头遍历。如果前一个节点的长度小于 254 字节，那么 previous_entry_length 会使用 1 字节记录它的长度，如果前一节点的长度大于等于 254 字节，那么 previous_entry_length 的长度为 5 字节，且属性的第一个字节会被设置为 0xFE(254)，之后四个字节则用于保存前一节点的长度。&lt;code&gt;encoding&lt;/code&gt; 属性记录了节点的 content 所存数据的类型及长度，节点值 &lt;code&gt;content&lt;/code&gt; 可以是一个字节数据或者整数。&lt;/p&gt;&#xA;&lt;p&gt;如果在一个压缩列表中，有多个连续的、长度介于 250 字节到 253 字节之前的节点 e1 至 eN，这时将一个长度大于等于 254 字节的新节点 new 设置为压缩列表的表头节点就会触发 &lt;strong&gt;连锁更新&lt;/strong&gt;。如下图所示，因为 e1 的 previous_entry_length 属性仅长 1 字节，它没办法保存新节点 new 的长度，所以程序将对压缩列表执行空间重分配操作，并将 e1 的 previous_entry_length属性从原来的 1 字节长扩展为 5 字节长。但这又导致了 e2 的 previous_entry_length 无法记录 e1 的长度，导致需要再次执行空间重分配操作&amp;hellip;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/redis-list-chain-update.jpg&#39; alt=&#34;/images/redis-list-chain-update.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;除了添加新节点可能会引发连锁更新之外，删除节点也可能会引发连锁更新。在最坏的情况下需要对压缩列表执行 N 次空间重分配操作，而每次空间重分配的最坏复杂度为 O(N)，所以连锁更新的最坏复杂度为 O(N^2)。尽管连锁更新的复杂度较高，但它真正造成性能问题的 &lt;strong&gt;几率是很低的&lt;/strong&gt;，压缩列表里要恰好有多个连续的、长度介于 250 字节至 253 字节之间的节点，才有可能引发连锁更新；即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响，所以 ziplistPush 等命令的平均复杂度仅为O(N)。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;哈希&#34;&gt;&lt;span&gt;哈希&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%93%88%e5%b8%8c&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;哈希对象的编码可以是 ziplist 或者 hashtable。当哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节，且保存的键值对数量小于 512 个，哈希对象就使用 &lt;code&gt;ziplist&lt;/code&gt; 编码，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的节点推入压缩列表表尾，再将保存了值的节点推入到压缩列表表尾，如下图所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/redis-hashmap-ziplist.jpg&#39; alt=&#34;/images/redis-hashmap-ziplist.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;当上述的两个条件不满足时，哈希对象就会使用 hashtable 编码，由于 Redis 所使用的 C 语言 &lt;strong&gt;没有内置&lt;/strong&gt; 字典这种数据结构，因此 Redis 构建了自己的字典实现，其结构如下图所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/redis-hashmap-dicht.jpg&#39; alt=&#34;/images/redis-hashmap-dicht.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;dicht&lt;/code&gt; 中的 table 指向一个数组，数组中的每个元素都指向一个 &lt;code&gt;dictEntry&lt;/code&gt; 结构，它保存着一个键值对。dictEntry 包含指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，以此来解决 &lt;strong&gt;键冲突&lt;/strong&gt; 的问题。&lt;code&gt;ht&lt;/code&gt; 是一个包含两个项的数组，数组中的每个项都是一个 dicht 哈希表，一般情况下，字典只使用 ht[0] 哈希表，ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。&lt;/p&gt;&#xA;&lt;p&gt;Redis 中字典的 rehash 动作并不是一次性、集中式地完成的，而是 &lt;strong&gt;分多次、渐进式&lt;/strong&gt; 地完成的。因为如果哈希表里保存的键值对数量较多，要一次性将这些键值对全部 rehash 到 ht[1] 的话，庞大的计算量可能会导致服务器在一段时间内 &lt;strong&gt;停止服务&lt;/strong&gt;。渐进式 rehash 时会在字典内维护一个索引计数器变量 rehashidx，在 rehash 进行期间，程序会将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1]，当本次 rehash 完成后，程序将 rehashidx 属性的值加一。&lt;/p&gt;&#xA;&lt;p&gt;在进行渐进式 rehash 的过程中，字典会同时使用 ht[0] 和 ht[1] 两个哈希表，删除、查找、更新等操作会在两个哈希表上进行。例如要在字典里面查找一个键的话，程序会先在 ht[0] 里面进行查找，如果没找到的话，就会继续到 ht[1] 里面进行查找，诸如此类。新添加到字典的键值对一律会被保存到 ht[1] 里面，而 ht[0] 则不再进行任何添加操作，这一措施保证了 ht[0] 包含的键值对数量会 &lt;strong&gt;只减不增&lt;/strong&gt;，并随着 rehash 操作的执行而最终变成空表。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;集合&#34;&gt;&lt;span&gt;集合&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e9%9b%86%e5%90%88&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;集合对象的编码可以是 intset 或者 hashtable，当集合对象保存的元素都是整数值且元素数量不超过 512 个时将会使用整数集合编码，不满足这两个条件就使用 hashtable 编码，字典的每个键都是一个集合元素，而字典的值则全部被设置为 NULL。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;Contents&lt;/code&gt; 数组的每一项都是整数集合的一个元素，各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。intset 的结构如下图所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/redis-intset.jpg&#39; alt=&#34;/images/redis-intset.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;其中的 encoding 决定了集合中整数的类型，它可以是 INTSET_ENC_INT8、INTSET_ENC_INT16、INTSET_ENC_INT32、INTSET_ENC_INT64，每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比集合中的现有类型长时，整数集合需要先进行 &lt;strong&gt;升级&lt;/strong&gt;。升级时会先扩展整数集合底层数组的空间大小，然后将现有元素都转换成与新元素相同的类型，最后将新元素添加到底层数组里面。&lt;/p&gt;&#xA;&lt;p&gt;因为 C 语言是静态类型语言，为了避免 &lt;strong&gt;类型错误&lt;/strong&gt;，我们通常不会将两种不同类型的值放在同一个数据结构里面。整数集合通过自动升级底层数据来适应新元素，所以我们可以随意地将 int16_t、int32_t 或者 int64_t 类型的整数添加到集合中，而不必担心出现类型错误。整数集合的实现可以让集合可以尽量节省内存，又可以确保升级操作只会在有需要的时候进行。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;有序集合&#34;&gt;&lt;span&gt;有序集合&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%9c%89%e5%ba%8f%e9%9b%86%e5%90%88&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;有序集合 Sorted Set 的编码可以是 zipllist 或 skiplist，当有序集合保存的所有元素成员的长度都小于 64 字节且元素数量小于 128 个时会使用 ziplist 编码，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个元素保存元素的分值，如下图所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/redis-sortedSet-ziplist.jpg&#39; alt=&#34;/images/redis-sortedSet-ziplist.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;跳跃表 skiplist 是一种有序的数据结构，它通过在每个节点中维持 &lt;strong&gt;多个指向其他节点的指针&lt;/strong&gt;，从而达到快速访问节点的目的。其结构如下图所示，header 和 tail 为支持快速访问的表头节点和表尾节点，level 用于获取跳跃表中层高最大的那个节点的数量（表头节点的层高并不计算在内）。表中的节点按各自所保存的分值从小到大排列，节点的 level 数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/redis-skiplist-hashtable.jpg&#39; alt=&#34;/images/redis-skiplist-hashtable.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;除此之外，有序集合还同时使用字典来保存从成员到分值的映射，这样就可以以 O(1) 复杂度查找给定成员的分值。值得一提的是，虽然 zset 结构同时使用跳跃表和字典来保存有序集合元素，但这两种数据结构都会通过指针来 &lt;strong&gt;共享&lt;/strong&gt; 相同元素的成员和分值，不会产生任何重复成员或者分值，也不会因此而 &lt;strong&gt;浪费额外的内存&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h1 class=&#34;heading-element&#34; id=&#34;单机数据库的实现&#34;&gt;&lt;span&gt;单机数据库的实现&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%8d%95%e6%9c%ba%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e5%ae%9e%e7%8e%b0&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&lt;h3 class=&#34;heading-element&#34; id=&#34;数据库&#34;&gt;&lt;span&gt;数据库&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%95%b0%e6%8d%ae%e5%ba%93&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;Redis 使用字典类型的 &lt;strong&gt;键空间 dict&lt;/strong&gt;  保存数据库中的键和值，其结构如下图所示。每次当我们在 Redis 数据库中新创建一个键值对时，我们至少会创建两个对象，一个字符串键对象，一个值对象，它可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的一种。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/redis-dict.jpg&#39; alt=&#34;/images/redis-dict.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;因为 Redis 的键空间是一个字典，所以所有针对数据库的操作，比如添加或删除一个键值对，又或者在数据库中获取某个键值对等，实际上都是通过对键空间进行操作来实现的。&lt;/p&gt;&#xA;&lt;p&gt;通过 &lt;code&gt;EXPIRE&lt;/code&gt; 或者 &lt;code&gt;PEXPIRE&lt;/code&gt; 命令可以以秒或者毫秒精度为某个键设置生存时间，或者通过 &lt;code&gt;EXPIREAT&lt;/code&gt; 或 &lt;code&gt;PEXPIREAT&lt;/code&gt; 命令给某个键设置过期时间（UNIX 时间戳）。Redis 通过 &lt;strong&gt;expires 字典&lt;/strong&gt; 保存数据库中所有键的过期时间，它的键指向间空间中的某个键对象（对象共享），值为一个毫秒精度的 long long 类型的 UNIX 时间戳。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/redis-expire.jpg&#39; alt=&#34;/images/redis-expire.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;通过过期字典，程序可以检查某个键是否存在于过期字典，如果存在，可以检查当前 UNIX 时间错是否大于键的过期时间，如果是的话，那么键已经过期；否则键未过期。如果一个键过期了，那么它什么时候会被删除呢？&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;定时删除：设置键的过期时间的同时，创建一个定时器，在键的过期时间来临时立即执行对键的删除操作。定时删除策略是 &lt;strong&gt;对内存最友好&lt;/strong&gt; 的，可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存，但它 &lt;strong&gt;对 CPU 时间是最不友好&lt;/strong&gt; 的，在 CPU 时间非常紧张的情况下，这无疑会对服务器的响应时间和吞吐量造成影响。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;惰性删除：每次从键空间获取键时，都检查键是否过期，如果过期就删除。这样对 CPU 时间来说是最友好的，因为删除过期键的操作只会在非做不可的情况下进行，且只删除当前处理的键；但它 &lt;strong&gt;对内存是最不友好的&lt;/strong&gt;，有些过期键如果没被访问到的话可能永远也不会被删除（内存泄漏），这对于运行状态非常依赖于内存的 Redis 服务器来说，肯定不是一个好消息。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。定期删除策略是前两种策略的一种整合和折中，每隔一段时间执行一次删除过期键操作，并通过限制操作执行的时长和频率来减少删除操作对 CPU 时间的影响，此外，定期删除有效地减少了因为过期键而带来的内存浪费。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Redis 服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好地在合理使用 CPU 时间和避免浪费内存空间之间取得 &lt;strong&gt;平衡&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;rdb-持久化&#34;&gt;&lt;span&gt;RDB 持久化&lt;/span&gt;&#xA;  &lt;a href=&#34;#rdb-%e6%8c%81%e4%b9%85%e5%8c%96&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;Redis 提供了 RDB 持久化功能将内存中的数据库状态保存到磁盘里面，来避免进程退出时数据库状态的意外丢失。RDB 可以手动执行，也可以根据服务器配置定期执行，它会生成一个经过压缩的二进制文件，在 Redis 启动时可以用 RDB 文件来还原数据库状态。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;SAVE&lt;/code&gt; 命令会 &lt;strong&gt;阻塞&lt;/strong&gt; 服务器进程，直到 RDB 文件创建完毕，在这期间服务器不能处理任何命令请求。&lt;code&gt;BGSAVE&lt;/code&gt; 则会在派生出的子进程中创建 RDB 文件，服务器进程（父进程）继续处理命令请求。&lt;/p&gt;&#xA;&lt;p&gt;save 选项的默认条件为：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;save 900 1&lt;/p&gt;&#xA;&lt;p&gt;save 300 10&lt;/p&gt;&#xA;&lt;p&gt;save 60 10000&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;那么只要满足以下三个条件中的任意一个，BGSAVE 命令就会被执行：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;服务器在 900 秒之内，对数据库进行了至少 1 次修改&lt;/li&gt;&#xA;&lt;li&gt;服务器在 300 秒之内，对数据库进行了至少 10 次修改&lt;/li&gt;&#xA;&lt;li&gt;服务器在 60 秒之内，对数据库进行了至少 10000 次修改&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Redis 通过其周期性操作函数 &lt;code&gt;serverCron&lt;/code&gt; 默认每隔 100 毫秒执行一次检查，检查 dirty 计数器并计算距离上次执行保存操作有多少秒，当满足保存条件中的任意一条时便执行 BGSAVE 命令。&lt;/p&gt;&#xA;&lt;p&gt;在创建新的 RDB 文件时，程序会对数据库中的键进行检查，&lt;strong&gt;已过期的键&lt;/strong&gt; 不会被保存到新创建的 RDB 文件中。在 Redis 启动载入 RDB 文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入 RDB 文件的服务器不会造成影响。&lt;/p&gt;&#xA;&lt;p&gt;Redis 在启动时会自动检测，如果存在 RDB 文件就会自动载入。值得一提的是，因为 AOF 文件的 &lt;strong&gt;更新频率&lt;/strong&gt; 通常比 RDB 文件的要高，所以如果服务器开启了 AOF 持久化功能，那 Redis 会优先使用 AOF 文件来还原数据库状态。只有在 AOF 持久化功能处于关闭状态时，服务器才会使用 RDB 文件来还原数据库状态。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;aof-持久化&#34;&gt;&lt;span&gt;AOF 持久化&lt;/span&gt;&#xA;  &lt;a href=&#34;#aof-%e6%8c%81%e4%b9%85%e5%8c%96&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;除了 RDB 之外，Redis 还提供了 AOF &lt;code&gt;Append Only File&lt;/code&gt; 持久化功能。AOF 通过保存 Redis 服务器所执行的 &lt;strong&gt;写命令&lt;/strong&gt; 来记录数据库状态的，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的 aof_buf 缓冲区的末尾，由服务器配置的 &lt;code&gt;appendfsync&lt;/code&gt;（默认为 everysec）来决定不同的持久化行为：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;appendfsync&lt;/th&gt;&#xA;          &lt;th&gt;持久化行为&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;always&lt;/td&gt;&#xA;          &lt;td&gt;将 aof_buf 缓冲区中的所有内容写入并同步到 AOF 文件中&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;everysec&lt;/td&gt;&#xA;          &lt;td&gt;将 aof_buf 缓冲区中的所有内容写入到 AOF 文件，如果距上次同步超过一秒，就进行同步&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;no&lt;/td&gt;&#xA;          &lt;td&gt;将 aof_buf 缓冲区中的所有内容写入到 AOF 文件，不进行同步，何时同步由操作系统来决定&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;当 appendfsync 的值为 always 时，服务器在每个事件循环都要将 aof_buf 缓冲区中的所有内容写入到 AOF 文件，并且同步 AOF 文件，效率最慢但也 &lt;strong&gt;最安全&lt;/strong&gt;，即使出现故障停机，AOF 持久化也只会丢失一个事件循环中所产生的命令数据。Redis 在载入 AOF 文件进行数据还原时会创建一个不带网络连接的伪客户端，逐条读取其中的写命令并执行。&lt;/p&gt;&#xA;&lt;p&gt;随着服务器的运行，AOF 文件中的内容会越来越多，文件的体积也会越来越大，如果不加以控制的话，体积过大的 AOF文件很可能对 Redis 服务器、甚至整个宿主计算器造成影响，并且 AOF 文件的体积越大，进行数据还原所需的时间就越多。&lt;/p&gt;&#xA;&lt;p&gt;为此，Redis 提供了 &lt;strong&gt;AOF 文件重写&lt;/strong&gt; 功能，通过创建一个不包含任何浪费空间的冗余命令的新的 AOF 文件来替换原有的 AOF 文件。AOF 文件重写并不需要对现有的 AOF 文件进行任何读取、分析或者写入操作，而是通过读取服务器当前的数据库状态来实现的。因为新的 AOF 文件只包含还原当前数据库状态所必须的命令，所以新的 AOF 文件不会浪费任何硬盘空间。&lt;/p&gt;&#xA;&lt;p&gt;Redis 将 AOF 重写放到子进程中执行，这样服务器进程（父进程）可以在重写期间继续处理命令请求。在此期间客户端对数据库的修改会被同时记录到 &lt;strong&gt;AOF 重写缓冲区&lt;/strong&gt; 中，当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，最后使用原子替换完成 AOF 重写操作。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/redis-aof-rewrite.jpg&#39; alt=&#34;/images/redis-aof-rewrite.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;对于 &lt;strong&gt;过期键&lt;/strong&gt;，当过期键被惰性删除或者定期删除之后，程序会向 AOF 文件追加一条 DEL 命令，来显式地记录该键已被删除。在 AOF 重写的过程中，已过期的键不会被保存到重写后的 AOF 文件中，因此数据库中包含过期键不会对 AOF 产生影响。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;事件&#34;&gt;&lt;span&gt;事件&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e4%ba%8b%e4%bb%b6&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;Redis 服务器是一个 &lt;strong&gt;事件驱动程序&lt;/strong&gt;，服务器通过处理文件事件（监听客户端）和时间事件（serverCron 函数）来实现功能。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;文件事件&lt;/code&gt; 使用 &lt;strong&gt;I/O 多路复用&lt;/strong&gt; 来同时监听多个套接字，并且根据套接字目前执行的任务来为套接字关联不同的事件处理器。文件事件处理器以 &lt;strong&gt;单线程&lt;/strong&gt; 方式运行，但通过使用 I/O 多路复用程序来监听多个套接字&lt;a href=&#34;https://www.zhihu.com/question/422815669/answer/1522156745&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;（参考：关于 Redis 单线程的解释）&lt;/a&gt;，这样既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他以单线程方式运行的模块进行对接，以保持 Redis 内存单线程设计的简单性。&lt;/p&gt;&#xA;&lt;p&gt;文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个文件事件，所以多个文件事件有可能会 &lt;strong&gt;并发地出现&lt;/strong&gt;。但 I/O 多路复用程序总是将所有产生事件的套接字都放到一个队列里面，然后以 &lt;strong&gt;有序、同步&lt;/strong&gt;、每次一个套接字的方式向文件事件分派器传送套接字。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/redis-file-event.jpg&#39; alt=&#34;/images/redis-file-event.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;时间事件&lt;/code&gt; 分为只执行一次的定时事件和周期性事件。服务器将所有的时间事件都放在一个 &lt;strong&gt;无序链表&lt;/strong&gt; 中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达（时间事件的 when 属性记录的 UNIX 时间戳等于或小于当前时间的 UNIX 时间戳）的时间事件，并调用相应的事件处理器。正常模式下的 Redis 服务器只使用 serverCron 一个时间事件，所以使用无序链表来保存并不影响事件执行的性能。&lt;/p&gt;&#xA;&lt;p&gt;服务器默认规定 &lt;code&gt;serverCron&lt;/code&gt; 每秒运行 10 次以实现对自身资源和状态的定期检查和调整，确保服务可以长期、稳定地运行，它的主要工作包括：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等&lt;/li&gt;&#xA;&lt;li&gt;清理服务器中的过期键值对&lt;/li&gt;&#xA;&lt;li&gt;关闭和清理连接失效的客户端&lt;/li&gt;&#xA;&lt;li&gt;尝试进行 AOF 或 RDB 持久化操作&lt;/li&gt;&#xA;&lt;li&gt;如果服务器是主服务器，那么对从服务器进行定期同步&lt;/li&gt;&#xA;&lt;li&gt;如果处于集群模式，对集群进行定期同步和连接测试&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;因为服务器中同时存在文件事件和时间事件两种事件类型，所以服务器必须对这两种事件进行 &lt;strong&gt;调度&lt;/strong&gt;，决定何时应该处理文件事件，何时又应该处理时间事件，以及花多少时间来处理它们等等，其伪代码如下：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;def aeProcessEvents():&#xA; // 获取到达时间离当前时间最接近的时间事件&#xA; time_event = aeSearchNearestTimer()&#xA; &#xA; // 计算最接近的时间事件距离到达还有多少毫秒&#xA; remaind_ms = time_event.when - unix_ts_now()&#xA; &#xA; // 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设定为 0&#xA; if remaind_ms &amp;lt; 0:&#xA;  remaind_ms = 0&#xA;  &#xA; // 根据 remaind_ms 的值，创建 timeval 结构&#xA; timeval = create_timeval_with_ms(remaind_ms)&#xA; &#xA; // 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 结构决定&#xA; // 如果 remaind_ms 的值为 0，那么 aeApiPoll 调用之后马上返回，不阻塞&#xA; aeApiPoll(timeval)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;aeApiPoll&lt;/code&gt; 函数的最大阻塞时间由距当前时间最接近的时间事件决定，这个方法既可以 &lt;strong&gt;避免&lt;/strong&gt; 服务器对事件事件进行频繁的轮询（忙等待），也可以确保 aeApiPoll 函数不会阻塞过长时间。函数会处理随机出现的文件事件，当最终来到时间事件设置的到达时间时，服务器就可以开始处理到达的时间事件了。&lt;/p&gt;&#xA;&lt;p&gt;Redis 服务器的主函数会将 &lt;code&gt;asProcessEvents&lt;/code&gt; 置于一个循环里面，一直处理事件，直到服务器关闭为止。Redis 对文件事件和时间事件的处理都是 &lt;strong&gt;同步、有序、原子&lt;/strong&gt; 地执行的，服务器不会中途中断事件处理，也不会对事件进行抢占。因此，不管是文件事件的处理器，还是时间事件的处理器，它们都会 &lt;strong&gt;尽可能地减少程序的阻塞时间&lt;/strong&gt;，并在有需要时主动让出执行权，从而降低事件饥饿的可能性。比如说，在命令回复处理器将一个命令回复写入到客户端套接字时，如果写入字节数超过了一个预设常量的话，命令回复处理器就会主动用 break 跳出写入循环，将余下的数据留到下次再写；另外，时间事件也会将非常耗时的持久化操作放到子线程中执行。&lt;/p&gt;&#xA;&lt;h1 class=&#34;heading-element&#34; id=&#34;多机数据库的实现&#34;&gt;&lt;span&gt;多机数据库的实现&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%a4%9a%e6%9c%ba%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e5%ae%9e%e7%8e%b0&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&lt;h3 class=&#34;heading-element&#34; id=&#34;复制&#34;&gt;&lt;span&gt;复制&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%a4%8d%e5%88%b6&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;Redis 的复制功能分为同步和命令传播两个操作。当客户端向从服务器发送 &lt;code&gt;SLAVEOF&lt;/code&gt; 命令，要求从服务器复制主服务器时，从服务器会首先向主服务器发送 &lt;code&gt;SYNC&lt;/code&gt; 命令执行同步操作，收到 SYNC 命令的主服务器执行 BGSAVE 命令，在后台生成一个 RDB文件，并使用一个 &lt;strong&gt;缓冲区&lt;/strong&gt; 记录从现在开始执行的所有写命令。主服务器发送生成的 RDB 文件，在从服务器载入后将记录在缓冲区中的所有写命令发送给从服务器，从服务器通过执行这些写命令，将自己的数据库状态更新至主服务器数据库当前的状态。&lt;/p&gt;&#xA;&lt;p&gt;之后每当主服务器执行客户端发送的写命令时，主服务器的数据库就有可能被修改，并导致主从服务器状态不再一致。为了让主从服务器再次回到一致状态，主服务器需要对从服务器执行 &lt;strong&gt;命令传播&lt;/strong&gt; 操作：主服务器将自己执行的写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器再次回到一致状态。&lt;/p&gt;&#xA;&lt;p&gt;Redis 2.8 之前，从服务器对主服务器的复制无论是初次复制还是断线后重复制都是发送 &lt;code&gt;SYNC&lt;/code&gt; 命令，主服务器将通过BGSAVE 命令生成 RDB 文件并发送给从服务器，这个操作会 &lt;strong&gt;耗费&lt;/strong&gt; 服务器大量的 CPU、内存、磁盘 I/O 资源以及网络资源，无疑是非常 &lt;strong&gt;低效&lt;/strong&gt; 的，因为断线重连后生成 RDB 文件包含了大多数从服务器已有的数据。&lt;/p&gt;&#xA;&lt;p&gt;为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis 从 2.8 版本开始使用 &lt;code&gt;PSYNC&lt;/code&gt; 命令代替 SYNC 命令来执行复制时的同步操作。PSYNC 会在初次复制的时候使用完整重同步，而在断线后重复制时使用 &lt;strong&gt;部分重同步&lt;/strong&gt;（如果条件允许）。相比 SYNC 命令在断线重复制时需要生成、传送和载入整个 RDB 文件，而部分重同步只需要将从服务器缺少的写命令发送给从服务器执行就可以了，这将使用更少的资源，同步也会更快。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;部分重同步的实现&#34;&gt;&lt;span&gt;部分重同步的实现&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e9%83%a8%e5%88%86%e9%87%8d%e5%90%8c%e6%ad%a5%e7%9a%84%e5%ae%9e%e7%8e%b0&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;部分重同步功能主要由以下三个部分构成，复制偏移量、主服务器的复制积压缓冲区、服务器的运行 ID。PSYNC 命令执行完整重同步和部分重同步的流程如下图所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/redis-psync.jpg&#39; alt=&#34;/images/redis-psync.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;执行复制的双方——主服务器和从服务器会分别维护一个 &lt;strong&gt;复制偏移量&lt;/strong&gt;，主服务器每次向从服务器传播 N 个字节的数据时，就将自己的复制偏移量加上 N，从服务器每次收到主服务器传播来的 N 个字节的数据时，就将自己的复制偏移量的值加上 N。通过 &lt;strong&gt;对比&lt;/strong&gt; 主从服务器的复制偏移量就很容易地知道主从服务器是否处于一致状态。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;复制积压缓冲区&lt;/strong&gt; 是由主服务器维护的一个固定长度、先进先出队列，默认大小为 1 MB。当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面，缓冲区会为队列中的每个字节记录相应的复制偏移量。当从服务器重新连上主服务器时，从服务器会通过 PYSNC 命令将自己的复制偏移量 &lt;code&gt;offset&lt;/code&gt; 发送给主服务器，如果 offset 偏移量之后的数据 &lt;strong&gt;仍在&lt;/strong&gt; 复制积压缓冲区里面，那么主服务器就执行部分重同步操作。&lt;/p&gt;&#xA;&lt;p&gt;每个 Redis 服务器都有一个自己的 &lt;strong&gt;运行 ID&lt;/strong&gt;，运行 ID 是服务器启动时自动生成的 40 位随机的十六进制字符，当从服务器对主服务器进行初次复制时，主服务器会将自己的运行 ID 传送给从服务器，从服务器会将这个运行 ID 保存起来。当从服务器断线重连后，通过将从服务器保存的运行 ID 与当前连接的主服务器的运行 ID &lt;strong&gt;对比&lt;/strong&gt; 来判断，断线之前复制的主服务器是否是当前连接的这个主服务器，如果是，主服务器可以尝试执行部分重同步操作，若不是则执行完成重同步操作。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;心跳检测&#34;&gt;&lt;span&gt;心跳检测&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%bf%83%e8%b7%b3%e6%a3%80%e6%b5%8b&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;在命令传播阶段，从服务器默认会以 &lt;strong&gt;每秒一次&lt;/strong&gt; 的频率，向主服务器发送命令 &lt;code&gt;REPLCONF ACK &amp;lt;replication_offset&amp;gt;&lt;/code&gt;这个命令对于主从服务器有三个作用：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;检测主从服务器的网络连接状态：如果主服务器超过一秒钟没有收到从服务器发来的 REPLCONF ACK 命令，那么就知道主从服务器之间的连接出现问题了。&lt;/li&gt;&#xA;&lt;li&gt;辅助实现 min-slaves 选项：可以防止主服务器在不安全的情况下执行写命令，例如下主服务器配置 &lt;code&gt;min-slaves-to-write 3&lt;/code&gt; &lt;code&gt;min-slaves-max-lag 10&lt;/code&gt; 的情况下，如果从服务器数量少于 3 个，或者从服务器的延迟 lag 都大于等于 10 秒，主服务器将拒绝执行写命令。&lt;/li&gt;&#xA;&lt;li&gt;检测命令丢失：如果主服务器传播给从服务器的写命令因为网络故障在半路丢失，主服务器可以通过 REPLCONF ACK 命令中的偏移量 &lt;strong&gt;发觉从服务器缺少部分数据&lt;/strong&gt;，并将这些数据重新发送给从服务器（Redis 2.8 之前无法通过这一点保证主从服务器数据一致性）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;sentinel&#34;&gt;&lt;span&gt;Sentinel&lt;/span&gt;&#xA;  &lt;a href=&#34;#sentinel&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;Sentinel（哨兵）是 Redis 高可用性的解决方案：由一个或多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器 &lt;strong&gt;升级&lt;/strong&gt; 为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;sentinel-服务器&#34;&gt;&lt;span&gt;Sentinel 服务器&lt;/span&gt;&#xA;  &lt;a href=&#34;#sentinel-%e6%9c%8d%e5%8a%a1%e5%99%a8&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;Sentinel 本质上只是一个运行在特殊模式下的 Redis 服务器，因为 Sentinel 执行的工作和普通 Redis 服务器执行的工作不同，所以 Sentinel 的初始化过程和普通 Redis 不尽相同。比如 Sentinel 在初始化时不会载入 RDB 或者 AOF 文件，启动 Sentinel 时会将一部分普通 Redis 服务器使用的代码替换成 Sentinel 的 &lt;strong&gt;专用代码&lt;/strong&gt;，并载入 Sentinel &lt;strong&gt;专用的命令表&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;所有被 Sentinel 监视的主服务器的相关信息会被保存到 &lt;code&gt;sentinelState&lt;/code&gt; 中的 masters 字典中，Sentinel 启动时会载入 Sentinel 的配置文件来初始化这个 masters 字典。随后 Sentinel 会创建两个连向主服务器的异步网络连接：一个是命令连接，专用用于向主服务器发送命令，并接收命令回复；另一个是订阅连接，专门用于订阅主服务器的 &lt;code&gt;\_sentinel\_:hello&lt;/code&gt; 频道。如果在信息发送时，想要接收信息的客户端不在线或者断线，那么这个客户端就会 &lt;strong&gt;丢失&lt;/strong&gt; 这条信息。为了不丢失 _sentinel_:hello 频道的任何信息，Sentinel 必须专门用一个 &lt;strong&gt;订阅连接&lt;/strong&gt; 来接收该频道的信息。&lt;/p&gt;&#xA;&lt;p&gt;Sentinel 会默认 &lt;strong&gt;每十秒一次&lt;/strong&gt; 的频率通过命令连接向被监视的主服务器发送 INFO 命令，通过分析回复来获取主服务器的当前信息，其得到的回复类似以下内容：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Server&#xA;...&#xA;run_id:7611c59dc3a29aa6fa0609f841bb6a1019008a9c&#xA;...&#xA;# Replication&#xA;role:master&#xA;...&#xA;slave0:ip=127.0.0.1,port=11111,state=online,offset=43,lag=0&#xA;slave1:ip=127.0.0.1,port=22222,state=online,offset=43,lag=0&#xA;slave2:ip=127.0.0.1,port=33333,state=online,offset=43,lag=0&#xA;...&#xA;# Other sections&#xA;...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;除了得到关于主服务器本身的信息（会根据回复对 masters 字典进行更新）外，还得到了主服务器属下所有从服务器的信息，因此 Sentinel 无须用户提供从服务器的地址信息（并以此更新 masters 字典中的  slaves 字典），就可以 &lt;strong&gt;自动发现从服务器&lt;/strong&gt;。同样地，Sentinel 会创建连接到从服务器的命令连接和订阅连接，并以默认 &lt;strong&gt;每十秒一次&lt;/strong&gt; 的频率向从服务器发送 INFO 命令，根据回复内容更新从服务器的实例结构。&lt;/p&gt;&#xA;&lt;p&gt;Sentinel 会以默认 &lt;strong&gt;每两秒一次&lt;/strong&gt; 的频率，通过命令连接向所有被监视的主服务器和从服务器的 _sentinel_:hello 频道发送 &lt;code&gt;PUBLISH __sentinel__:hello &amp;quot;&amp;lt;s_ip&amp;gt;,&amp;lt;s_port&amp;gt;,&amp;lt;s_runid&amp;gt;,&amp;lt;s_epoch&amp;gt;,&amp;lt;m_name&amp;gt;,&amp;lt;m_ip&amp;gt;,&amp;lt;m_port&amp;gt;,&amp;lt;m_epoch&amp;gt;&amp;quot;&lt;/code&gt; 其中以 s_ 开头的参数记录的是 Sentinel 本身的信息，以 m_ 开头的则是主服务器的信息，如果发送对象为从服务器，那么这些参数记录的就是从服务器正在复制的主服务器的信息。&lt;/p&gt;&#xA;&lt;p&gt;当 Sentinel 与一个主/从服务器建立起订阅连接后，会发送 &lt;code&gt;SUBSCRIBE __sentinel__:hello&lt;/code&gt; 订阅频道。也就是说，Sentinel 既通过命令连接向每个连接的服务器的 __sentinel__:hello 频道发送信息，又通过订阅连接从该频道接收信息。对于监视同一个服务器的多个 Sentinel 来说，一个 Sentinel 发送的信息会被其他 Sentinel 接收到，这些信息会被用于 &lt;strong&gt;更新其他 Sentinel 对发送信息 Sentinel 的认知&lt;/strong&gt;，也会被用于更新其他 Sentinel 对被监视服务器的认知。因为一个 Sentinel 可以通过分析接收到的频道信息来获知其他 Sentinel 的存在，并通过发送频道信息让其他 Sentinel 知道自己的存在，所以用户在使用 Sentinel 的时候并不需要提供各个 Sentinel 的地址信息，监视同一个主服务器的多个 Sentinel 可以 &lt;strong&gt;自动发现&lt;/strong&gt; 对方。&lt;/p&gt;&#xA;&lt;p&gt;当 Sentinel 通过频道信息发现一个新的 Sentinel 时，它会创建一个连向新 Sentinel 的命令连接，相连的 Sentinel 可以通过命令连接向其他 Sentinel 发送命令请求来进行 &lt;strong&gt;信息交换&lt;/strong&gt;（在对服务器的下线检测时进行彼此通信）。Sentinel 之间 &lt;strong&gt;不会&lt;/strong&gt; 创建订阅连接，因为 Sentinel 通过接收主/从服务器的频道信息来发现未知的新 Sentinel，而相互已知的 Sentinel 只要使用命令连接来进行通信就足够了。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;检测下线与故障转移&#34;&gt;&lt;span&gt;检测下线与故障转移&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%a3%80%e6%b5%8b%e4%b8%8b%e7%ba%bf%e4%b8%8e%e6%95%85%e9%9a%9c%e8%bd%ac%e7%a7%bb&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;Sentinel 会在默认情况下以 &lt;strong&gt;每秒一次&lt;/strong&gt; 的频率向所有与它创建了命令连接的实例（包括主服务器、从服务器、其他 Sentinel）发送 PING 命令，如果一个实例在 &lt;code&gt;down-after-milliseconds&lt;/code&gt; 毫秒内，连续向 Sentinel 返回无效回复，那么 Sentinel 就会修改这个实例状态为 &lt;strong&gt;主观下线状态&lt;/strong&gt;。需要注意的是，对于监视同一主服务器的多个 Sentinel 来说，这些 Sentinel 所设置的 &lt;code&gt;down-after-milliseconds&lt;/code&gt; 值可能不同，所以当一个 Sentinel 将主服务器判断为主观下线时，其他 Sentinel 可能仍然会认为主服务器处于在线状态。&lt;/p&gt;&#xA;&lt;p&gt;当 Sentinel 将一个主服务器判断为主观下线后，为了确认这个主服务器是否真的下线了，它会向同样监视这一主服务器的其他 Sentinel发送 &lt;code&gt;SENTINEL is-master-down-by-addr &amp;lt;ip&amp;gt;&amp;lt;port&amp;gt;&amp;lt;current_epoch&amp;gt;&amp;lt;runid&amp;gt;&lt;/code&gt; 进行询问，看它们是否也认为主服务器已经进入了下线状态（主观/客观）。当目标 Sentinel 接收到源 Sentinel 发来的 SENTINEL is-master-down-by-addr 命令时，目标 Sentinel 会检查请求中的主服务器是否下线，然后向源 Sentinel 返回三个参数：&amp;lt;down_state&amp;gt;、&amp;lt;leader_runid&amp;gt;、&amp;lt;leader_epoch&amp;gt;。当 Sentinel 从其他 Sentinel 那里接收到足够数量的已下线判断之后（不同 Sentinel 设置的客观下线状态的判断条件可不同），Sentinel 就会将服务器判定为 &lt;strong&gt;客观下线&lt;/strong&gt;，并对主服务器执行故障转移操作。&lt;/p&gt;&#xA;&lt;p&gt;每个发现主服务器进入客观下线的 Sentinel 都会要求其他 Sentinel 将自己设置为局部 &lt;code&gt;领头 Sentinel&lt;/code&gt;，当源 Sentinel 向目标 Sentinel 发送 SENTINEL is-master-down-by-addr 命令，命令中的 runid 不是 * 符号而是源 Sentinel 的运行 ID 时，这表示源 Sentinel 要求目标 Sentinel 将前者设置为后者的局部领头 Sentinel。根据 &lt;strong&gt;先到先得&lt;/strong&gt; 的原则，在一个配置纪元里面，目标 Sentinel 会设置最先发送命令的 Sentinel 为局部领头 Sentinel，拒绝之后接收到的请求。如果某个 Sentinel 被 &lt;strong&gt;半数以上&lt;/strong&gt; 的 Sentinel 设置成了局部领头 Sentinel，那么这个 Sentinel 成为领头 Sentinel，如果在给定时限内，没有一个 Sentinel 被选举为领头 Sentinel，那么各个 Sentinel 将在一段时间之后再次进行选举，直到选出领头 Sentinel 为止。&lt;/p&gt;&#xA;&lt;p&gt;领头 Sentinel 将对已下线的主服务器执行故障转移操作，先从已下线主服务器属下的所有从服务器里面，&lt;strong&gt;选出新的主服务器&lt;/strong&gt;（在没有过早地与主服务器断开连接的从服务器中，选出优先级最高、偏移量最大、运行ID最小的从服务器），让已下线主服务器属下的所有从服务器改为复制新的主服务器，最后将已下线主服务器设置为新主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;集群&#34;&gt;&lt;span&gt;集群&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e9%9b%86%e7%be%a4&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;h4 class=&#34;heading-element&#34; id=&#34;槽指派&#34;&gt;&lt;span&gt;槽指派&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%a7%bd%e6%8c%87%e6%b4%be&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;一个 Redis 集群通常由多个节点组成，在刚开始的时候，每个节点都是相互独立的，处于一个只包含自己的集群当中，一个真正可工作的集群是通过 &lt;code&gt;CLUSTER MEET &amp;lt;ip&amp;gt;&amp;lt;port&amp;gt;&lt;/code&gt; 将各个独立的节点连接起来，构成一个包含多个节点的集群。Redis 服务器会根据 &lt;code&gt;cluster-enabled&lt;/code&gt; 配置选择作为节点运行在集群模式下，它会继续使用所有在单机模式中使用的服务器组件，比如文件/时间事件处理器、serverCrom 函数、RDB、AOF、复制功能等。&lt;/p&gt;&#xA;&lt;p&gt;节点使用 &lt;code&gt;clusterState&lt;/code&gt; 来保存只有在集群模式下才会用到的数据，集群中的每个节点都将使用一个 &lt;code&gt;clusterNode&lt;/code&gt; 记录其状态，具体存储结构如下图所示，结构的 nodes 字典记录了集群目前包含的三个节点，这三个节点分别由三个 clusterNode 结构表示，其中 myself 指针指向代表节点 7000 的 clusterNode 结构，而字典中的另外两个指针分别指向代表节点 7001 和 7002 的 clusterNode 结构，这两个节点是已知的在集群中的其他节点。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/redis-clusterState.jpg&#39; alt=&#34;/images/redis-clusterState.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Redis 集群通过分片的方式来保存数据库中的键值对，集群的整个数据库被分为 16384 个槽 slot，数据库的每个键都属于这 16384 个槽的其中一个。可以使用 &lt;code&gt;CLUSTER ADDSLOTS 0 1 2 3 4 ... 5000&lt;/code&gt; 将槽指派给某个节点负责，当数据库中的 16384 个槽都有节点在处理时，集群处于上线状态，返回则处于下线 fail 状态。&lt;/p&gt;&#xA;&lt;p&gt;clusterNode 结构中的 slots 属性和 numslot 属性记录了节点负责处理哪些槽：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;struct clusterNode {&#xA;&#x9;// ...&#xA;&#x9;unsigned char slots[15384/8];&#xA;&#x9;int numslot;&#xA;&#x9;// ...&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;slots 属性是一个二进制数组，长度为 16384/8 = 2048 个字节，共包含 16384 个二进制位。如果 slots 数组在索引 i 上的二进制位的值为 1，那么表示节点负责处理槽 i，否则就是不负责处理。因为取出和设置 slots 数组中任意一个二进制位的值复杂度仅为 0(1)，所以对于一个给定节点的 slots 数组来说，程序检查节点是否复杂处理某个槽，又或者将某个槽指派给节点复杂，这两个动作的复杂度都是 0(1)。&lt;/p&gt;&#xA;&lt;p&gt;此外，节点还会将自己的 slots 数组通过消息发给集群中的其他节点，以此来告知其他节点自己目前负责处理哪些槽。clusterState结构中的 slots 数组记录了集群中所有 16384 个槽的指派信息，如果 slots[i] 指向 NULL，表示槽 i 尚未指派给任何节点，如果指向一个 clusterNode 结构，那么表示槽 i 已经指派给了 clusterNode 结构所代表的节点。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;typedef struct clusterState {&#xA;&#x9;// ...&#xA;&#x9;clusterNode *slots[16384];&#xA;&#x9;// ...&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要说明的一点是，虽然 clusterState.slots 数据记录了集群中所有槽的指派信息，但使用 clusterNode 结构的 slots 数组来记录单个节点的槽指派信息仍然是 &lt;strong&gt;必要的&lt;/strong&gt;。如果单独使用 clusterState.slots 数据的话，那么每次要将节点 A 的槽指派信息 &lt;strong&gt;传播&lt;/strong&gt; 给其他节点时，程序必须先遍历整个 clusterState.slots 数组，记录节点 A 负责处理哪些槽，然后才能发送节点 A 的槽指派信息，这比直接发送 clusterNode.slots 数组要麻烦和低效的多。&lt;/p&gt;&#xA;&lt;p&gt;当客户端向集群中的节点发送数据命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己，具体的流程如下图所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/redis-ask-error.jpg&#39; alt=&#34;/images/redis-ask-error.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;如果键所在的槽并没有指派给当前节点，那么节点会向客户端返回一个 &lt;code&gt;MOVED&lt;/code&gt; 错误，指引客户端转向 redirect 至正确的节点，并再次发送之前想要执行的命令。因此一个集群客户端通常会与集群中的多个节点创建套接字连接，而所谓的节点转向实际上就是 &lt;strong&gt;换一个套接字&lt;/strong&gt; 来发送命令。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;复制与故障转移&#34;&gt;&lt;span&gt;复制与故障转移&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%a4%8d%e5%88%b6%e4%b8%8e%e6%95%85%e9%9a%9c%e8%bd%ac%e7%a7%bb&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;Redis 集群中，主节点用于处理槽，从节点用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。集群从节点的复制功能和单机 Redis 服务器的复制功能使用了相同的代码，一个节点成为从节点，并开始复制某个主节点这一信息会 &lt;strong&gt;通过消息发送&lt;/strong&gt; 给集群中的其他节点，最终集群中的所有节点都会知道某个从节点正在复制某个主节点。&lt;/p&gt;&#xA;&lt;p&gt;集群中的每个节点会定期地向集群中的其他节点发送 PING 消息，如果接收 PING 消息的节点没有在规定的时间内返回 PONG 消息，那么发送 PING 消息的节点就会将接收 PING 消息的节点标记为 &lt;strong&gt;疑似下线&lt;/strong&gt;。如果在一个集群中 &lt;strong&gt;半数以上&lt;/strong&gt; 负责处理槽的主节点都将某个主节点 x 报告为疑似下线时，那么这个主节点 x 将被标记为 &lt;strong&gt;已下线 FAIL&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;这时从节点将开始对下线主节点进行故障转移，从该主节点的所有从节点里面，选举出新的主节点，撤销所有对已下线主节点的槽指派，全部指派给新的主节点，并通知集群中的其他节点。集群选举新的主节点的方法为：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在每个配置纪元中，已下线主节点的从节点会向集群广播一条消息，向主节点要求投票，而第一个向集群中主节点要求投票的从节点将获得投票。&lt;/li&gt;&#xA;&lt;li&gt;当一个从节点收集到大于等于 N/2+1 张支持票时，这个从节点就会当选新的主节点，确保了新的主节点只会有一个。&lt;/li&gt;&#xA;&lt;li&gt;如果在一个配置纪元里面没有从节点能收集到足够多的支持票，那么集群将进入一个新的配置纪元，并再次进行选择，直到选出新的主节点为止。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 class=&#34;heading-element&#34; id=&#34;redis-功能&#34;&gt;&lt;span&gt;Redis 功能&lt;/span&gt;&#xA;  &lt;a href=&#34;#redis-%e5%8a%9f%e8%83%bd&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&lt;h3 class=&#34;heading-element&#34; id=&#34;发布与订阅&#34;&gt;&lt;span&gt;发布与订阅&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%8f%91%e5%b8%83%e4%b8%8e%e8%ae%a2%e9%98%85&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;客户端可以订阅一个或多个频道，每当有其他客户端向被订阅的频道发送消息时，频道的所有订阅者都会收到这条消息。此外客户端还可以通过 &lt;code&gt;PSUBSCRIBE&lt;/code&gt; 订阅一个或多个模式，从而接收所有与模式匹配的频道的消息。如下图所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/redis-subscribe.jpg&#39; alt=&#34;/images/redis-subscribe.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Redis 将所有频道的订阅关系都保存在服务器状态的 &lt;code&gt;pubsub_channels&lt;/code&gt; 字典里面，键为某个被订阅的频道，值是一个链表，里面记录了所有订阅这个频道的客户端。类似地，所有模式的订阅关系都保存在服务器状态的 &lt;code&gt;pubsub_patterns&lt;/code&gt; 属性里面，它也是一个链表，里面记录了客户端与其订阅的模式，如下图所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/redis-multi-queue.jpg&#39; alt=&#34;/images/redis-multi-queue.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;当一个 Redis 客户端执行 &lt;code&gt;PUBLISH &amp;lt;channel&amp;gt; &amp;lt;message&amp;gt;&lt;/code&gt; 命令将消息发送给频道时，服务器会将消息 message 发送给频道所有的订阅者，并发送给所有与 channel 匹配的模式的订阅者。PUBLISH 命令将在 pubsub_channels 字典中查找键为 channel 对应的链表值，然后遍历链表将消息发送给频道所有的订阅者。&lt;/p&gt;&#xA;&lt;p&gt;至于模式订阅者，PUBLISH 命令会遍历整个 pubsub_patterns 链表，查找那些与 channel 频道相匹配的模式，&#xA;并将消息发送给订阅了这些模式的客户端，其伪代码如下所示：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;def pattern_public(channel, message) :&#xA;&#xA; # 遍历所有模式订阅消息&#xA; for pubsubPattern in server.pubsub_patterns:&#xA; &#xA;  # 如果频道和模式相匹配&#xA;  if match (channel, pubsubPattern.pattern):&#xA;  &#xA;   # 那么将消息发送给订阅该模式的客户端&#xA;   send_message(pubsubPattern.client, message)&lt;/code&gt;&lt;/pre&gt;&lt;h3 class=&#34;heading-element&#34; id=&#34;事务&#34;&gt;&lt;span&gt;事务&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e4%ba%8b%e5%8a%a1&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;Redis 事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器 &lt;strong&gt;不会中断事务&lt;/strong&gt; 而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。以下是一个 Redis 事务执行的过程：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;redis&amp;gt; MULTI&#xA;OK&#xA;&#xA;redis&amp;gt; SET &amp;#34;name&amp;#34; &amp;#34;Practical Common Lisp&amp;#34;&#xA;QUEUED&#xA;&#xA;redis&amp;gt; GET &amp;#34;name&amp;#34;&#xA;QUEUED&#xA;&#xA;redis&amp;gt; SET &amp;#34;author&amp;#34; &amp;#34;Peter Seibel&amp;#34;&#xA;QUEUED&#xA;&#xA;redis&amp;gt; GET &amp;#34;auther&amp;#34;&#xA;QUEUED&#xA;&#xA;redis&amp;gt; EXEC&#xA;1) OK&#xA;2) &amp;#34;Practical Common Lisp&amp;#34;&#xA;3) OK&#xA;4) &amp;#34;Peter Seibel&amp;#34;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;MULTI&lt;/code&gt; 命令的执行标志着事务的开始，当一个客户端切换到事务状态之后，服务器会根据这个客户端发来的不同命令执行不同的操作：如果客户端发送的命令为 EXEC、DISCARD、WATCH、MULTI 四个命令的其中一个，那么服务器立即执行这个命令；相反，如果是这四个命令以外的其他命令，那么服务器并不立即执行这个命令，而是将这个命令放入一个 FIFO 事务队列里面，然后向客户端返回 &lt;code&gt;QUEUED&lt;/code&gt; 回复，其具体逻辑如下图所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/redis-multi.jpg&#39; alt=&#34;/images/redis-multi.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;当一个处于事务状态的客户端向服务器发送 &lt;code&gt;EXEC&lt;/code&gt; 命令时，这个 EXEC 命令将被立即执行，服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;watch-命令的实现&#34;&gt;&lt;span&gt;WATCH 命令的实现&lt;/span&gt;&#xA;  &lt;a href=&#34;#watch-%e5%91%bd%e4%bb%a4%e7%9a%84%e5%ae%9e%e7%8e%b0&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;&lt;code&gt;WATCH&lt;/code&gt; 命令是一个乐观锁的实现，它可以在 EXEC 命令执行之前监视任意数量的数据库键，并在 EXEC 命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将 &lt;strong&gt;拒绝执行事务&lt;/strong&gt;，并向客户端返回代表执行失败的空回复。&lt;/p&gt;&#xA;&lt;p&gt;每个 Redis 数据库都保存着一个 watched_keys 字典，字典的键是被 WATCH 监视的数据库键，而字典的值是一个链表，记录了所有监视相应数据库键的客户端。所有对数据库进行修改的命令，比如 SET、LPUSH、SADD、ZREM、DEL、FLUSHDB 等等，在执行之后都会调用 multi.c/touchWatchKey 函数对 watched_keys 字典进行检查，如果有客户端正在监视刚刚被命令修改过的数据库键，那么 touchWatchKey 函数会将链表中客户端的 &lt;code&gt;REDIS_DIRTY_CAS&lt;/code&gt; 标识打开，标识该客户端的事务安全性已经被破坏。&lt;/p&gt;&#xA;&lt;p&gt;当接收到客户端发来的 EXEC 命令时，服务器会根据这个客户端是否打开了 REDIS_DIRTY_CAS 标识来决定是否执行事务：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/redis-watch.jpg&#39; alt=&#34;/images/redis-watch.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;事务的-acid-性质&#34;&gt;&lt;span&gt;事务的 ACID 性质&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e4%ba%8b%e5%8a%a1%e7%9a%84-acid-%e6%80%a7%e8%b4%a8&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;Redis 的事务具有原子性，可以将事务中的多个操作当做一个整体来执行，服务器要么执行事务中的所有操作，要么就一个操作也不执行。与传统关系型数据库的最大区别是，Redis &lt;strong&gt;不支持事务回滚&lt;/strong&gt; 机制，即使事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下午，直到将事务队列中的所有命令都执行完毕为止。&lt;/p&gt;&#xA;&lt;p&gt;Redis 通过谨慎的错误检测和简单的设计来保证事务的一致性，比如在事务入队命令的过程中，如果出现命令不存在或者命令格式不正确等，错误的命令不会被入队；事务在执行的过程中发生错误，出错的命令 &lt;strong&gt;不会&lt;/strong&gt; 对数据库做任何修改，也不会中断事务的执行，服务器会继续执行事务中余下的其他命令，并且已执行的命令不会被出错的命令影响。&lt;/p&gt;&#xA;&lt;p&gt;因为 Redis 使用 &lt;strong&gt;单线程&lt;/strong&gt; 的方式来执行事务（以及事务队列中的命令），并且服务器保证，在执行事务期间不会对事务进行中断，因此，Redis 的事务总是以串行的方式运行的，并且事务也总是具有隔离性的。&lt;/p&gt;&#xA;&lt;p&gt;当服务器在无持久化的内存模式下运行时，事务不具有耐久性；当运行在 RDB 模式下时，服务器只会在特定的保存条件被满足时，才会执行 BGSAVE 命令，因此也不具有耐久性；当运行在 AOF 模式下时，并且 appendfsync 选项的值为 always 时，事务才是具有耐久性的。虽然可以在事务的最后加上 SAVE 命令来保证事务的耐久性，但这种做法效率太低，并不具有实用性。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Java：并发编程实战</title>
      <link>https://hoffmanzheng.github.io/2021/java-concurrency/</link>
      <pubDate>Fri, 02 Apr 2021 13:19:47 +0100</pubDate>
      <guid>https://hoffmanzheng.github.io/2021/java-concurrency/</guid>
      <category domain="https://hoffmanzheng.github.io/categories/reading-notes/">Reading Notes</category>
      <description>&lt;p&gt;在 &lt;a href=&#34;http://www.mooreslaw.org&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;摩尔定律&lt;/a&gt; 失效的今天，通过提高时钟频率来提升处理器的性能已变得越来越困难，如何高效地使用并发，充分发挥多核处理器的强大计算能力变得益发重要。操作系统的出现使得计算机可以每次运行多个程序，实现了 &lt;strong&gt;进程级别的并发&lt;/strong&gt;，操作系统为每个进程分配各自的资源（比如内存），不同的进程之间可以通过一些通信机制来交换数据，包括套接字、文件、共享内存等。&lt;/p&gt;&#xA;&lt;p&gt;线程的出现允许在同一个进程中同时存在 &lt;strong&gt;多个程序控制流&lt;/strong&gt;，它们共享进程中的资源，并且可以被同时调度到多个 CPU 上运行。多线程程序通过对多核处理器的充分利用来提升系统吞吐率，然而这却会引入更多的问题：指令重排、并发修改、死锁、饥饿、活锁、上下文切换、线程调度开销等。&lt;/p&gt;&#xA;&lt;p&gt;本篇将结合 &lt;a href=&#34;https://book.douban.com/subject/10484692/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;《Java 并发编程实战》&lt;/a&gt; 讲解在 Java 项目中如何利用线程来提高并发程序的吞吐量或响应性，如何确保并发程序的执行与预期一致，避免安全性和活跃性问题。&lt;/p&gt;&#xA;&lt;h1 class=&#34;heading-element&#34; id=&#34;并发任务的控制&#34;&gt;&lt;span&gt;并发任务的控制&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%b9%b6%e5%8f%91%e4%bb%bb%e5%8a%a1%e7%9a%84%e6%8e%a7%e5%88%b6&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&lt;p&gt;在设计并发程序时，第一步就是要找出清晰的 &lt;strong&gt;任务边界&lt;/strong&gt;，抽象出相互独立、可以并行执行的工作单元。大多数服务器应用程序都提供了一种自然的任务边界选择方式：以独立的客户请求为边界，主线程不断接收外部连接、&lt;strong&gt;分发请求&lt;/strong&gt;并创建一个新线程来处理请求，但这种方法存在一些缺陷：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;线程生命周期的开销非常高：大量轻量级的请求会在线程的创建和销毁上消耗较多的计算资源&lt;/li&gt;&#xA;&lt;li&gt;资源消耗：如果可运行的线程数大于可用处理器的数量，闲置线程将会占用内存，且给垃圾回收带来压力；在 CPU 忙碌的状态下再创建更多的线程反而会降低性能&lt;/li&gt;&#xA;&lt;li&gt;稳定性：没有对可创建的线程数做一个限制，容易耗尽资源造成 &lt;code&gt;OutOfMemory&lt;/code&gt; 异常&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;executor-框架&#34;&gt;&lt;span&gt;Executor 框架&lt;/span&gt;&#xA;  &lt;a href=&#34;#executor-%e6%a1%86%e6%9e%b6&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;串行执行的问题在于其糟糕的响应性和吞吐量，而 “为每个任务分配一个线程” 却产生了复杂的 &lt;strong&gt;资源管理&lt;/strong&gt; 问题。为此 Java 提供了 Executor 作为 Thread 的替代，它提供了一种标准的任务执行框架，可以将任务的提交过程与实际执行过程 &lt;strong&gt;解耦&lt;/strong&gt; 开来，从而无须太大的困难就可以为某种类型的任务指定和修改 &lt;strong&gt;执行策略&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;笔者在 &lt;a href=&#34;https://hoffmanzheng.github.io/2020/java-threadpool/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Java：线程池原理、源码分析&lt;/a&gt; 中已经介绍过线程池相关的内容，线程池通过对线程的统一分配、调优和监控等，实现了从 “为每个任务分配一个线程” 策略到基于线程池的策略的飞跃，服务器不会再创建数千个线程来争夺有限的 CPU 和内存资源，也不会再在高负载情况下失败了。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;处理非正常的线程中止&#34;&gt;&lt;span&gt;处理非正常的线程中止&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%a4%84%e7%90%86%e9%9d%9e%e6%ad%a3%e5%b8%b8%e7%9a%84%e7%ba%bf%e7%a8%8b%e4%b8%ad%e6%ad%a2&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;在延迟任务及周期任务上，&lt;code&gt;java.util.Timer&lt;/code&gt; 提供了基于绝对时间的调度机制， 但 Timer 在执行所有定时任务时只会创建一个线程，如果某个任务的执行时间过长，可能会影响后续的任务执行。此外如果 TimerTask 抛出一个 &lt;strong&gt;未检查异常&lt;/strong&gt;，定时线程将会被 &lt;strong&gt;终止&lt;/strong&gt;，Timer 也不会恢复线程的执行，而是会错误地认为整个 Timer 都被取消了。因此已经被调度但尚未执行的 TimerTask 将不会执行，新的任务也不能被调度，导致 &lt;code&gt;线程泄漏&lt;/code&gt;。（推荐使用 DelauQueue 或者 ScheduledThreadPoolExecutor）&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;public class OutOfTime {&#xA; public static void main(String[] args) throws Exception {&#xA;        Timer timer = new Timer();&#xA;        timer.schedule(new ThrowTask(), 1);&#xA;        SECONDS.sleep(1);                        // 程序到此就结束了&#xA;        timer.schedule(new ThrowTask(), 1);&#xA;        SECONDS.sleep(5);&#xA;    }&#xA;    &#xA;    static class ThrowTask extends TimerTask {&#xA;        public void run() {&#xA;            throw new RuntimeException();&#xA;        }&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;线程因未捕获异常而终止时，应用程序可能看起来仍然在工作，所以这个错误可能会被忽略。任何代码都可能抛出一个 RuntimeException，不要盲目地认为它一定会正常返回，因此线程应该在 &lt;code&gt;try-catch&lt;/code&gt; 代码块中调用任务，捕获那些未检查的异常，也可以使用 &lt;code&gt;try-finally&lt;/code&gt; 代码块来 &lt;strong&gt;确保框架能够知道&lt;/strong&gt; 线程非正常退出的情况，并作出正确的响应。如以下展示了如何在线程池内部处理非受检异常：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;public void run() {&#xA;    Throwable thrown = null;&#xA;    try {&#xA;        while (!isInterrupted()) {&#xA;            runTask(getTaskFromWorkQueue());&#xA;        } &#xA;    } catch (Throwable e) {&#xA;        thrown = e;&#xA;    } finally {&#xA;        threadExited(this, thrown);      // 通知框架该线程已经终结&#xA;        // 框架可能会用新的线程代替这个工作线程，确保不会影响到后续任务的执行&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;除了上述主动 &lt;strong&gt;处理未检查异常&lt;/strong&gt; 的方法，Thread 中提供了 &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt;，它能检测出某个线程由于未捕获异常而终结的情况，然后做出相应的处理（默认为将栈追踪信息输出到 System.err）：例如将错误信息及相应的栈追踪信息写入应用程序中、尝试重新启动线程、执行其他修复或诊断等。&lt;/p&gt;&#xA;&lt;p&gt;如果想为线程池中的所有线程设置一个 UncaughtExceptionHandler，需要为 ThreadPoolExecutor 的构造函数提供一个 ThreadFactory（&lt;code&gt;thread.setUncaughtExceptionHandler(new CustomUEH());&lt;/code&gt;），将任务封装在能够捕获异常的 Runable 或 Callable 中，或者改写 ThreadPoolExecutor 的 &lt;code&gt;afterExecute&lt;/code&gt; 方法。需要注意的是，只有通过 execute 提交的任务，才能将它抛出的异常交给未捕获异常处理，而通过 submit 提交的任务，都会将异常封装在 Future.get 的 ExecutionException 中以重新抛出。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;一组任务的结果收集&#34;&gt;&lt;span&gt;一组任务的结果收集&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e4%b8%80%e7%bb%84%e4%bb%bb%e5%8a%a1%e7%9a%84%e7%bb%93%e6%9e%9c%e6%94%b6%e9%9b%86&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;如果希望得到一组任务的计算结果，可以保留与每个任务关联的 Future，然后反复调用 get 方法，timeout 指定为 0，通过轮询判断任务是否完成。这种方法虽然可行，但有些繁琐，幸运的是还有一种更好的方法：&lt;code&gt;CompletionService&lt;/code&gt;。它将 Executor 和 BlockingQueue 的功能融合在一起，在提交任务后通过队列的 take 和 poll 等方法来获取已完成的结果。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;任务的取消与线程的关闭&#34;&gt;&lt;span&gt;任务的取消与线程的关闭&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e4%bb%bb%e5%8a%a1%e7%9a%84%e5%8f%96%e6%b6%88%e4%b8%8e%e7%ba%bf%e7%a8%8b%e7%9a%84%e5%85%b3%e9%97%ad&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;任务和线程的启动很容易，在大多数时候，我们都会让它们运行直到结束，或者让它们自行停止。然而有时候我们希望 &lt;strong&gt;提前结束任务或线程&lt;/strong&gt;，或许是因为用户取消了操作，或者应用程序需要被快速关闭。Java 没有提供任何机制来安全地终止线程，只提供了中断（Interruption）作为 &lt;strong&gt;协作&lt;/strong&gt; 机制，去 &lt;strong&gt;通知&lt;/strong&gt; 另一个线程去终止当前的工作，因为任务本身的代码比发出取消请求的代码更清楚如何执行清除工作（避免将共享的数据置于不一致的状态）。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://java.sun.com/j2se/1.5.0/docs/guide/misc/threadPrimitiveDeprecation.html&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Why are Thread.stop, Thread.suspend, Thread.resume and Runtime.runFinalizersOnExit Deprecated?&lt;/a&gt; 中讲述了 Thread.stop 和 suspend 等方法存在的一些缺陷，以及废弃的原因：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Thread.stop 是不安全的，终止一个线程会抛出 &lt;code&gt;ThreadDeath&lt;/code&gt; 并 unlock 所有它拥有的锁，导致这些锁保护的共享对象处在一个不一致的状态。如果其他线程在这些共享对象上操作可能会导致任意的行为，ThreadDeath 会悄悄地杀死线程，因此并没有警告说应用程序处在一个危险的状态。&lt;/li&gt;&#xA;&lt;li&gt;如果想终止一个等待中的线程，可以使用 &lt;code&gt;Thread.interrupt&lt;/code&gt; ，它使用了基于状态的信号机制。如果一个方法 catch 了 InterruptedException 但是没有声明抛出这个受检异常，那它应该通过 &lt;code&gt;Thread.currentThread().interrupt();&lt;/code&gt; 重新中断线程。&lt;/li&gt;&#xA;&lt;li&gt;Thread.suspend 本质上容易发生死锁，如果目标线程在挂起时持有了一个锁，那么其他线程在目标线程恢复前将无法获取这个锁保护的对象。如果恢复目标线程的线程在调用 &lt;code&gt;Thread.resume&lt;/code&gt; 之前尝试获取这个锁，则会导致死锁。&lt;/li&gt;&#xA;&lt;li&gt;可以使用 &lt;code&gt;Object.wait&lt;/code&gt; 挂起线程，&lt;code&gt;Object.notify&lt;/code&gt; 恢复线程。注意 wait 和 notify 方法都在同步代码块中进行调用，保证序列化运行以减少竞争。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;取消任务&#34;&gt;&lt;span&gt;取消任务&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%8f%96%e6%b6%88%e4%bb%bb%e5%8a%a1&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;如果通过在任务中设置 “已请求取消” &lt;strong&gt;标志位&lt;/strong&gt; + 轮询的方式实现任务的取消，那么在请求取消的时刻和下一次检查标志位之间就会存在延迟，在与阻塞方法联合使用时可能会导致更严重的问题：任务可能 &lt;strong&gt;永远不会检查&lt;/strong&gt; 取消标志。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;class BrokenPrimeProducer extends Thread {&#xA; private final BlockingQueue&amp;lt;BigInteger&amp;gt; queue;&#xA;    private volatile boolean cancelled = false;        // 标志位&#xA;    &#xA;    public void run() {&#xA;        try {&#xA;            BigInteger p = BigInteger.ONE;&#xA;            while (!cancelled) {&#xA;                queue.put(p = p.nextProbablePrime());   // 队列满，一直阻塞，无法通过 cancel 取消&#xA;            }&#xA;        } catch (InterruptedException consumed) {}&#xA;    }&#xA;    &#xA;    public void cancel() {cancelled = true;}&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为此 Java 使用中断作为一种协作的方式去通知另一个线程 &lt;strong&gt;在合适的情况下&lt;/strong&gt; 停止当前的工作。每个线程都有一个 boolean 类型的中断状态，在调用 interrupt() 方法后被设置，它并不会真正地去中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;public class Thread implements Runable {&#xA;    public void interrupt() {...}                // 中断该线程&#xA;    public boolean isInterrupted() {...}         // 判断当前线程是否被中断&#xA;    public static boolean interrupted() {...}    // 测试这个线程是否被中断，清除中断状态，并返回它之前的值  -&amp;gt; 除非想屏蔽这个中断，否则必须对它进行处理，抛出 InterruptedException 或者调用 interrupt&#xA;    &#xA;    /**&#xA;     * @throws  InterruptedException&#xA;     *          if any thread has interrupted the current thread. The&#xA;     *          &amp;lt;i&amp;gt;interrupted status&amp;lt;/i&amp;gt; of the current thread is&#xA;     *          cleared when this exception is thrown.&#xA;     */&#xA;    public static native void sleep(long millis) throws InterruptedException;&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一些阻塞库中的方法，比如 Thread.sleep 和 Object.wait 等，都会检查线程何时中断，清除中断状态后抛出 &lt;code&gt;InterruptedException&lt;/code&gt; ，因此上述通过标志位取消任务的机制可以优化为使用中断来实现：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;class BrokenPrimeProducer extends Thread {&#xA; private final BlockingQueue&amp;lt;BigInteger&amp;gt; queue;&#xA;    &#xA;    public void run() {&#xA;        try {&#xA;            BigInteger p = BigInteger.ONE;&#xA;            while (!Thread.currentThread().isInterrupted()) {  // 检测中断&#xA;                // 这里显式的检测是不必要的，但执行后会对中断提供更高的响应性&#xA;                queue.put(p = p.nextProbablePrime());          // 响应中断&#xA;            }&#xA;        } catch (InterruptedException consumed) {}&#xA;    }&#xA;    &#xA;    public void cancel() {interrupt();}&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在响应中断方面，非线程所有者应该小心地 &lt;strong&gt;保存中断状态&lt;/strong&gt;（传递 InterruptedException / 使用 interrupt 恢复中断状态），这样拥有线程的代码才能对中断做出响应。这也是大多数可阻塞的库函数都只是抛出 InterruptedException 作为中断响应的原因，它们的取消策略就是尽快退出执行流程，并把中断信息传递给调用者，从而使调用栈中的上层代码可以采取进一步的操作。&lt;/p&gt;&#xA;&lt;p&gt;如果代码不会调用可中断的阻塞方法，仍然可以通过在任务代码中选择合适的频率轮询当前线程的中断状态来响应中断。以 ThreadPoolExecutor 为例，它的工作者线程在检测到中断时，如果线程池正在关闭，它会在结束之前执行一些线程池清理工作，否则它可能创建一个新线程将线程池恢复到合理的规模。&lt;/p&gt;&#xA;&lt;p&gt;此外还可以使用 &lt;code&gt;future.cancel(boolean mayInterruptIfRunning)&lt;/code&gt; 来实现取消，参数 mayInterruptIfRunning 表示能否中断运行中的任务。使用 AbstractExecutorService.newTaskFor + 实现 RunnableFuture 可以实现非标准的取消，定制的取消代码可以实现日志记录或者收集取消操作的统计信息，以及一些不响应中断的操作。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;public static void timeRun (Runnable r, long timeout, TimeUnit unit) throws InterruptedException {&#xA;    Future&amp;lt;?&amp;gt; task = taskExec.submit(r);&#xA;    try {&#xA;        task.get(timeout, unit);&#xA;    } catch (TimeoutException e) {&#xA;        // 接下来任务会被取消&#xA;    } catch (ExecutionException e) {&#xA;        throw launderThrowable(e.getCause()); // 重新抛出任务中的异常&#xA;    } finally {&#xA;        task.cancel(true);&#xA;        // 超时后取消任务，如果任务成功返回，这个操作不会有任何影响&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然 Java 没有提供抢占式的中断机制，然而通过推迟中断请求的处理，开发人员能制定更灵活的中断策略，从而使应用程序在响应性和健壮性之间实现合理的平衡。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;停止基于线程的服务&#34;&gt;&lt;span&gt;停止基于线程的服务&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%81%9c%e6%ad%a2%e5%9f%ba%e4%ba%8e%e7%ba%bf%e7%a8%8b%e7%9a%84%e6%9c%8d%e5%8a%a1&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;应用服务通常会创建拥有多个线程的服务，且这些服务的生命周期通常比创建它们的方法的生命周期 &lt;strong&gt;更长&lt;/strong&gt;。如果应用程序准备退出，那么这些服务所拥有的线程也需要结束。由于无法通过抢占式的方法来停止线程，因此它们需要自行结束（需提供生命周期方法）。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;比如日志服务，应用线程调用 log 方法将日志放入某个队列，由专门的日志线程负责写入，是一种多生产者单消费者的设计。如果直接关闭日志服务，就会 &lt;strong&gt;丢失&lt;/strong&gt; 那些正在等待被写入到日志的信息，并且由于队列满了其他正在调用 log 的线程将会被阻塞。为此可以设置一个标志位，在日志放入队列前进行判断，但这样就存在 “先判断再运行” 的竞态条件问题。由于队列的 put 本身可以阻塞，可以以原子方式检查关闭请求，并递增一个计数器来保持提交消息的权利：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code&gt;public class LogService {&#xA;    private final BlockingQueue&amp;lt;String&amp;gt; queue;&#xA;    private final LoggerThread loggerThread;&#xA;    private final PrintWriter writer;&#xA;    private boolean isShutdown;                 // 标志位  &#xA;    private int reservations;                   // 计数器&#xA;    &#xA;    public void start() { loggerThread.start(); }&#xA;    &#xA;    public void stop() {&#xA;        synchronized(this) { isShutdown = true; }&#xA;        loggerThread.interrupt();&#xA;    }&#xA;    &#xA;    public void log (String msg) throws InterruptedException {&#xA;        synchronized (this) {&#xA;            if (isShutdown) {                   // 在应用线程调用 log 时先检查标志位&#xA;                throw new IllegalStateException(...);&#xA;            }&#xA;            &amp;#43;&amp;#43;reservations;&#xA;        }&#xA;        queue.put(msg);                         &#xA;        // 对共享的标志位和计数器上锁已经足够了，队列本身会阻塞&#xA;    }&#xA;    &#xA;    private class LoggerThread extends Thread {&#xA;        public void run() {&#xA;            try {&#xA;                while (true) {&#xA;                    try {&#xA;                        synchronized (LogService.this) {&#xA;                            if (isShutdown &amp;amp;&amp;amp; reservation == 0) {&#xA;                                break;&#xA;                            }&#xA;                        }&#xA;                        String msg = queue.take();&#xA;                        synchronized (LogService.this) { --reservations; }&#xA;                        writer.println(msg);&#xA;                    } catch (InterruptedException e) { /** retry */}&#xA;                }&#xA;            } finally {&#xA;                writer.close();&#xA;            }&#xA;        }&#xA;    }&#xA;} &lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;另一种关闭生产者-消费者服务的方式就是使用 “毒丸 Poison Pill” 对象。当从队列中获取到这个毒丸对象时就停止服务。在先进先出 FIFO 的队列中，毒丸对象能确保在关闭消费者之前能够完成队列中之前提交的所有工作，而生产者在提交毒丸对象后也不会再提交任务工作。 遗憾的是，毒丸对象只适用于生产者和消费者的数量都已知的情况。&lt;/li&gt;&#xA;&lt;li&gt;在调用 shutdownNow 关闭线程池时，除了想得到所有已提交但尚未开始的任务，还想获取所有已经开始但尚未结束的任务，可以通过 &lt;strong&gt;封装&lt;/strong&gt; ExecutorService 并使得 execute 记录哪些任务是在线程池关闭后被取消的：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code&gt;public class TrackingExecutor extends AbstractExecutorService {&#xA;    private final ExecutorService exec;&#xA;    private final Set&amp;lt;Runnable&amp;gt; tasksCancelledAtShutdown = Collections.synchronizedSet(new HashSet&amp;lt;Runnable&amp;gt;);&#xA;    &#xA;    public void execute (final Runnable runnable) {&#xA;        exec.execute(new Runnable()) {&#xA;            public void run() {&#xA;                try {&#xA;                    runnable.run();&#xA;                } finally {&#xA;                    if (isShutdown() &amp;amp;&amp;amp; Thread.currentThread().isInterrupted()) {&#xA;                        tasksCancelledAtShutdown.add(runnable);&#xA;                    } &#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;    &#xA;    public List&amp;lt;Runnable&amp;gt; getCancelledTasks() {&#xA;        if (!exec.isTerminated()) {&#xA;            throw new IllegalStateException(...);&#xA;        }&#xA;        return new ArrayList&amp;lt;Runnable&amp;gt;(tasksCancelledAtShutdown);&#xA;    }&#xA;    &#xA;    // 将 ExecutorService 的其他方法委托给 exec&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;h1 class=&#34;heading-element&#34; id=&#34;活跃性问题与并发的性能&#34;&gt;&lt;span&gt;活跃性问题与并发的性能&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%b4%bb%e8%b7%83%e6%80%a7%e9%97%ae%e9%a2%98%e4%b8%8e%e5%b9%b6%e5%8f%91%e7%9a%84%e6%80%a7%e8%83%bd&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&lt;p&gt;我们使用加锁机制来确保线程安全，但如果过度使用加锁，则可能导致 &lt;strong&gt;锁顺序死锁&lt;/strong&gt;。同样我们使用线程池和信号量来限制对资源的使用，但它们可能会导致资源死锁。在数据库系统的设计中提供了 &lt;strong&gt;主动监测死锁及从死锁中恢复&lt;/strong&gt;（选择一个牺牲者放弃事务，释放它持有的资源，详见 &lt;a href=&#34;https://hoffmanzheng.github.io/2021/database-innodb/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Database：InnoDB 存储引擎&lt;/a&gt;）的机制，但 Java 应用程序是 &lt;strong&gt;无法&lt;/strong&gt; 从死锁中恢复过来的，因此在设计时就一定要排除可能导致死锁出现的条件。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;避免活跃性危险&#34;&gt;&lt;span&gt;避免活跃性危险&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e9%81%bf%e5%85%8d%e6%b4%bb%e8%b7%83%e6%80%a7%e5%8d%b1%e9%99%a9&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;h4 class=&#34;heading-element&#34; id=&#34;死锁&#34;&gt;&lt;span&gt;死锁&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%ad%bb%e9%94%81&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;如果两个线程试图以 &lt;strong&gt;不同的顺序&lt;/strong&gt; 来获得相同的锁，则可能会发生锁顺序死锁，如下图所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/lock-ordering-deadlock.jpg&#39; alt=&#34;/images/lock-ordering-deadlock.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;想要避免锁顺序死锁，需要对程序中的加锁行为进行全局分析，查看是否存在 &lt;strong&gt;嵌套的锁获取&lt;/strong&gt; 操作。有时候看似能够控制锁顺序的代码依然没有避免死锁的发生，如下列的代码，如果一个线程从 X 向 Y 转账，另一个线程从 Y 向 X 转账，那么就有可能会发生死锁。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;public void transferMoney (Account fromAccount, Account toAccount, DollarAmount amount) &#xA;    throws InsufficientFundsException {&#xA;    synchronized (fromAccount) {&#xA;        synchronized (toAccount) {    // 嵌套的锁获取操作&#xA;            if (fromAccount.getBalance().compareTo(amount) &amp;lt; 0) {&#xA;                throw new InsufficientFundsException();&#xA;            } else {&#xA;                fromAccount.debit(amount);&#xA;                toAccount.credit(amount);&#xA;            }&#xA;        }&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于我们无法控制参数的顺序，因此必须在整个程序中定义锁的顺序，可以使用 &lt;code&gt;System.identityHashCode&lt;/code&gt; 方法重新定义锁的顺序，来保证所有的线程 &lt;strong&gt;以固定的顺序&lt;/strong&gt; 来获取锁：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;private static final Object tieLock = new Object();&#xA;&#xA;public void transferMoney (Account fromAccount, Account toAccount, DollarAmount amount) &#xA;    throws InsufficientFundsException {&#xA;    class Helper {&#xA;        public void transfer() throws InsufficientFundsException {&#xA;            if (fromAccount.getBalance().compareTo(amount) &amp;lt; 0) {&#xA;                throw new InsufficientFundsException();&#xA;            } else {&#xA;                fromAccount.debit(amount);&#xA;                toAccount.credit(amount);&#xA;            }&#xA;        }&#xA;    }&#xA;    &#xA;    int fromHash = System.identityHashCode(fromAccount);&#xA;    int toHash = System.identityHashCode(toAccount);&#xA;    &#xA;    if (fromHash &amp;lt; toHash) {&#xA;        synchronized (fromAccount) {&#xA;            synchronized (toAccount) {&#xA;                new Helper().transfer();&#xA;            }&#xA;        }&#xA;    } else if (fromHash &amp;gt; toHash) {&#xA;        synchronized (toAccount) {&#xA;            synchronized (fromAccount) {&#xA;                new Helper().transfer();&#xA;            }&#xA;        }&#xA;    } else {&#xA;        synchronized (tieLock) {          &#xA;            // 极少情况拥有相同的散列值，加入另一个锁以保证串行&#xA;            synchronized (fromAccount) {&#xA;                synchronized (toAccount) {&#xA;                    new Helper().transfer();&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在持有锁的时候调用某个外部方法也可能出现活跃性问题，如果在这个外部方法中可能会获取其他锁（可能导致锁顺序死锁），或者阻塞时间过长，导致其他线程无法及时获得当前被持有的锁。如果在调用某个方法时不需要持有锁，这种调用表被称为 &lt;strong&gt;开放调用&lt;/strong&gt;。这种通过开放调用来避免死锁的方法，类似于采用封装机制来提供线程安全的方法，在分析的时候更为简单，更容易确保采用一致的顺序来获得锁。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;死锁的避免与诊断&#34;&gt;&lt;span&gt;死锁的避免与诊断&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%ad%bb%e9%94%81%e7%9a%84%e9%81%bf%e5%85%8d%e4%b8%8e%e8%af%8a%e6%96%ad&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;如果一个程序每次至多只能获得一个锁，那么就不会产生锁顺序死锁。如果必须获取多个锁，在设计时必须考虑锁的顺序：尽量减少潜在的加锁交互数量，将获取锁时需要遵循的协议写入正式文档并始终遵循这些协议。&lt;/p&gt;&#xA;&lt;p&gt;还有一项技术可以检测死锁和从死锁中恢复过来，即使用显示锁中的 &lt;strong&gt;定时 tryLock&lt;/strong&gt; 或者可轮询的锁。如下列代码所示，使用 tryLock 来获取两个锁，如果不能同时获得，那么就回退并重新尝试。在休眠时间中加入随机部分，从而降低活锁的可能性。如果在指定时间内不能获得所有需要的锁，就返回一个失败状态，从而使该操作平缓地失败。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;public boolean transferMoney (Account fromAccount, Account toAccount, &#xA;                              DollarAmount amount, long timeout, TimeUnit unit) &#xA;    throws InsufficientFundsException, InterruptedException{&#xA;    long stopTime = System.nanoTime() &amp;#43; unit.toNanos(timeout);&#xA;    while (true) {&#xA;        if (fromAccount.lock.tryLock()) {&#xA;            try {&#xA;                if (toAccount.lock.tryLock()) {&#xA;                    try {&#xA;                        if (fromAccount.getBalance().compareTo(amount) &amp;lt; 0 ) {&#xA;                            throw new InsufficientFundsException();&#xA;                        } else {&#xA;                            fromAccount.debit(amount);&#xA;                            toAccount.credit(amount);&#xA;                            return true;&#xA;                        }&#xA;                    } finally {&#xA;                        toAccount.lock.unlock();&#xA;                    }&#xA;                }&#xA;            } finally {   // 获取 toAccount 锁失败，释放掉 fromAccount 锁&#xA;                fromAccount.lock.unlock();&#xA;            }&#xA;        }&#xA;        if (System.nanoTime() &amp;lt; stopTime) { return false; }   &#xA;        // 在指定时间内不能获得所有需要的锁，返回失败的状态&#xA;        NANOSECONDS.sleep(new Random().nextInt() % 1000);   &#xA;        // 休眠一段时间，降低活锁发生的可能性&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;h4 class=&#34;heading-element&#34; id=&#34;其他活跃性危险&#34;&gt;&lt;span&gt;其他活跃性危险&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%85%b6%e4%bb%96%e6%b4%bb%e8%b7%83%e6%80%a7%e5%8d%b1%e9%99%a9&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;当线程由于无法访问它所需要的戏院而不能继续执行时，就发生了 &lt;strong&gt;饥饿&lt;/strong&gt;，比如对线程的优先级使用不当，或者在持有锁时执行一些无法结束的结构（无限制地等待某个资源）。在 Thread API 中定义的线程优先级只是作为线程调度的参考，JVM 会根据需要将它们映射到操作系统的调度优先级，由操作系统的线程调度器尽力地提供公平的、活跃性良好的调度。尽量 &lt;strong&gt;不要改变线程的优先级&lt;/strong&gt;，只要改变了线程的优先级，程序的行为就将与 &lt;strong&gt;平台相关&lt;/strong&gt;，并且有导致发生饥饿问题的风险。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;活锁&lt;/strong&gt; 是另一种形式的活跃性问题，虽然不会阻塞线程，但是线程将不断重复执行相同的操作，且总会失败。活锁通常是由过度的错误恢复代码造成的，当多个相互协作的线程都对彼此进行响应从而修改各自的状态，并使得任何一个线程都无法继续执行时，就发生了活锁。这就像两个过于礼貌的人在半路上面对面地相遇：他们彼此都让出对方的路，然后又在另一条路上相遇了，因此他们就这样反复地避让下去。要解决这种活锁问题，就需要 &lt;strong&gt;在重试机制中引入随机性&lt;/strong&gt;，比如等待一段随机的时间再重试。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;性能与可伸缩性&#34;&gt;&lt;span&gt;性能与可伸缩性&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%80%a7%e8%83%bd%e4%b8%8e%e5%8f%af%e4%bc%b8%e7%bc%a9%e6%80%a7&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;提升性能意味着用更少的资源做更多的事情，当操作性能由于某种特定的资源受到限制时，我们常将该操作称为资源密集型的操作，比如：&lt;a href=&#34;https://zh.wikipedia.org/zh/CPU%E5%AF%86%E9%9B%86%E5%9E%8B&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;CPU 密集型&lt;/a&gt;、I/O 密集型等。尽管使用多个线程的目标是提升整体性能，但却引入了一些额外的开销，包括：线程之间的协调（加锁、触发信号及内存同步等），增加的上下文切换， 线程的创建和销毁，以及线程的调度等。如果 &lt;strong&gt;过度地使用线程&lt;/strong&gt;，那么这些开销甚至会超过由于提高吞吐量、响应性或者计算能力所带来的性能提升。&lt;/p&gt;&#xA;&lt;p&gt;使用线程常常是为了充分利用多个处理器的计算能力，因此在并发程序性能的讨论中，通常更多地将侧重点放在 &lt;strong&gt;吞吐量和&lt;a href=&#34;https://baike.baidu.com/item/%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;可伸缩性&lt;/a&gt;&lt;/strong&gt; 上，而不是服务时间。Amdahl 定律告诉我们，程序的可伸缩性取决于在所有代码中必须被 &lt;strong&gt;串行执行&lt;/strong&gt; 的代码（比如独占锁）比例。因此通常可以通过以下方式来提升可伸缩性：减少锁的持有时间，降低锁的粒度，以及采用非独占的锁或非阻塞锁来代替独占锁。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;amdahl-定律&#34;&gt;&lt;span&gt;Amdahl 定律&lt;/span&gt;&#xA;  &lt;a href=&#34;#amdahl-%e5%ae%9a%e5%be%8b&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;大多数并发程序都是由一系列的并行工作和串行工作组成的。Amdahl 定律描述的是：在增加计算资源的情况下，程序在理论上能够实现最高加速比，取决于程序中 &lt;strong&gt;可并行组件与串行组件所占的比重&lt;/strong&gt;。如果 F 为必须被串行执行的部分，在包含 N 个处理器的机器中，最高的加速比为：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/speedup-Amdahl.png&#39; alt=&#34;/images/speedup-Amdahl.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;当 N 趋近无穷大时，最大的加速比趋近于 1/F。Amdahl 定律还量化了串行化的效率开销，在拥有 10 个处理器的系统中，如果程序有 10% 的部分需要串行执行，那么最高的加速比为 5.3（53% 的利用率），在拥有 100 个处理器的系统中加速比可以达到 9.2（9% 的利用率）。下图给出了处理器利用率（加速比 / 处理器的数量）在不同串行比例以及处理器数量情况下的变化曲线，可以明显地看到，即使串行部分所占的百分比很小，也会极大地限制当增加计算资源时能够提升的吞吐率。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/Amdahl-graph.jpg&#39; alt=&#34;/images/Amdahl-graph.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;如果要预测应用程序在某个多处理器系统中将实现多大的加速比，需要 &lt;strong&gt;找出任务中的串行部分&lt;/strong&gt;，除了任务本身执行的部分外，还有一些常见的串行操作容易被忽略：比如从队列中取出任务的部分，或是对结果进行处理的部分。下图给出从一个共享 Queue 取出元素时，增加线程对吞吐量的变化：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/Amdahl-concurrentLinkedQueue.jpg&#39; alt=&#34;/images/Amdahl-concurrentLinkedQueue.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;可以看到只需改变队列的实现方式，就能对可伸缩性产生明显的影响。吞吐量的差异来源于两个队列中不同比例的串行部分，同步的 LinkedList 采用单个锁来保护整个队列的状态，并且在 offer 和 remove 等方法的调用期间都将持有这个锁；ConcurrentLinkedQueue 使用了一种更复杂的非阻塞队列算法，&lt;strong&gt;减少了各个操作的串行部分&lt;/strong&gt;，获得了更好的吞吐量。当线程数达到一定值之后，吞吐量基本保持不变，这是由于线程增加后锁上的竞争增加，每个操作消耗的时间大部分都用于上下文切换和调度延迟，再加入更多的线程也不会提高太多的吞吐量。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;线程引入的开销&#34;&gt;&lt;span&gt;线程引入的开销&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e7%ba%bf%e7%a8%8b%e5%bc%95%e5%85%a5%e7%9a%84%e5%bc%80%e9%94%80&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;多个线程的调度和协调过程中都需要一定的性能开销：对于为了提升性能而引入的线程来说，并行带来的性能提升必须超过并发导致的开销。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;上下文切换&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;如果可运行的线程数大于 CPU 的数量，那么操作系统最终会将某个正在运行的线程调度出来，从而使其他线程能够使用 CPU，这将导致一次上下文切换（在大多数处理器中，上下文切换的开销相当于 5000~10000 个时钟周期，大约几微妙）。当线程在等待某个锁而 &lt;strong&gt;阻塞&lt;/strong&gt; 时，JVM 通常会将这个线程挂起，在程序中发生的阻塞越多，就会发生越多的上下文切换，在 JVM 和操作系统的代码中消耗越多的 CPU 时钟周期，应用程序的可用 CPU 时钟周期就越少，从而增加调度开销，并因此降低吞吐量。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;内存同步&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;synchronized 和 volatile 提供的内存可见性保证可能会使用特殊指令：内存栅栏。内存栅栏可以刷新缓存，使缓存无效，刷新硬件的写缓存以及停止执行管道，但同时 &lt;strong&gt;抑制&lt;/strong&gt; 一些编译器优化操作（比如指令重排序），对性能带来间接的影响。synchronized 机制对无竞争的同步进行了优化（例如去掉一些不会发生竞争的锁，通过逸出分析、锁粒度粗化减少锁获取操作次数等）（volatile 通常是非竞争的），通常只消耗 20~250 个时钟周期，对应用程序整体性能的影响微乎其微。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;阻塞&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;竞争的同步可能需要操作系统介入，从而增加开销。在锁上竞争失败的线程会发生阻塞，如果等待时间较短适合采用自旋等待的方式，而如果等待时间较长则会通过操作系统挂起线程，在这过程中将包含两次额外的 &lt;strong&gt;上下文切换&lt;/strong&gt;，以及所有必要的 &lt;strong&gt;操作系统操作&lt;/strong&gt; 和缓存操作：被阻塞的线程在其执行时间片还未用完之前就被交换出去，而在随后当要获取的锁或其他资源可用时，又再次被切换回来。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;减少锁的竞争&#34;&gt;&lt;span&gt;减少锁的竞争&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%87%8f%e5%b0%91%e9%94%81%e7%9a%84%e7%ab%9e%e4%ba%89&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;串行操作会降低可伸缩性，并且上下文切换也会降低性能。在锁上发生竞争时将同时导致这两种问题，因此减少锁的竞争能够提高性能和可伸缩性。有两个因素将影响在锁上发生竞争的可能性：&lt;strong&gt;锁的请求频率，以及每次持有该锁的时间&lt;/strong&gt;。如果二者的乘积很小，那么大多数获取锁的操作都不会发生竞争，不会对可伸缩性造成严重影响。然而如果在锁上的请求量很高，那么需要获取该锁的线程将被阻塞并等待，在极端情况下，即使仍有大量工作等待完成，处理器也会被 &lt;strong&gt;闲置&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;缩小锁的范围&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;降低发生锁竞争可能性的一种有效方式就是尽可能缩短锁的持有时间。例如可以将一些与锁无关的代码 &lt;strong&gt;移出同步代码块&lt;/strong&gt;，尤其是那些开销较大的操作，不需要访问 &lt;strong&gt;共享状态&lt;/strong&gt; 的操作，以及可能被阻塞的操作。根据 Amdahl 定律，这样消除了限制可伸缩性的一个因素，因为串行代码的总量减少了。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;减小锁的粒度&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;另一种减小锁的持有时间的方式是降低线程请求锁的频率，这可以通过 &lt;strong&gt;锁分解和锁分段&lt;/strong&gt; 等技术来实现。在这些技术中将采用多个相互独立的锁来保护独立的状态变量，改变这些变量在之前由单个锁来保护的情况，从而减小锁操作的粒度，实现更高的可伸缩性。&lt;code&gt;ConcurrentHashMap&lt;/code&gt; 就采用了锁分段技术，使用 16 个锁来保护所有的散列桶，这大约能把对于锁的请求减少到原来的 1/16。分段锁的一个劣势在于：在要获取多个锁来实现 &lt;strong&gt;独占访问&lt;/strong&gt; 时将会更加困难并且开销更高，比如在扩容时需要加锁整个容器，需要获取分段锁集合中所有的锁。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;避免热点域&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;当操作请求多个变量时，锁的粒度将很难降低。虽然使用一个独立的 &lt;strong&gt;计数器&lt;/strong&gt; 能很好地提高类似 size 和 isEmpty 方法的执行速度，但却导致更难以提升实现的可伸缩性，因为每个修改 map 的操作都需要更新这个共享的计数器。即使使用锁分段来实现散列链，那么在对计数器的访问进行同步时，也会重新导致在使用独占锁时存在的可伸缩性问题。在这种情况下，计数器也被称为 &lt;strong&gt;热点域&lt;/strong&gt;，因为每个导致元素数量变化的操作都需要访问它。为了避免这个问题，ConcurrentHashMap 为每个分段都维护了一个独立的计数，通过每个分段的锁来维护这个值，它的 size 将对每个分段进行枚举并将每个分段中的元素数量进行相加。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;避免使用独占锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;第三种降低竞争锁的影响的技术就是 &lt;strong&gt;放弃使用独占锁&lt;/strong&gt;，从而使用一种友好并发的方式来管理共享状态，比如使用并发容器、读-写锁、不可变对象以及原子变量，详见下文。&lt;/p&gt;&#xA;&lt;h1 class=&#34;heading-element&#34; id=&#34;java-对并发的支持&#34;&gt;&lt;span&gt;Java 对并发的支持&lt;/span&gt;&#xA;  &lt;a href=&#34;#java-%e5%af%b9%e5%b9%b6%e5%8f%91%e7%9a%84%e6%94%af%e6%8c%81&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&lt;h3 class=&#34;heading-element&#34; id=&#34;显式锁&#34;&gt;&lt;span&gt;显式锁&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%98%be%e5%bc%8f%e9%94%81&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;在大多数情况下，内置锁都能很好地工作，但在功能上存在一些 &lt;strong&gt;局限性&lt;/strong&gt;，例如无法中断一个正在等待获取锁的线程，或者无法在请求获取一个锁时无限地等待下去。Java 5.0 增加了 &lt;code&gt;ReentrantLock&lt;/code&gt;，它提供了一种无条件的、可轮询的、定时的以及可中断的锁获取操作。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;可定时的与可轮询的锁获取&lt;/strong&gt; 模式是由 tryLock 方法实现的，使用它可以有效避免死锁的发生（&lt;strong&gt;代码示例参见上文&lt;/strong&gt;：死锁的避免与诊断）。使用定时锁时，如果不能在指定的时间内给出结果，那么就会使程序提前结束。当使用内置锁时，在开始请求锁后，这个操作将无法取消，因此内置锁将难以实现带有时间限制的操作。此外，&lt;code&gt;Lock.lockInterruptibly&lt;/code&gt; 方法能够在获得锁的同时保持对中断的响应，实现一个可取消的加锁操作。&lt;/p&gt;&#xA;&lt;p&gt;相比 ReentrantLock 使用的保守且强硬的互斥锁，&lt;code&gt;ReadWriteLock&lt;/code&gt; 提供了一种较为乐观的实现：一个资源可以被多个读操作访问，或者被一个写操作访问，但两者不能同时进行。读-写锁是一种性能优化措施，可以提高多处理器系统上被 &lt;strong&gt;频繁读取&lt;/strong&gt; 的数据结构的性能（见下图），而在其他情况下，读-写锁的性能要比独占锁的性能要略差一些，因为它们的复杂性更高。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/readWriteLock.jpg&#39; alt=&#34;/images/readWriteLock.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;条件队列&#34;&gt;&lt;span&gt;条件队列&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%9d%a1%e4%bb%b6%e9%98%9f%e5%88%97&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;在并发程序中，&lt;strong&gt;基于状态的条件&lt;/strong&gt; 可能会由于其他线程的操作而改变：一个资源池可能在几条指令之前还是空的，但现在却变为非空的，因为另一个线程可能会返回一个元素到资源池。当基于状态的前提条件不满足时，方法可以返回一个错误值，&lt;strong&gt;让调用者自行处理&lt;/strong&gt; 失败的情况，比如 &lt;code&gt;Queue.poll()&lt;/code&gt; 在队列为空时会返回 null，&lt;code&gt;Queue.remove()&lt;/code&gt; 则会直接抛出 NoSuchElementException 异常。&lt;/p&gt;&#xA;&lt;p&gt;客户代码在处理失败时，可以选择直接重试（称为忙等待或 &lt;strong&gt;自旋等待&lt;/strong&gt;），如果状态在很长一段时间内都不会发生变化，那么使用这种方法就会 &lt;strong&gt;消耗大量的 CPU 时间&lt;/strong&gt;。相反，调用者页可以进入休眠状态来避免消耗过多的 CPU 时间，但如果状态在刚调用完 sleep 就立即发生变化，那么将不必要地休眠一段时间。因此，客户代码必须要在二者之间进行选择：要么容忍自旋导致的 CPU 时钟周期的浪费，要么容忍由于休眠导致的低响应性。&lt;/p&gt;&#xA;&lt;p&gt;阻塞库的方法实现了 &amp;ldquo;&lt;strong&gt;轮询与休眠&lt;/strong&gt;&amp;rdquo; 的重试机制，从而使调用者无须在每次调用时都实现重试逻辑。如果队列为空，那么 take 将休眠并直到另一个线程在队列中放入一个元素；如果队列满了，那么 put 将休眠并直到另一个线程从队列中取走一个元素，以便有空间容纳新的数据。这种方法将前提条件的管理操作 &lt;strong&gt;封装&lt;/strong&gt; 起来，并简化了对队列的使用，但在实现的过程中需要付出大量的努力。如果存在某种挂起线程的方法，并且这种方法能够确保当某个 &lt;strong&gt;条件成真时线程立即醒来&lt;/strong&gt;，那么将极大地简化实现工作，这正是条件队列实现的功能。&lt;/p&gt;&#xA;&lt;p&gt;在调用内置条件队列的 &lt;code&gt;Object.wait()&lt;/code&gt; 方法时，需要持有条件队列对象上的锁。wait 方法将释放锁，阻塞当前线程，并等待直至超时，然后线程被中断或者通过一个通知被唤醒。虽然在锁、条件谓词（基于状态的前提条件）和条件队列之间的三元关系并不复杂，但使用内置的条件队列可能会造成以下几个问题：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;过早唤醒：一个条件队列能与多个条件谓词相关，当执行控制重新进入调用 wait 的代码时，可能有其他线程已经获取了这个锁，并修改了对象的状态。因此每当线程从 wait 中唤醒时，都必须再次测试条件谓词&lt;/li&gt;&#xA;&lt;li&gt;信号丢失：在开始 wait 之前没有检查条件谓词，导致线程在等待一个已经发过的事件；此外，多个线程可以基于不同的条件谓词在同一个条件队列上等待，如果使用 notify 可能会导致信号丢失的问题，所以在大多数情况下应该优先选择 notifyAll。虽然 notifyAll 可能比 notify 更低效，但却更容易确保类的行为是正确的。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;由于每个内置锁都只能有一个相关联的条件队列，而多个线程可能在同一个条件队列上 &lt;strong&gt;等待不同的条件谓词&lt;/strong&gt;，使得无法满足在使用 notifyAll 时所有等待线程为同一类型的需求。如果想编写一个带有多个条件谓词的并发对象，可以使用更灵活的 &lt;code&gt;Condition&lt;/code&gt;。正如 Lock 比内置锁提供了更为丰富的功能，Condition 同样比内置条件队列提供了更丰富的功能：在每个锁上可存在多个等待、条件等待可以是可中断的或不可中断的、基于时限的等待，以及公平的或非公平的队列操作。&lt;/p&gt;&#xA;&lt;p&gt;如下代码示例了使用显示的条件变量的有界缓存，分别用 notFull 和 notEmpty 表示 &amp;ldquo;非满&amp;rdquo; 与 &amp;ldquo;非空&amp;rdquo; 两个条件谓词。当缓存为空时，take 将阻塞并等待 notEmpty，此时 put 向 notEmpty 发送信号，可以解除任何在 take 中阻塞的线程。通过将两个条件谓词分开并放到两个等待线程集中，Condition 使其 &lt;strong&gt;更容易满足单次通知的需求&lt;/strong&gt;。它能极大地减少在每次缓存操作中发生的上下文切换与锁请求的次数。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;public class ConditionBoundedBuffer&amp;lt;T&amp;gt; {&#xA;&#x9;protected final Lock lock = new ReentrantLock();&#xA;&#x9;private final Condition notFull = lock.newCondition();  // 条件谓词：count &amp;lt; items.length&#xA;&#x9;private final Condition notEmpty = lock.newCondition();  // 条件谓词：count &amp;gt; 0&#xA;&#x9;private final T[] items = (T[]) new Object[BUFFER_SIZE];&#xA;&#x9;private int tail, head, count;&#xA; &#xA;&#x9;public void put(T x) throws InterruptedException {&#xA;&#x9;&#x9;lock.lock();&#xA;&#x9;&#x9;try {&#xA;&#x9;&#x9;&#x9;// 循环避免过早唤醒&#xA;&#x9;&#x9;&#x9;while (count == items.length) { notFull.await(); }   &#xA;&#x9;&#x9;&#x9;// 阻塞直到满足 notFull 条件谓词&#xA;&#x9;&#x9;&#x9;items[tail] = x;&#xA;&#x9;&#x9;&#x9;if (&amp;#43;&amp;#43;tail == items.length) { tail = 0; }&#xA;&#x9;&#x9;&#x9;&amp;#43;&amp;#43;count;&#xA;&#x9;&#x9;&#x9;notEmpty.signal();&#xA;&#x9;&#x9;} finally {&#xA;&#x9;&#x9;&#x9;lock.unlock();&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA; &#xA;&#x9;public T take() throws InterruptedException {&#xA;&#x9;&#x9;lock.lock();&#xA;&#x9;&#x9;try {&#xA;&#x9;&#x9;&#x9;// 循环避免过早唤醒&#xA;&#x9;&#x9;&#x9;while (count == 0) { notEmpty.await(); }   &#xA;&#x9;&#x9;&#x9;// 阻塞直到满足 notEmpty&#xA;&#x9;&#x9;&#x9;T x = items[head];&#xA;&#x9;&#x9;&#x9;items[head] = null;&#xA;&#x9;&#x9;&#x9;if (&amp;#43;&amp;#43;head == items.length) { head = 0; }&#xA;&#x9;&#x9;&#x9;--count;&#xA;&#x9;&#x9;&#x9;notFull.signal();&#xA;&#x9;&#x9;&#x9;return x;&#xA;&#x9;&#x9;} finally {&#xA;&#x9;&#x9;&#x9;lock.unlock();&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;h3 class=&#34;heading-element&#34; id=&#34;aqs&#34;&gt;&lt;span&gt;AQS&lt;/span&gt;&#xA;  &lt;a href=&#34;#aqs&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt; 抽象的队列式同步器，是许多同步类共同的基类，是一个用于 &lt;strong&gt;构建锁和同步器的框架&lt;/strong&gt;，使用 AQS 可以简单且高效地构造出许多同步器，比如 ReentrantLock、CountDownLatch、Semaphore 等。AQS 解决了在实现同步器时涉及的大量细节问题，基于 AQS 构建同步器可以极大地 &lt;strong&gt;减少实现工作&lt;/strong&gt;，而且也不必处理在多个位置上发生的竞争问题。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/AQS.png&#39; alt=&#34;/images/AQS.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;AQS 负责管理同步器类中的状态 &lt;code&gt;state&lt;/code&gt;，它是一个整数类型的状态信息，可以用于表示 &lt;strong&gt;任意状态&lt;/strong&gt;。例如，ReentrantLock 用它来表示所有者线程已经重复获取该锁的次数，Semaphone 用它表示剩余的许可数量，FutureTask 用它来表示任务的状态（尚未开始、正在运行、已完成以及已取消）。在同步器类中还可以自行管理一些额外的状态变量，比如 ReentrantLock 保存了锁的当前所有者信息，这样就能区分某个获取操作是重入的还是竞争的。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// The synchronization state.  使用 volatile 保证线程可见性&#xA;private volatile int state;&#xA;&#xA;// 返回当前的同步状态&#xA;protected final int getState() { return state; }&#xA;&#xA;// 设置同步状态的值&#xA;protected final void setState(int newState) { state = newState; }&#xA;&#xA;// 原子地（CAS）将同步状态设置为给定值 update，如果当前同步状态的值等于期望值 expect&#xA;protected final boolean compareAndSetState(int expect, int update) {&#xA;    // See below for intrinsics setup to support this&#xA;    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;h4 class=&#34;heading-element&#34; id=&#34;独占访问&#34;&gt;&lt;span&gt;独占访问&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e7%8b%ac%e5%8d%a0%e8%ae%bf%e9%97%ae&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;同时只能允许一个线程执行，例如 ReentrantLock，它的内部类分别实现了以公平（&lt;code&gt;FairSync&lt;/code&gt;）或者非公平（&lt;code&gt;NonfairSync&lt;/code&gt;）获取锁的方式：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 公平锁的同步对象&#xA;static final class FairSync extends Sync {&#xA;    private static final long serialVersionUID = -3000897897090466540L;&#xA;&#xA;    final void lock() { acquire(1); }&#xA;&#xA;&#x9;// 公平版本的 tryAcquire&#xA;    protected final boolean tryAcquire(int acquires) {&#xA;        final Thread current = Thread.currentThread();&#xA;        int c = getState();&#xA;        if (c == 0) {&#xA;            // 和非公平锁相比，这里多了一个判断：是否有线程在等待&#xA;            if (!hasQueuedPredecessors() &amp;amp;&amp;amp;&#xA;                compareAndSetState(0, acquires)) {&#xA;                setExclusiveOwnerThread(current);&#xA;                return true;&#xA;            }&#xA;        }&#xA;        else if (current == getExclusiveOwnerThread()) {&#xA;            int nextc = c &amp;#43; acquires;&#xA;            if (nextc &amp;lt; 0)&#xA;                throw new Error(&amp;#34;Maximum lock count exceeded&amp;#34;);&#xA;            setState(nextc);&#xA;            return true;&#xA;        }&#xA;        return false;&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;// 非公平锁的同步对象&#xA;static final class NonfairSync extends Sync {&#xA;    private static final long serialVersionUID = 7316153563782823691L;&#xA;&#xA;    // 和公平锁相比，这里会尝试使用 CAS 抢锁，成功就返回&#xA;    final void lock() {&#xA;        if (compareAndSetState(0, 1))&#xA;            setExclusiveOwnerThread(Thread.currentThread());&#xA;        else&#xA;            acquire(1);&#xA;    }&#xA;&#xA;    protected final boolean tryAcquire(int acquires) {&#xA;        return nonfairTryAcquire(acquires); // 非公平的 tryAcquire&#xA;    }&#xA;}&#xA;&#xA;/** &#xA;  * Sync 类&#xA;  * Performs non-fair tryLock.  tryAcquire is implemented in&#xA;  * subclasses, but both need nonfair try for trylock method.&#xA;*/&#xA;final boolean nonfairTryAcquire(int acquires) {&#xA;    final Thread current = Thread.currentThread();&#xA;    int c = getState();&#xA;    if (c == 0) {&#xA;        // 没有判断队列中是否有线程在等待&#xA;        if (compareAndSetState(0, acquires)) {&#xA;            setExclusiveOwnerThread(current);&#xA;            return true;&#xA;        }&#xA;    }&#xA;    else if (current == getExclusiveOwnerThread()) {&#xA;        int nextc = c &amp;#43; acquires;&#xA;        if (nextc &amp;lt; 0) // overflow&#xA;            throw new Error(&amp;#34;Maximum lock count exceeded&amp;#34;);&#xA;        setState(nextc);&#xA;        return true;&#xA;    }&#xA;    return false;&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;总结：公平锁和非公平锁只有两处不同：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。&lt;/li&gt;&#xA;&lt;li&gt;非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会 &lt;strong&gt;判断等待队列是否有线程处于等待状态&lt;/strong&gt;，如果有则不去抢锁，乖乖排到后面。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，&lt;strong&gt;都要进入到阻塞队列等待唤醒&lt;/strong&gt;。相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于 &lt;strong&gt;饥饿&lt;/strong&gt; 状态。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;共享访问&#34;&gt;&lt;span&gt;共享访问&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%85%b1%e4%ba%ab%e8%ae%bf%e9%97%ae&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;共享访问指多个线程可同时执行，如 Semaphone、CountDownLatch、CyclicBarrier、ReadWriteLock 等。&lt;/p&gt;&#xA;&lt;p&gt;相比 synchronized 和 ReentrantLock 同时只能允许一个线程访问某个资源，&lt;code&gt;Semaphone&lt;/code&gt; 可以指定多个线程同时访问某个资源，它管理了一组虚拟的许可，它默认构造 AQS 的 state 为 permits。当执行任务的线程数量超出 permits，那么多余的线程将会被放入阻塞队列 Park,并自旋判断 state 是否大于 0。只有当 state 大于 0 的时候，阻塞的线程才能继续执行，此时先前执行任务的线程继续执行 release 方法，release 方法使得 state 的变量会加 1，那么自旋的线程便会判断成功。如此，每次只有最多不超过 permits 数量的线程能自旋成功，便 &lt;strong&gt;限制了执行任务线程的数量&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;CountDownLatch&lt;/code&gt; 允许 count 个线程阻塞在一个地方，&lt;strong&gt;直至所有线程的任务都执行完毕&lt;/strong&gt;。CountDownLatch 也是共享锁的一种实现，它默认构造 AQS 的 state 值为 count。当线程使用 countDown() 方法时,其实使用了tryReleaseShared 方法以 CAS 的操作来减少 state，直至 state 为 0 。当调用 await() 方法的时候，如果 state 不为 0，那就证明任务还没有执行完毕，await() 方法就会一直阻塞，也就是说 await() 方法之后的语句不会被执行。CountDownLatch 会自旋 CAS 判断 state == 0，如果 state == 0 的话，就会释放所有等待的线程，await() 方法之后的语句得到执行。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;CyclicBarrier&lt;/code&gt; 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比CountDownLatch 更加复杂和强大。CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示 &lt;strong&gt;屏障拦截的线程数量&lt;/strong&gt;，每个线程调用 await 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。CyclicBarrier 内部通过一个 count 变量作为计数器，count 的初始值为 parties 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减一。如果 count 值为 0 了，表示最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。CountDownLatch 是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而 CyclicBarrier 更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;非阻塞同步机制&#34;&gt;&lt;span&gt;非阻塞同步机制&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e9%9d%9e%e9%98%bb%e5%a1%9e%e5%90%8c%e6%ad%a5%e6%9c%ba%e5%88%b6&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;h4 class=&#34;heading-element&#34; id=&#34;锁的劣势&#34;&gt;&lt;span&gt;锁的劣势&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e9%94%81%e7%9a%84%e5%8a%a3%e5%8a%bf&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;虽然使用锁可以确保数据在并发访问中的一致性，但独占锁是一项 &lt;strong&gt;悲观&lt;/strong&gt; 技术，如果有多个线程同时请求锁，那么一些线程将被挂起并且在稍后恢复运行。当线程恢复执行时，还必须等待其他线程执行完它们的时间片以后，才能被调度执行。在挂起和恢复线程等过程中存在着很大的开销，并且通常存在着较长时间的 &lt;strong&gt;中断&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;锁定还存在其他一些缺点。当一个线程正在等待锁时，它 &lt;strong&gt;不能做任何其他事情&lt;/strong&gt;。如果一个线程在持有锁的情况下被延迟执行（例如发生了缺页错误、调度延迟，或者其他类似情况），那么所有需要这个锁的线程都无法执行下去。如果被阻塞线程的优先级较高，而持有锁的线程优先级较低，就会产生 &lt;strong&gt;优先级反转&lt;/strong&gt;。即使高优先级的线程可以抢先执行，但仍然需要等待锁被释放，从而导致它的优先级会降至低优先级线程的级别。如果持有锁的线程被永久地阻塞（例如由于出现了无限循环，死锁，活锁或者其他的活跃性故障），所有等待这个锁的线程就永远无法执行下去。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;cas-与原子变量&#34;&gt;&lt;span&gt;CAS 与原子变量&lt;/span&gt;&#xA;  &lt;a href=&#34;#cas-%e4%b8%8e%e5%8e%9f%e5%ad%90%e5%8f%98%e9%87%8f&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;与基于锁的方案相比，非阻塞算法使用 &lt;strong&gt;底层的原子机器指令&lt;/strong&gt;，在设计和实现上都要复杂得多，但它们在可伸缩性和活跃性上却拥有巨大的优势。由于非阻塞算法可以使多个线程在竞争相同的数据时不会发生阻塞，因此它能在粒度更细的层次上进行协调，并且极大地减少调度开销。而且在非阻塞算法中不存在死锁和其他活跃性问题。&lt;/p&gt;&#xA;&lt;p&gt;在针对多处理器操作而设计的处理器中提供了一些特殊指令，用于管理对共享数据的并发访问。在早期的处理器中支持原子的测试并设置（Test-and-Set），获取并递增（Fetch-and-Increment）以及交换等指令，这些指令足以实现各种互斥体，而这些互斥体又可以实现一些更复杂的并发对象。现在几乎所有的现代处理器中都包含了某种形式的 &lt;strong&gt;原子读-改-写指令&lt;/strong&gt;，例如比较并交换（Compare-and-Swap）或者关联加载/条件存储（Load-Linked/Store-Conditional）。操作系统和 JVM 使用这些指令来实现锁和并发的数据结构。&lt;/p&gt;&#xA;&lt;p&gt;当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，其他线程都将失败。然而，失败的线程并 &lt;strong&gt;不会被挂起&lt;/strong&gt;，而是被告知在这次竞争中失败，并可以再次尝试。由于一个线程在竞争 CAS 时失败不会阻塞，因此它可以决定是否重新尝试，或者执行一些恢复操作，或者不执行任何操作。这种灵活性就大大减少了与锁相关的活跃性风险。&lt;/p&gt;&#xA;&lt;p&gt;原子变量比锁的 &lt;strong&gt;粒度更细，量级更轻&lt;/strong&gt;，它将发生竞争的范围缩小到单个变量上。在使用基于原子变量而非锁的算法中，因为不需要挂起或重新调度线程，线程在执行时不易出现延迟，并且如果遇到竞争，也更容易恢复过来。下图给出了在适度/高度竞争的情况下使用锁和原子变量的吞吐量情况。可以看出，在高度竞争的情况下，锁的性能将超过原子变量的性能，但在更真实的竞争情况下，&#xA;原子变量的性能将超过锁的性能。这是因为锁在发生竞争时会挂起线程，从而降低了 CPU 的使用率和共享内存总线上的同步通信量。另一方面，如果使用原子变量，那么发出调用的类负责对竞争进行管理，如果在遇到竞争时立即重试，会导致在激烈竞争的环境下产生更多的竞争。（这就好比在交通拥堵时，交通信号灯能够实现较高的吞吐量；而在低拥堵时，环岛能实现更高的吞吐量。）&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/AtomicInteger.jpg&#39; alt=&#34;/images/AtomicInteger.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;可能有人会觉得原子变量的性能比锁更糟糕，但上图中的高度竞争程度其实有点 &lt;strong&gt;不切实际&lt;/strong&gt;。任何一个真实的程序都不会除了竞争锁或原子变量，其他什么工作都不做。在实际情况中，原子变量在可伸缩性上要高于锁，因为在应对常见的竞争程度时，原子变量的效率会更高。锁和原子变量在不同竞争程度上的性能差异很好地说明了各自的优势和劣势。在中低程度的竞争下，原子变量能提供更高的可伸缩性，而在高强度的竞争下，锁能够更有效地 &lt;strong&gt;避免竞争&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;非阻塞算法&#34;&gt;&lt;span&gt;非阻塞算法&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e9%9d%9e%e9%98%bb%e5%a1%9e%e7%ae%97%e6%b3%95&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;如果在某种算法中，一个线程的失败或挂起不会导致其他线程也失败或挂起，那么这种算法就被称为非阻塞算法。如果在算法的每个步骤中都存在某个线程能够执行下去，那么这种算法也被称为 &lt;strong&gt;无锁算法&lt;/strong&gt;。在非阻塞算法中通常不会出现死锁和优先级反转问题（但可能会出现饥饿和活锁问题，因为在算法中会反复地重试）。&lt;/p&gt;&#xA;&lt;p&gt;在实现相同功能的前提下，非阻塞算法通常比基于锁的算法更为复杂。创建非阻塞算法的关键在于，如何 &lt;strong&gt;将原子修改的范围缩小到单个变量上&lt;/strong&gt;，同时还要维护数据的一致性。栈是最简单的链式数据结构：每个元素仅指向一个元素，并且每个元素也只被一个元素引用。下列代码示例了如何通过原子引用构建线程安全的 ConcurrentStack，可以看出非阻塞算法的特性：如果某项工作的完成具有不确定性，必须重新执行。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;public class ConcurrentStack&amp;lt;E&amp;gt; {&#xA;&#x9;AtomicReference&amp;lt;Node&amp;lt;E&amp;gt;&amp;gt; top = new AtomicReference&amp;lt;Node&amp;lt;E&amp;gt;&amp;gt;(); &#xA;&#xA;&#x9;public void push (E item) {&#xA; &#x9;&#x9;Node&amp;lt;E&amp;gt; newHead = new Node&amp;lt;E&amp;gt;(item);&#xA;&#x9;&#x9;Node&amp;lt;E&amp;gt; oldHead;&#xA;&#x9;&#x9;do {&#xA;&#x9;&#x9;&#x9;oldHead = top.get();&#xA;&#x9;&#x9;&#x9;newHead.next = oldHead;&#xA;&#x9;&#x9;} while(!top.compareAndSet(oldHead, newHead));  &#xA;&#x9;&#x9;/** 如果在开始插入节点时，位于栈顶的节点没有发生变化，那么 CAS 就会成功；&#xA;&#x9;&#x9;如果栈顶节点发生了变化（其他线程插入或者删除了元素），&#xA;&#x9;&#x9;那么 CAS 将会失败，而 push 方法会根据栈的当前状态更新节点，并且再次尝试。**/&#xA;&#x9;}&#xA;&#xA;&#x9;public E pop() {&#xA;&#x9;&#x9;Node&amp;lt;E&amp;gt; oldHead;&#xA;&#x9;&#x9;Node&amp;lt;E&amp;gt; newHead;&#xA;&#x9;&#x9;do {&#xA;&#x9;&#x9;&#x9;oldHead = top.get();&#xA;&#x9;&#x9;&#x9;if (oldHead == null) { return null; }&#xA;&#x9;&#x9;&#x9;newHead = oldHead.next;&#xA;&#x9;&#x9;} while (!top.compareAndSet(oldHead, newHead));&#xA;&#x9;&#x9;return oldHead.item;&#xA;&#x9;}&#xA;&#xA;&#x9;private static class Node&amp;lt;E&amp;gt; {&#xA;&#x9;&#x9;public final E item;&#xA;&#x9;&#x9;public Node&amp;lt;E&amp;gt; next;&#xA;&#xA;&#x9;&#x9;public Node(E item) {&#xA;&#x9;&#x9;&#x9;this.item = item;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;非阻塞算法在栈中的实现很容易，但对于一些更复杂的数据结构，例如队列、散列表或数，则要复杂得多。下列代码展示了 Michael-Scott 提出的非阻塞链表算法（ConcurrentLinkedQueue 中使用的正是该算法），在初始化时就将头节点和尾节点都指向哑节点，当插入一个新的元素时，&lt;strong&gt;需要更新两个指针&lt;/strong&gt;。首先更新当前最后一个元素的 next 指针，将新节点链接到列表队尾，然后更新尾节点，将其指向这个新元素。如果第一个 CAS 成功，但第二个 CAS 失败，那么链表将处于不一致的状态，即使这两个 CAS 都成功了，仍有可能有另外一个线程在两个操作之间访问这个链表。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;public class LinkedQueue&amp;lt;E&amp;gt; {&#xA;&#x9;// 非阻塞链表算法中的插入算法&#xA;&#x9;private static class Node&amp;lt;E&amp;gt; {&#xA; &#x9;&#x9;final E item;&#xA;&#x9;&#x9;final AtomicReference&amp;lt;Node&amp;lt;E&amp;gt;&amp;gt; next;&#xA;&#xA;&#x9;&#x9;public Node(E item, Node&amp;lt;E&amp;gt; next) {&#xA;&#x9;&#x9;&#x9;this.item = item;&#xA;&#x9;&#x9;&#x9;this.next = new AtomicReference&amp;lt;Node&amp;lt;E&amp;gt;&amp;gt;(next);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;private final Node&amp;lt;E&amp;gt; dummy = new Node&amp;lt;E&amp;gt;(null, null); &#xA;&#x9;// 空链表 dummy 哑节点，等同于 sentinel 哨兵节点&#xA;&#x9;private final AtomicReference&amp;lt;Node&amp;lt;E&amp;gt;&amp;gt; head = new AtomicReference&amp;lt;Node&amp;lt;E&amp;gt;&amp;gt;(dummy);&#xA;&#x9;private final AtomicReference&amp;lt;Node&amp;lt;E&amp;gt;&amp;gt; tail = new AtomicReference&amp;lt;Node&amp;lt;E&amp;gt;&amp;gt;(dummy);&#xA;&#xA; &#x9;public boolean put(E item) {&#xA; &#x9;&#x9;Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;E&amp;gt;(item, null);&#xA;&#x9;&#x9;while(true) {&#xA;&#x9;&#x9;&#x9;Node&amp;lt;E&amp;gt; curTail = tail.get();&#xA;&#x9;&#x9;&#x9;Node&amp;lt;E&amp;gt; tailNext = curTail.next.get();&#xA;&#x9;&#x9;&#x9;if (curTail == tail.get()) {  &#xA;&#x9;&#x9;&#x9;&#x9;if (tailNext != null) {  &#xA;&#x9;&#x9;&#x9;&#x9;// 检查链表是否处于中间状态&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tail.compareAndSet(curTail, tailNext);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// 链表处于中间状态（另一个线程正在插入元素），帮助结束其他线程执行的插入元素操作，然后循环重试&#xA;&#x9;&#x9;&#x9;&#x9;} else {   // 链表处于稳定状态&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (curTail.next.compareAndSet(null, newNode)) {  &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// 如果其他线程插队，CAS 失败，会重新进入 while 循环重试&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;tail.compareAndSet(curTail, newNode);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// 第二步 CAS 如果失败，表示这一步已经由其他线程代为完成&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实现非阻塞算法的链表的关键点在于：当队列处于稳定状态时（下图 15-5），尾节点的 next 域将为空，如果队列处于中间状态，那么 tail.next 将为非空。因此，任何线程都能通过 &lt;strong&gt;检查 tail.next 来获取链表当前的状态&lt;/strong&gt;。而且，当链表处于中间状态时，可以通过将尾节点向前移动一个节点，从而结束其他线程正在执行的插入元素操作，并使得链表恢复为稳定状态。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/LinkedQueue.jpg&#39; alt=&#34;/images/LinkedQueue.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在使用 CAS 实现非阻塞算法时，可能会遇到 ABA 问题，即 V 的值首先由 A 变成 B，再由 B 变成 A，却仍然被认为是失败，需要重新执行算法中的某些步骤。对此可以选择同时更新两个值，一个引用和一个版本号，通过在引用上加上 &amp;ldquo;版本号&amp;rdquo; 来避免 ABA 问题。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;java-内存模型&#34;&gt;&lt;span&gt;Java 内存模型&lt;/span&gt;&#xA;  &lt;a href=&#34;#java-%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;h4 class=&#34;heading-element&#34; id=&#34;内存可见性与重排序&#34;&gt;&lt;span&gt;内存可见性与重排序&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%86%85%e5%ad%98%e5%8f%af%e8%a7%81%e6%80%a7%e4%b8%8e%e9%87%8d%e6%8e%92%e5%ba%8f&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;在编译器中生成的指令顺序，可以与源代码中的 &lt;strong&gt;顺序不同&lt;/strong&gt;，此外编译器还会把变量保存在 &lt;strong&gt;寄存器&lt;/strong&gt; 而不是内存中；处理器可以采用乱序或并行的方法来执行指令；缓存可能会改变将写入变量提交到主内存的次序，而且，保存在 &lt;strong&gt;处理器本地缓存&lt;/strong&gt; 中的值，对于其他处理器是不可见的。这些因素都会使得一个线程无法看到变量的最新值，并且会导致其他线程中的内存操作似乎在乱序执行——如果没有使用正确的同步。&lt;/p&gt;&#xA;&lt;p&gt;这些底层技术可以提高程序的执行速度，在单线程环境中不会产生其他影响。在多线程环境中，当多个线程要共享数据时，必须协调它们之间的操作。JVM 依赖程序通过同步操作来找出这些协调操作将在何时发生，并导致很大的性能开销。JMM 规定了 JVM 必须遵守一组&lt;strong&gt;最小保证&lt;/strong&gt;，这组保证规定了对变量的写入操作在何时将对于其他线程可见。JMM 在设计时就在可预测性和程序的易于开发性之间进行了权衡，从而在各种主流的处理器体系架构上能实现高性能的 JVM。&lt;/p&gt;&#xA;&lt;p&gt;在大多数时间里，是没有必要确保每个处理器能够知道其他处理器正在进行的工作，因此处理器会适当放宽存储一致性保证，以换取性能的提升。在架构定义的内存模型中将告诉应用程序可以从内存系统中获得怎样的保证，此外还定义了一些特殊的指令（称为 &lt;strong&gt;内存栅栏&lt;/strong&gt;），当需要共享数据时，这些指令就能实现额外的存储协调保证。为了使 Java 开发人员无须关心不同架构上内存模型之间的差异，Java 还提供了自己的内存模型，并且 JVM 通过在适当的位置上插入内存栅栏来屏蔽在 JMM 与底层平台内存模型之间的差异。&lt;/p&gt;&#xA;&lt;p&gt;调度器可能会采用不恰当的方式来交替执行不同线程的操作，JMM 还使得不同线程看到的操作执行顺序是不同的，各种使操作延迟或者看似乱序执行的不同原因，都可以归为 &lt;strong&gt;重排序&lt;/strong&gt;。在没有正确同步的情况下，即使要推断最简单的并发程序的行为也很困难。比如下列的 &lt;code&gt;PossibleReordering&lt;/code&gt; 可能会输出 （1，0）或（0，1）或（1，1）：线程 B 可以在线程 A 开始之前执行完成，线程 A 也可以在线程 B 开始之前就执行完成，或者二者的操作交替执行。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;public class PossibleReordering {&#xA;&#x9;static int x = 0, y = 0;&#xA;&#x9;static int a = 0, b = 0;&#xA; &#xA;&#x9;public static void main(String[] args) throws InterruptedException {&#xA;&#x9;&#x9;Thread one = new Thread(new Runnable() {&#xA;&#x9;&#x9;&#x9;public void run() {&#xA;&#x9;&#x9;&#x9;&#x9;a = 1;&#xA;&#x9;&#x9;&#x9;&#x9;x = b;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;});&#xA;&#x9;Thread other = new Thread(new Runnable() {&#xA;&#x9;&#x9;public void run() {&#xA;&#x9;&#x9;&#x9;b = 1;&#xA;&#x9;&#x9;&#x9;y = a;&#xA;&#x9;&#x9;}&#xA;&#x9;});&#xA;&#x9;one.start(); other.start();&#xA;&#x9;one.join(); other.join();&#xA;&#x9;System.out.println(&amp;#34;(&amp;#34; &amp;#43; x &amp;#43; &amp;#34;,&amp;#34; &amp;#43; y &amp;#43; &amp;#34;)&amp;#34;);&#xA;&#x9;}&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;奇怪的是，PossibleReordering 还可以输出（0,0）。下图给出了导致这种情况的重排序过程。如果没有同步，那么推断出执行顺序将是非常困难的，而要确保在程序中正确地使用同步却是非常容易的。同步将 &lt;strong&gt;限制编译器、运行时和硬件对内存操作重排序&lt;/strong&gt; 的方式，从而在实施重排序时不会破坏 JMM 提供的可见性保证。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/reordering.jpg&#39; alt=&#34;/images/reordering.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;java-内存模型-1&#34;&gt;&lt;span&gt;Java 内存模型&lt;/span&gt;&#xA;  &lt;a href=&#34;#java-%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b-1&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;JMM 为程序中所有的操作定义了一个偏序关系，称之为 &lt;code&gt;Happens-Before&lt;/code&gt;。要想保证执行操作 B 的线程看到操作 A 的结果（无论 A 和 B 是否在同一个线程中执行），那么在 A 和 B 之间必须满足 Happens-Before 关系。如果两个操作之间缺乏 Happens-Before 关系，那么 JVM 可以对它们任意地重排序。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Happens-Before 的规则包括：&lt;/p&gt;&#xA;&lt;p&gt;程序顺序规则：如果程序中操作 A 在操作 B 之前，那么在线程中 A 操作将在 B 操作之前执行。&lt;/p&gt;&#xA;&lt;p&gt;监视器锁规则：在监视器锁上的解锁操作必须在同一个监视器锁上的加锁操作之前执行。&lt;/p&gt;&#xA;&lt;p&gt;volatile 变量规则：对 volatile 变量的写入操作必须在对该变量的读操作之前执行。&lt;/p&gt;&#xA;&lt;p&gt;线程启动规则：在线程上对 Thread.start 的调用必须在该线程中执行任何操作之前执行。&lt;/p&gt;&#xA;&lt;p&gt;线程结束规则：线程中的任何操作都必须在其他线程检测到该线程已经结束之前执行，或者从 Thread.join 中成功返回，或者在调用Thread.isAlive 时返回 false。&lt;/p&gt;&#xA;&lt;p&gt;中断规则：当一个线程在另一个线程上调用 interrupt 时，必须在被中断线程检测到 interrupt 调用之前执行（通过抛出 InterruptedException, 或者调用 isInterrupted 和 interrupted）。&lt;/p&gt;&#xA;&lt;p&gt;终结器规则：对象的构造函数必须在启动该对象的终结器之前执行完成。&lt;/p&gt;&#xA;&lt;p&gt;传递性：如果操作 A 在操作 B 之前执行，并且操作 B 在操作 C 之前执行，那么操作 A 必须在操作 C 之前执行。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;当两个线程使用同一个锁进行同步时，它们之间的 Happens-Before 关系如下图所示。由于 A 释放了锁 M，并且 B 随后获得了锁 M，因此 A 中所有在释放锁之前的操作，也就位于 B 中请求锁之后的所有操作之前。如果这两个线程是在 &lt;strong&gt;不同的锁&lt;/strong&gt; 上进行同步的，那么久不能推断它们之间的动作顺序，因为在这两个线程的操作之间并不存在 Happens-Before 关系。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/happens-before.jpg&#39; alt=&#34;/images/happens-before.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;由于 Happens-Before 的排序功能很强大，因此有时候可以 &amp;ldquo;&lt;strong&gt;借助&lt;/strong&gt;&amp;rdquo; 现有同步机制的可见性属性。在 FutureTask 中就说明了如何使用这种 &amp;ldquo;借助&amp;rdquo; 技术，它自己维护了计算的结果，当一个线程调用 set 来保存结果并且另一个线程调用 get 来获取该结果时，这两个线程最好按照 Happens-Before 进行排序。这可以通过将执行结果的引用声明为 volatile 类型来实现，但利用现有的同步机制可以更容易地实现相同的功能。下列为保存和获取 result 时调用的 innerGet 与 innerSet 方法：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;private final class Sync extends AbstractQueuedSynchronizer {&#xA;&#x9;private static final int RUNNING = 1, RAN =2, CANCELLED = 4;&#xA;&#x9;private V result;&#xA;&#x9;private Exception exception;&#xA; &#xA;&#x9;void innerSet(V v) {&#xA;&#x9;&#x9;while(true) {&#xA;&#x9;&#x9;&#x9;int s = getState();&#xA;&#x9;&#x9;&#x9;if (ranOrCancelled(s)) { return; }&#xA;&#x9;&#x9;&#x9;if (compareAndSetState(s, RAN)) { break; }&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;result = v;&#xA;&#x9;&#x9;releaseShare(0);  // 在 tryReleaseShared 之前写入 result&#xA;&#x9;&#x9;done();&#xA;&#x9;}&#xA; &#xA;&#x9;// 通过在 tryReleaseShared 之前写入 result，在 acquireShared 之后读取 result，&#xA;&#x9;// 来确保 innerSet 中的写入操作会在 innerGet 中的读取操作之前执行&#xA;&#x9;V innerGet() throws InterruptedException, ExecutionException {&#xA;&#x9;&#x9;acquireSharedInterruptibly(0);  // 在 acquireShared 之后读取 result&#xA;&#x9;&#x9;if (getState() == CANCELLED) { throw new CancellationException(); }&#xA;&#x9;&#x9;if (exception != null) { throw new ExecutionException(exception); }&#xA;&#x9;&#x9;return result;&#xA;&#x9;}&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码使用了一种现有的 Happens-Before 顺序来确保对象的可见性，所以被称为 &amp;ldquo;借助&amp;rdquo;。这项技术很 &lt;strong&gt;容易出错&lt;/strong&gt;，因此要谨慎使用，只有当需要最大限度地提升某些类（例如 ReentrantLock）的性能时，才应该使用这项技术。在类库中提供的其他 Happens-Before 排序包括：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将一个元素放入一个线程安全容器的操作将在另一个线程从该容器中获得这个元素的操作之前执行。&lt;/li&gt;&#xA;&lt;li&gt;在 CountDownLatch 上的倒数操作将在线程从闭锁上的 await 方法中返回之前执行。&lt;/li&gt;&#xA;&lt;li&gt;释放 Semaphone 许可的操作将在从该 Semaphone 上获得一个许可之前执行。&lt;/li&gt;&#xA;&lt;li&gt;Future 表示的任务的所有操作将在从 Future.get 中返回之前执行。&lt;/li&gt;&#xA;&lt;li&gt;向 Executor 提交一个 Runnable 或 Callable 的操作将在任务开始执行之前执行。&lt;/li&gt;&#xA;&lt;li&gt;一个线程到达 CyclicBarrier 或 Exchanger 的操作将在其他到达该栅栏或交换点的线程被释放之前执行。如果 CyclicBarrier使用一个栅栏操作，那么到达栅栏的操作将在栅栏操作之前执行，而栅栏操作又会在线程从栅栏中释放之前执行。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Java：异常处理与日志记录</title>
      <link>https://hoffmanzheng.github.io/2021/java-exception-log/</link>
      <pubDate>Wed, 24 Mar 2021 13:19:47 +0100</pubDate>
      <guid>https://hoffmanzheng.github.io/2021/java-exception-log/</guid>
      <category domain="https://hoffmanzheng.github.io/categories/study-notes/">Study Notes</category>
      <description>&lt;p&gt;在开发 Java 项目中通常依赖 Eclipse/IDEA 等集成开发工具的 Debug 调试来追踪解决 Bug，而在没有调试工具的测试、生产环境（一般也不允许远程调试）往往通过日志的轨迹 &lt;strong&gt;快速定位并解决线上问题&lt;/strong&gt;。 但如果日志输出不好，不仅无法辅助定位问题反而可能会影响到程序的运行性能和稳定性。&lt;/p&gt;&#xA;&lt;p&gt;本篇将结合 &lt;a href=&#34;https://developer.aliyun.com/topic/java20&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;阿里巴巴《Java 开发手册（嵩山版）》&lt;/a&gt;、 &lt;a href=&#34;https://logging.apache.org/log4j/2.x/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Log4j 2.x 官方文档&lt;/a&gt;、 &lt;a href=&#34;https://www.overops.com/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Takipi 日志相关文章&lt;/a&gt; 讲解在项目中如何优雅地处理异常以及高效且有效地记录日志。&lt;/p&gt;&#xA;&lt;h1 class=&#34;heading-element&#34; id=&#34;java-的异常处理&#34;&gt;&lt;span&gt;Java 的异常处理&lt;/span&gt;&#xA;  &lt;a href=&#34;#java-%e7%9a%84%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&lt;h3 class=&#34;heading-element&#34; id=&#34;错误码&#34;&gt;&lt;span&gt;错误码&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e9%94%99%e8%af%af%e7%a0%81&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://developer.aliyun.com/topic/java20&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;阿里巴巴《Java 开发手册（嵩山版）》&lt;/a&gt; 中有关错误码给出了以下几点指导：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;错误码就像康熙字典中的生僻字一样，用词似乎精准，但是字典不容易随身携带并且简单易懂。1）错误码必须能够快速知晓 &lt;strong&gt;错误来源&lt;/strong&gt;，可快速判断是谁的问题。 2）错误码必须能够进行清晰地比对（代码中容易 equals）。 3） 错误码有利于团队快速对错误原因达到 &lt;strong&gt;一致认知&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;错误码分成两个部分：错误产生来源 + 四位数字编号 ，可参考手册中的附表（避免随意定义新的错误码），用于快速溯源。将来源于客户、当前系统、第三方服务的错误快速 &lt;strong&gt;区分&lt;/strong&gt;。在无法具体确定的错误场景中，可直接使用 &lt;strong&gt;宏观错误码&lt;/strong&gt;，比如 A0001（用户端错误）、B0001（系统执行出错）、C0001（调用第三方服务出错）&lt;/li&gt;&#xA;&lt;li&gt;错误码不能直接输出给用户作为提示信息使用。堆栈（stack_trace）、错误信息（error_message）、错误码（ error_code）、提示信息（ user_tip）是一个有效关联并互相转义的和谐整体，但是 &lt;strong&gt;请勿互相越俎代庖&lt;/strong&gt;。错误码之外的业务独特信息由 error_message 来承载，而不是让错误码本身涵盖过多具体业务属性&lt;/li&gt;&#xA;&lt;li&gt;在获取第三方服务错误码时，向上抛出允许 &lt;strong&gt;本系统转义&lt;/strong&gt;，由 C 转为 B，并且在错误信息上带上原有的第三方错误码。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;异常处理&#34;&gt;&lt;span&gt;异常处理&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://developer.aliyun.com/topic/java20&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;阿里巴巴《Java 开发手册（嵩山版）》&lt;/a&gt; 中有关异常处理给出了以下几点指导：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;异常设计的初衷是解决程序运行中的各种意外情况，而不是做流程或条件控制，且异常的处理效率比条件判断方式要低很多。&lt;/li&gt;&#xA;&lt;li&gt;非受检异常如 RuntimeException、NullPointerException 等不应该通过 catch 的方式来处理，而是自行使用条件判断。&lt;/li&gt;&#xA;&lt;li&gt;尽可能 &lt;strong&gt;区分异常类型&lt;/strong&gt;，再做对应的异常处理。定义异常时区分 unckecked / checked 异常，避免直接抛出 &lt;code&gt;new RuntimeException()&lt;/code&gt; 或是 Exception / Throwable，应使用 &lt;strong&gt;有业务含义&lt;/strong&gt; 的自定义异常。&lt;/li&gt;&#xA;&lt;li&gt;如果不想处理异常，可以将该异常抛出给它的调用者。最外层的业务使用者，必须处理异常，将其 &lt;strong&gt;转化&lt;/strong&gt; 为用户可以理解的内容。在事务场景中，应注意在 catch 后 &lt;strong&gt;手动回滚&lt;/strong&gt; 事务。&lt;/li&gt;&#xA;&lt;li&gt;finally 块必须对资源对象、流对象进行关闭，推荐使用 &lt;code&gt;try-with-resources&lt;/code&gt; 方式。在 finally 中禁止使用 return，finally 中的 return 会无情地屏蔽掉 try 中的 return 语句。&lt;/li&gt;&#xA;&lt;li&gt;方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加 &lt;strong&gt;注释充分说明什么情况下会返回 null 值&lt;/strong&gt;。必须考虑到远程调用失败、 序列化失败、运行时异常等场景返回 null 的情况。&lt;/li&gt;&#xA;&lt;li&gt;防止 &lt;code&gt;NullPointerException&lt;/code&gt; 是程序员的基本修养，注意 NPE 产生的场景：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;返回类型为基本数据类型， return 包装数据类型的对象时，自动拆箱有可能产生 NPE。&#xA;反例： public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。&lt;/li&gt;&#xA;&lt;li&gt;数据库的查询结果可能为 null。&lt;/li&gt;&#xA;&lt;li&gt;集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。&lt;/li&gt;&#xA;&lt;li&gt;远程调用返回对象时，一律要求进行空指针判断，防止 NPE。&lt;/li&gt;&#xA;&lt;li&gt;对于 Session 中获取的数据，建议进行 NPE 检查，避免空指针。&lt;/li&gt;&#xA;&lt;li&gt;级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;统一的异常处理&#34;&gt;&lt;span&gt;统一的异常处理&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e7%bb%9f%e4%b8%80%e7%9a%84%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;对于不可避免需要处理的各种异常，代码中就会出现大量的 try&amp;hellip; catch&amp;hellip; finally&amp;hellip; 代码块，不仅有大量的代码冗余，还影响代码的可读性。但异常还是要处理的，那么如何优雅地处理各种异常呢。&lt;/p&gt;&#xA;&lt;p&gt;在写测试用例的时候体验过 JUnit 的 Assert 带给我们的丝滑，可以模仿其写一个断言类，&lt;strong&gt;使用 asset 断言来代替日常的异常 throw&lt;/strong&gt;，在断言失败时会调用抛出异常的接口。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/asset-replace-throw.jpg&#39; alt=&#34;/images/asset-replace-throw.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;将错误码和异常信息封装在枚举中，这样就不用每一种异常都单独定义一个异常类了。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/exception-enum.jpg&#39; alt=&#34;/images/exception-enum.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;最终的业务逻辑在判断处理异常时就会变得非常简洁了：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;ExceptionEnum.CLIENT_INVALID_INPUT.assertNotNull(null);&#xA;ExceptionEnum.CLIENT_INVALID_INPUT.assertNotNull(new Object());&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;至于统一的异常处理，可以参考使用下 Spring 提供的 &lt;code&gt;@ExceptionHandler&lt;/code&gt; 。&lt;/p&gt;&#xA;&lt;h1 class=&#34;heading-element&#34; id=&#34;java-的日志记录&#34;&gt;&lt;span&gt;Java 的日志记录&lt;/span&gt;&#xA;  &lt;a href=&#34;#java-%e7%9a%84%e6%97%a5%e5%bf%97%e8%ae%b0%e5%bd%95&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&lt;h3 class=&#34;heading-element&#34; id=&#34;日志组件的选择&#34;&gt;&lt;span&gt;日志组件的选择&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%97%a5%e5%bf%97%e7%bb%84%e4%bb%b6%e7%9a%84%e9%80%89%e6%8b%a9&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;纵览 Java Log 的发展历程：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Log4j（作者Ceki Gülcü）出来时就等到了广泛的应用（注意这里是直接使用），是 Java 日志事实上的标准，并成为了 Apache 的项目&lt;/li&gt;&#xA;&lt;li&gt;Apache 要求把 Log4j 并入到 JDK，SUN 拒绝，并在 JDK1.4 版本后增加了 JUL（java.util.logging）&lt;/li&gt;&#xA;&lt;li&gt;毕竟是 JDK 自带的，JUL 也有很多人用。同时还有其他日志组件，如 SimpleLog 等。这时如果有人想换成其它日志组件，如 Log4j 换成 JUL，因为 API 完全不同，就需要改动代码。&lt;/li&gt;&#xA;&lt;li&gt;Apache 见此，开发了 JCL（Jakarta Commons Logging），即 commons-logging-xx.jar。它只提供一套 &lt;strong&gt;通用的日志接口 API&lt;/strong&gt;，并不提供日志的实现。很好的设计原则嘛，依赖抽象而非实现。这样应用程序可以在运行时选择自己想要的日志实现组件。&lt;/li&gt;&#xA;&lt;li&gt;这样看上去也挺美好的，但是 Log4j 的作者觉得 JCL 不好用，自己开发出 slf4j，它跟 JCL 类似，本身不替供日志具体实现，只对外提供接口或门面。目的就是为了替代 JCL。同时，还开发出 Logback，一个比 Log4j 拥有 &lt;strong&gt;更高性能&lt;/strong&gt; 的组件，目的是为了替代 Log4j。&lt;/li&gt;&#xA;&lt;li&gt;Apache 参考了 Logback 并做了一系列优化，推出了log4j 2&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;因此现在市面上常用的日志组件有：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;日志框架&lt;/th&gt;&#xA;          &lt;th&gt;介绍&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;commons-logging&lt;/td&gt;&#xA;          &lt;td&gt;Apache 提供的日志门面接口，已停止更新，现在已经不太流行了&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;slf4j&lt;/td&gt;&#xA;          &lt;td&gt;Simple Logging Facade for Java，简单日志门面接口，不包含日志实现，允许用户根据喜好接入不同的日志实现&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Log4j&lt;/td&gt;&#xA;          &lt;td&gt;Apache 的一个开源日志框架，市占率最多，但在 15 年 08 月被宣布停止维护，推荐升级到 log4j 2&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Log4j 2&lt;/td&gt;&#xA;          &lt;td&gt;Log4j 的升级产品，不兼容 Log4j&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Logging&lt;/td&gt;&#xA;          &lt;td&gt;Java 自带的日志工具类，java.util.logging 包，现在基本没什么人用了&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Logback&lt;/td&gt;&#xA;          &lt;td&gt;Slf4j 的原生实现框架，提供了对 Log4j 的改进，速度更快，所需内存更少&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;推荐使用门面模式的日志框架，有利于维护各个类统一的日志处理方式。&lt;a href=&#34;https://developer.aliyun.com/topic/java20&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;阿里巴巴《Java 开发手册（嵩山版）》&lt;/a&gt; 对此的代码规范如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/manual-log-component.png&#39; alt=&#34;image-20210326174344710&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在比较关注性能的地方，可以选择 Logback 或者自己实现高性能的 Logging API 更合适，在已经使用了 Log4j 的项目中，如果没有发现问题，则可以继续使用 Log4j2，如果不想有依赖则可以使用 java.util.logging 或者框架容器已经提供的日志接口。&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;日志的配置&#34;&gt;&lt;span&gt;日志的配置&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%97%a5%e5%bf%97%e7%9a%84%e9%85%8d%e7%bd%ae&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;h4 class=&#34;heading-element&#34; id=&#34;日志级别&#34;&gt;&lt;span&gt;日志级别&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%97%a5%e5%bf%97%e7%ba%a7%e5%88%ab&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;日志级别&lt;/th&gt;&#xA;          &lt;th&gt;规范和说明&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;DEBUG&lt;/td&gt;&#xA;          &lt;td&gt;主要输出调试性质的内容如：参数信息、调试细节、返回值等。用于开发、测试，应尽可能详尽，起到调试的作用&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;INFO&lt;/td&gt;&#xA;          &lt;td&gt;记录系统关键信息，旨在保留系统正常工作期间的关键运行指标，方便日常运维工作以及错误回溯时上下文场景的复现。建议在项目完成后，在测试环境将日志级别调成 INFO，验证日志是否达到预期&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WARN&lt;/td&gt;&#xA;          &lt;td&gt;主要输出警告性质的内容，这些内容应该是可以预知且有规划的，比如某个方法参数不满足条件等&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;ERROR&lt;/td&gt;&#xA;          &lt;td&gt;主要针对一些不可预知的信息，诸如：错误、异常等，比如在 catch 中抓获的网络通信、数据库连接异常。在带有错误、异常对象的数据时，需要将该对象一并输出&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;由于 INFO 及 DEBUG 日志打印量远大于 ERROR，出于性能的考虑，如果代码为核心代码，执行频率非常高，务必推敲日志设计是否合理，是否需要下调为 DEBUG 级别日志。&lt;/p&gt;&#xA;&lt;p&gt;一般来说，WARN 级别代表可恢复的异常，此次失败 &lt;strong&gt;不影响下次业务的执行&lt;/strong&gt;，不会短信报警。ERROR 级别会有短信甚至电话报警，意味着系统中发生了非常严重的问题，&lt;strong&gt;必须马上有人处理&lt;/strong&gt;，比如数据库不可用，系统的关键业务流程走不下去等等。不区分问题的重要程度，只要有问题就 ERROR 记录下来是非常 &lt;strong&gt;不负责任&lt;/strong&gt; 的行为。如果不分轻重缓急一律 ERROR 对待，就会徒增报错的频率，久而久之，运维人员对错误报警就不会那么在意，这个警报也就失去了原始的意义。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://developer.aliyun.com/topic/java20&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;阿里巴巴《Java 开发手册（嵩山版）》&lt;/a&gt; 在日志级别方面的规范要求有：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;【推荐】谨慎地记录日志。生产环境 &lt;strong&gt;禁止&lt;/strong&gt; 输出 debug 日志；有选择地输出 info 日志；如果使用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。&lt;/p&gt;&#xA;&lt;p&gt;说明：大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？&lt;/p&gt;&#xA;&lt;p&gt;【推荐】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出 error 级别，&lt;strong&gt;避免频繁报警&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;说明：注意日志输出的级别，error 级别只记录系统逻辑出错、异常或者重要的错误信息。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;日志的配置-1&#34;&gt;&lt;span&gt;日志的配置&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%97%a5%e5%bf%97%e7%9a%84%e9%85%8d%e7%bd%ae-1&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;&lt;a href=&#34;https://logging.apache.org/log4j/2.x/manual/configuration.html&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Log4j 2.x 配置文档&lt;/a&gt; 中详细地介绍了如何通过配置文件来管理日志行为。在项目启动的时候，Log4j 会在 classpath 中搜索配置文件，然后使用对应的配置工厂 &lt;code&gt;ConfigurationFactory&lt;/code&gt; 来配置 Logger。如果没有找到配置文件，则将会使用默认的配置。与默认配置等效的配置文件会看起来像：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&#xA;&amp;lt;Configuration status=&amp;#34;WARN&amp;#34;&amp;gt;&#xA;  &amp;lt;Appenders&amp;gt;&#xA;    &amp;lt;Console name=&amp;#34;Console&amp;#34; target=&amp;#34;SYSTEM_OUT&amp;#34;&amp;gt;   // 日志输出到 console&#xA;      &amp;lt;PatternLayout pattern=&amp;#34;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&amp;#34;/&amp;gt;    // 日志格式&#xA;    &amp;lt;/Console&amp;gt;&#xA;  &amp;lt;/Appenders&amp;gt;&#xA;  &amp;lt;Loggers&amp;gt;&#xA;    &amp;lt;Root level=&amp;#34;error&amp;#34;&amp;gt;    // 默认根日志的级别为 error&#xA;      &amp;lt;AppenderRef ref=&amp;#34;Console&amp;#34;/&amp;gt;&#xA;    &amp;lt;/Root&amp;gt;&#xA;  &amp;lt;/Loggers&amp;gt;&#xA;&amp;lt;/Configuration&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在对日志配置前理解日志的工作机制是至关重要的，在没有理解 &lt;a href=&#34;https://logging.apache.org/log4j/2.x/manual/architecture.html&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Log4j 体系结构&lt;/a&gt; 的情况下去配置日志将会备受挫折。&lt;/p&gt;&#xA;&lt;p&gt;日志可以配置多个 logger 元素，logger 元素必须有一个名字属性，也可以单独指定 additivity（默认 true），和 level（默认 ERROR）。如果想对某个 Logger 设置单独的日志级别，可以在配置文件中添加一个新的日志定义，如果想避免这个 Logger 下产生的日志重复提交给上级的根日志，可以将 &lt;code&gt;additivity&lt;/code&gt; 设置为 false。&lt;/p&gt;&#xA;&lt;p&gt;对 Log4j 2 一些特性如 Appenders，Filters，Layout 等的配置可以参考 ：&lt;a href=&#34;https://logging.apache.org/log4j/2.x/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Log4j 2 官方文档&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 class=&#34;heading-element&#34; id=&#34;日志打印最佳实践&#34;&gt;&lt;span&gt;日志打印最佳实践&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%97%a5%e5%bf%97%e6%89%93%e5%8d%b0%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&lt;h4 class=&#34;heading-element&#34; id=&#34;记录日志的时机&#34;&gt;&lt;span&gt;记录日志的时机&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e8%ae%b0%e5%bd%95%e6%97%a5%e5%bf%97%e7%9a%84%e6%97%b6%e6%9c%ba&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;在看线上日志的时候，可曾陷入过有效日志被 &lt;strong&gt;大量无意义&lt;/strong&gt; 的日志信息淹没的日志泥潭？&lt;/p&gt;&#xA;&lt;p&gt;回归初衷，记录的日志大致有以下三种用途：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;功能&lt;/th&gt;&#xA;          &lt;th&gt;用途&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;问题追踪&lt;/td&gt;&#xA;          &lt;td&gt;辅助排查和定位线上问题，优化程序运行性能&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;状态监控&lt;/td&gt;&#xA;          &lt;td&gt;通过日志分析，监控系统的运行状态&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;安全审计&lt;/td&gt;&#xA;          &lt;td&gt;安全审计，发现未授权的操作&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;因此，记录日志的合适时机有以下几种：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;编程语言提示异常：流行框架的异常报错，是质量非常高的，应当适当记录，结合业务情况使用 warn 或者 error 级别&lt;/li&gt;&#xA;&lt;li&gt;业务流程预期不符：取决于开发人员判断能否容忍情形发生，常见的有：外部参数不正确，数据处理返回值不在合理范围内等&lt;/li&gt;&#xA;&lt;li&gt;组件关键动作：核心数据表增删改查，核心组件运行等，建议记录 info 级别，如果日志频度高或打印量特别大，可以提炼关键点 info 记录，其余酌情考虑 debug 级别&lt;/li&gt;&#xA;&lt;li&gt;系统初始化：核心模块或者组件初始化过程中往往依赖一些关键配置，根据参数不同会提供不一样的服务，务必在这里记录 info 日志，打印出参数以及启动完成态服务表述&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 class=&#34;heading-element&#34; id=&#34;日志打印最佳实践-1&#34;&gt;&lt;span&gt;日志打印最佳实践&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e6%97%a5%e5%bf%97%e6%89%93%e5%8d%b0%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5-1&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&lt;ol&gt;&#xA;&lt;li&gt;使用门面接口定义日志对象，符合抽象编程思想方便切换。最好将日志对象定义为 &lt;code&gt;static final&lt;/code&gt;，因为通过调用相同日志名称的 &lt;code&gt;getLogger&lt;/code&gt; 将会返回相同的日志实例，但每次实例化一个新的日志对象是一个相当昂贵的操作&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;import org.slf4j.Logger;&#xA;import org.slf4j.LoggerFactory;&#xA;&#xA;private static final Logger logger = LoggerFactory.getLogger({ClassName}.class);&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;虽然 Apache 在 &lt;a href=&#34;https://logging.apache.org/log4j/2.x/manual/usage.html&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Log4j 2.x 使用文档&lt;/a&gt; 中花了较大的篇幅阐明：logger name 会在 Logger 创建的时候被指定，当 log 方法被调用时日志事件却会反映出调用方的类名，这可能会与 Logger 的创建类有所 &lt;strong&gt;不同&lt;/strong&gt;。但在文末，其指出在日志中打印出 location information（class name, method name and line number）会产生较大的 &lt;strong&gt;性能损失&lt;/strong&gt;，如果方法名和行数不重要的话，最好 &lt;strong&gt;确保每个类拥有它自己的 Logger&lt;/strong&gt;，这样 logger name 就能真实反映出执行 logging 的类。根据 &lt;a href=&#34;https://www.overops.com/blog/how-to-instantly-improve-your-java-logging-with-7-logback-tweaks/&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Takipi&lt;/a&gt; 的测试结果，如果在日志中加入 Class 信息，性能会相比 Logback 的默认配置 &lt;strong&gt;下降 6 成左右&lt;/strong&gt;，因此如果一定要打印类信息，可以考虑用类名来命名 Logger。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/log-class-pattern.png&#39; alt=&#34;log-class-pattern&#34;&gt;&lt;/p&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;使用参数化形式 {} 占位，[] 进行参数隔离，可读性好。一看就知道 [] 里面是输出的动态参数。且不要在日志中调用对象的方法获取值，除非确保该对象肯定不为 null，否则很有可能会因为日志的问题而导致应用产生 &lt;strong&gt;空指针&lt;/strong&gt; 异常。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;logger.debug(&amp;#34;invalid Param [{}]&amp;#34;, &amp;#34;\&amp;#34;\&amp;#34;&amp;#34;);&#xA;&#xA;2021-03-25 16:38:03,408 DEBUG [StaffInfoService.java:520] : invalid Param [&amp;#34;&amp;#34;]&#xA;    &#xA;log.info(&amp;#34;load student (id=[{}]), name: [{}]&amp;#34;, id, student.getName());  // 不推荐&#xA;&#xA;log.info(&amp;#34;load student (id=[{}]), student: [{}]&amp;#34;, id, student);  // 推荐&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果使用了字符串拼接的方式输出日志，即使 DEBUG 级别的日志在生产环境中不会输出到文件中，也可能带来不小的开销，在 &lt;a href=&#34;https://logging.apache.org/log4j/2.x/performance.html&#34; target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Log4j 2.x 性能文档&lt;/a&gt; 中就对比了字符串拼接和参数化信息两者的性能差异。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;log.debug(&amp;#34;Entry number: [{}] is [{}]&amp;#34;, i, entry[i]);&#xA;// 完全格式化的信息字符串在 logger 的 DEBUG 级别没有启用时不会被构建&#xA;&#xA;// 如果没有这个 API，就需要三行代码来实现同样的功能&#xA;// 仍在使用不支持{}模板的 Log4j 1.x 或 Apache Commons Logging 组件的公司都会有在日志输出前加判断的编码规范&#xA;if (logger.isDebugEnabled()) {&#xA;    log.debug(&amp;#34;Entry number: &amp;#34; &amp;#43; i &amp;#43; &amp;#34; is &amp;#34; &amp;#43; entry[i].toString());&#xA;}&#xA;&#xA;// 即使在没有启用 DEBUG 的生产环境也会将变量转换为字符串进行拼接，产生性能开销&#xA;log.debug(&amp;#34;Entry number: &amp;#34; &amp;#43; i &amp;#43; &amp;#34; is &amp;#34; &amp;#43; entry[i].toString());&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;如果启用了 DEBUG，则日志信息需要在记录点被格式化。异步记录日志时，参数可能在后台线程记录前就在应用线程中被改变。这将在日志文件中展现出错误的信息。为了防止这种情况，Log4j 2, log4j 1.2, Logback 选择在将信息传递给后台线程之 &lt;strong&gt;前&lt;/strong&gt;  就格式化信息文本。&lt;/li&gt;&#xA;&lt;li&gt;这项安全举措却产生了性能开销。下图对比了使用不同日志组件记录带参数信息时的吞吐量。JUL（java.util.logging）没有内置的异步处理器，它的 &lt;code&gt;MemoryHandler&lt;/code&gt; 并没有采取上述的安全策略，而只是保留了原始参数对象的引用。因此它在单线程下非常快，然而在更多的应用线程并发记录日志时，&lt;strong&gt;锁内容的开销超过了它的收益&lt;/strong&gt;。在吞吐量的绝对值上，Log4j 2 异步日志想比其他的日志框架表现得更出色，但注意信息格式化的开销将会随着参数数量的上升而急剧增加。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/log-parameterized-message.png&#39; alt=&#34;log-parameterized-message&#34;&gt;&lt;/p&gt;&#xA;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;禁用标准输出 &lt;code&gt;System.out.println&lt;/code&gt; 和 &lt;code&gt;System.err.println&lt;/code&gt; 记录日志。因为这个只会打印到控制台，而不会记录到日志文件中，不方便管理日志。此外，标准输出不会显示类名和行号信息，很难定位日志内容和打印的位置，根本无法排查问题。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;// e.printStackTrace() 其实也是通过 System.err 来进行输出的&#xA;public void printStackTrace() {&#xA;    printStackTrace(System.err);&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;5&#34;&gt;&#xA;&lt;li&gt;建议记录下所有未被捕获的日志，其实抛出异常有开销，记录异常同样会带来一定的开销，主要原因是 &lt;code&gt;Throwable&lt;/code&gt; 类的 &lt;code&gt;fillInStackTrace&lt;/code&gt; 方法默认是同步的。一般使用 logger.error 都会打出异常的堆栈，如果对吞吐量有一定的要求，可以考虑覆盖该方法，去掉 &lt;code&gt;synchronized native&lt;/code&gt;，直接返回实例本身。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;public synchronized Throwable fillInStackTrace() {&#xA;        if (stackTrace != null ||&#xA;            backtrace != null /* Out of protocol state */ ) {&#xA;            fillInStackTrace(0);&#xA;            stackTrace = UNASSIGNED_STACK;&#xA;        }&#xA;        return this;&#xA;    }&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;6&#34;&gt;&#xA;&lt;li&gt;异步日志：应用线程捕获所有需要的信息放入队列，后台线程随后会处理这些信息。只要队列足够大，应用线程应该只需花费非常少的时间在调用日志上并很快返回到业务逻辑中。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;性能更高的 Log4j 2 Async Logger 使用了 &lt;strong&gt;无锁&lt;/strong&gt; 的数据结构，而不是 Log4j 1.2 和 Log4j 2 Async Appender 所用的 &lt;code&gt;ArrayBlockingQueue&lt;/code&gt;，这样多线程应用就不会在入队日志事件时经历阻塞。&lt;/li&gt;&#xA;&lt;li&gt;下图展示了一个无锁数据结构在多线程场景下对吞吐量产生的影响：Log4j 2 Async Logger 随着线程数的提升表现出了更好的 &lt;strong&gt;可伸缩性&lt;/strong&gt;。其他的日志组件由于承受锁的开销，在更多线程的场景下只获得了不变或更低的吞吐量。需要注意的是，图中展示出的峰值吞吐量，一旦队列满了 appender 就需要等待，会导致吞吐量出现了下降的情况。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#39;https://hoffmanzheng.github.io/images/log4j2-async-logger.png&#39; alt=&#34;log4j 2-async-logger&#34;&gt;&lt;/p&gt;&#xA;&lt;ol start=&#34;7&#34;&gt;&#xA;&lt;li&gt;在分布式系统中，一个完整请求的日志并 &lt;strong&gt;不只在一个应用&lt;/strong&gt; 的日志文件中，而是分散在不同服务器上不同应用节点的日志文件中。所以最好在每个子系统的日志中附上一个 UUID 标识，便于后续查询相关的日志。&lt;/li&gt;&#xA;&lt;li&gt;很多时候会在单机上部署多实例以便充分利用服务器资源，这时千万不要贪图日志监控或日志查询方便，将多个实例的日志写到同一个日志文件中。如果多个 JVM 往同一个文件里写日志，大约会使性能降低 10%。如果对同一个日志文件有大量的写需求，可以考虑 &lt;strong&gt;拆分日志到不同的文件&lt;/strong&gt;。添加多个 Appender，不同的情况使用不同的 Logger。&lt;/li&gt;&#xA;&lt;li&gt;调用第三方服务时，所有的出参、入参、遇到的异常都是必须记录的，因为 &lt;strong&gt;很难追溯第三方模块发生的问题&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;异常信息应该包括两类信息：案发现场信息和 &lt;strong&gt;异常堆栈信息&lt;/strong&gt;。尽量通过异常的日志能还原当时的情景，比如当时受影响的是哪个用户、传入的变量是什么、处理哪些核心数据引发的异常等等。有些代码在编写时就知道很难被执行到或者 &lt;strong&gt;不希望被执行到&lt;/strong&gt;、以及一些基本不会走到的 else 块，这些地方需要记录下核心日志&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre&gt;&lt;code&gt;logger.error(&amp;#34;inputParams:{} and errorMessage:{}&amp;#34;, 各类参数或者对象 toString(), e.getMessage(), e);&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
