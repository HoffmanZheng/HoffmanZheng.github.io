<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="Chenghao.Zheng">
  
  
  
  <link rel="prev" href="https://nervousorange.github.io/2020/advanced-git/" />
  
  <link rel="canonical" href="https://nervousorange.github.io/2021/database-innodb/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           Database：InnoDB 存储引擎 | 人间一场大梦
       
  </title>
  <meta name="title" content="Database：InnoDB 存储引擎 | 人间一场大梦">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/nervousorange.github.io\/"
    },
    "articleSection" : "posts",
    "name" : "Database：InnoDB 存储引擎",
    "headline" : "Database：InnoDB 存储引擎",
    "description" : "在之前的博客 Database：MySQL 数据库 中笔者已经介绍了自己对于关系型数据库 MySQL 的些许认识，但终觉不够深刻，本篇将结合 《MySQL技术内幕：InnoDB存储引擎》 讲解作为 MySQL 企业级数据库应用的第一存储引擎 InnoDB 的 核心实现和工作机制，主要内容有：缓冲池、线程工作机制、日志文件、锁、事务以及数据的备份与恢复等。\nMySQL 存储引擎 MySQL 数据库区别于其他数据库的最重要的一个特点就是其 插件式的表存储引擎（Pluggable Storage Engines），其提供了一系列标准的管理和服务支持，如 SQL 分析器和优化器等，这些标准与存储引擎本身无关，而存储引擎是底层物理结构的实现，每个存储引擎开发者可以按照自己的意愿来进行开发。 MySQL 数据库的体系结构如下图：\n需要注意的是，存储引擎是 基于表的，而不是数据库。每个存储引擎都有各自的特点，开发者应该根据具体的应用选择适合的存储引擎，以下是一些存储引擎的简单介绍：\nInnoDB 支持事务，行锁，外键，使用 MVCC 获得高并发性，实现了 SQL 的 4 种隔离级别，默认为 REPEATABLE，使用一种被称为 next-key locking 的策略来避免幻读（phantom）现象的产生，聚集索引，按主键顺序，从 MySQL 5.5.8 开始成为 MySQL 默认的存储引擎，众多互联网公司的成功应用已经证明了 InnoDB 存储引擎的高可用性、高性能以及高可扩展性。\nMyISAM 不支持事务，表锁，支持全文索引，在 5.5.8 之前是默认的存储引擎，只缓存索引文件，不缓冲数据文件。\nNDB 集群 存储引擎，数据全部放在内存中，主键查找速度极快，通过添加 NDB 数据存储节点（Data Node）可以线性地提高数据库性能；有一个问题值得注意，那就是 NDB 存储引擎的连接操作 JOIN 是在 MySQL 数据库层完成的，而不是在存储引擎层完成的。这意味着，复杂的连接操作需要巨大的网络开销，因此关联查询速度很慢。\nMemory 数据存放于内存，数据库重启或者发生崩溃，表中的数据都将消失，使用了 哈希索引，只支持表锁，并发性能较差；MySQL 使用 Memory 存储引擎作为 临时表 来存放查询的中间结果集。\nArchive 只支持 INSERT SELECT 操作，支持索引，压缩比例 1：10，非常 适合存储归档数据，如日志信息。使用行锁来实现高并发的插入操作，但并不是事务安全的引擎。",
    "inLanguage" : "en-us",
    "author" : "Chenghao Zheng",
    "creator" : "Chenghao Zheng",
    "publisher": "Chenghao Zheng",
    "accountablePerson" : "Chenghao Zheng",
    "copyrightHolder" : "Chenghao Zheng",
    "copyrightYear" : "2021",
    "datePublished": "2021-01-07 13:19:47 \x2b0100 \x2b0100",
    "dateModified" : "2021-01-07 13:19:47 \x2b0100 \x2b0100",
    "url" : "https:\/\/nervousorange.github.io\/2021\/database-innodb\/",
    "wordCount" : "960",
    "keywords" : [ "Database", "人间一场大梦"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    
        <div class="top-scroll-bar"></div>
    
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://nervousorange.github.io/">人间一场大梦</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
    
        <div class="top-scroll-bar"></div>
    
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://nervousorange.github.io/">人间一场大梦</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Database：InnoDB 存储引擎</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://nervousorange.github.io/" rel="author">Chenghao Zheng</a> with ♥ 
                <span class="post-time">
                on <time datetime=2021-01-07 itemprop="datePublished">January 7, 2021</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="https://nervousorange.github.io/categories/reading-notes/"> Reading notes </a>
                        
                </span>
                 <span class="post-word-count">,960 words</span>
        </div>
    </header>
    <div class="post-content">
        

        
            
        

        
        
     
          
          
          

          
          
          

          <p>在之前的博客 <a href="https://nervousorange.github.io/2020/database-mysql/">Database：MySQL 数据库</a> 中笔者已经介绍了自己对于关系型数据库 MySQL 的些许认识，但终觉不够深刻，本篇将结合 <a href="https://book.douban.com/subject/24708143/">《MySQL技术内幕：InnoDB存储引擎》</a> 讲解作为 MySQL 企业级数据库应用的第一存储引擎 InnoDB 的 <strong>核心实现和工作机制</strong>，主要内容有：缓冲池、线程工作机制、日志文件、锁、事务以及数据的备份与恢复等。</p>
<h3 id="mysql-存储引擎">MySQL 存储引擎</h3>
<p>MySQL 数据库区别于其他数据库的最重要的一个特点就是其 <strong>插件式的表存储引擎</strong>（Pluggable Storage Engines），其提供了一系列标准的管理和服务支持，如 SQL 分析器和优化器等，这些标准与存储引擎本身无关，而存储引擎是底层物理结构的实现，每个存储引擎开发者可以按照自己的意愿来进行开发。 MySQL 数据库的体系结构如下图：</p>
<p><img src="/images/mysql-architecture.png" alt=""></p>
<p>需要注意的是，存储引擎是 <strong>基于表的</strong>，而不是数据库。每个存储引擎都有各自的特点，开发者应该根据具体的应用选择适合的存储引擎，以下是一些存储引擎的简单介绍：</p>
<h4 id="innodb">InnoDB</h4>
<p>支持事务，行锁，外键，使用 MVCC 获得高并发性，实现了 SQL 的 4 种隔离级别，默认为 REPEATABLE，使用一种被称为 <code>next-key locking</code> 的策略来避免幻读（phantom）现象的产生，聚集索引，按主键顺序，从 MySQL 5.5.8 开始成为 MySQL 默认的存储引擎，众多互联网公司的成功应用已经证明了 InnoDB 存储引擎的高可用性、高性能以及高可扩展性。</p>
<h4 id="myisam">MyISAM</h4>
<p>不支持事务，表锁，支持全文索引，在 5.5.8 之前是默认的存储引擎，只缓存索引文件，不缓冲数据文件。</p>
<h4 id="ndb">NDB</h4>
<p><strong>集群</strong> 存储引擎，数据全部放在内存中，主键查找速度极快，通过添加 NDB 数据存储节点（Data Node）可以线性地提高数据库性能；有一个问题值得注意，那就是 NDB 存储引擎的连接操作 JOIN 是在 MySQL 数据库层完成的，而不是在存储引擎层完成的。这意味着，复杂的连接操作需要巨大的网络开销，因此关联查询速度很慢。</p>
<h4 id="memory">Memory</h4>
<p>数据存放于内存，数据库重启或者发生崩溃，表中的数据都将消失，使用了 <strong>哈希索引</strong>，只支持表锁，并发性能较差；MySQL 使用 Memory 存储引擎作为 <strong>临时表</strong> 来存放查询的中间结果集。</p>
<h4 id="archive">Archive</h4>
<p>只支持 INSERT SELECT 操作，支持索引，压缩比例 1：10，非常 <strong>适合存储归档数据</strong>，如日志信息。使用行锁来实现高并发的插入操作，但并不是事务安全的引擎。</p>
<h4 id="federated">Federated</h4>
<p>不存放数据，它只是指向一台远程 MySQL 数据库服务器上的表，类似于 SQL Server 的链接服务器和 Oracle 的透明网关，但只支持 MySQL 的数据库表。</p>
<h4 id="maria">Maria</h4>
<p>由 MySQL 创始人之一的 Micheal Widenius 开发，可以看做是 MyISAM 的后续版本。特点是支持缓存数据和索引文件，应用了行锁设计，提供了MVCC功能，支持事务和非事务安全的选项，以及更好的 BLOB 字符类型的处理性能。</p>
<h4 id="mysql-的临时表">MySQL 的临时表</h4>
<p>MySQL 数据库使用 Memory 存储引擎作为临时表来存放 <strong>查询的中间结果集</strong>。如果中间结果集大于 Memory 存储引擎表的容量设置，又或者中间结果中含有 TEXT 或 BLOB 列类型字段，则 MySQL 数据库会把其转换到 MyISAM 存储引擎表而 <strong>放到磁盘中</strong>。之前提到过 MyISAM 不缓存数据文件，因此这时产生的临时表的性能对于查询会有损失。</p>
<h3 id="innodb-存储引擎">InnoDB 存储引擎</h3>
<p>早期的 InnoDB 的版本随着 MySQL 数据库的更新而更新，从 5.1 版本开始，MySQL 允许存储引擎开发商以动态方式加载引擎，官方称 InnoDB Plugin，其各个版本的功能升级如下表：</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>老版本 InnoDB</td>
<td>支持 ACID、行锁设计、MVCC</td>
</tr>
<tr>
<td>InnoDB 1.0.x（MySQL 5.1）</td>
<td>增加了 compress 和 dynamic 页格式</td>
</tr>
<tr>
<td>InnoDB 1.1.x（MySQL 5.5）</td>
<td>增加了 Linux AIO、多回滚段</td>
</tr>
<tr>
<td>InnoDB 1.2.x（MySQL 5.6）</td>
<td>增加了全文索引支持、在线索引添加</td>
</tr>
</tbody>
</table>
<p>下图简单展示了 InnoDB 存储引擎的体系架构，可以看到 InnoDB 主要由一个大的内存池和多个后台线程组成</p>
<p><img src="/images/InnoDB-architecture.jpg" alt=""></p>
<h4 id="缓冲池">缓冲池</h4>
<p>InnoDB 是 <strong>基于磁盘</strong> 的数据库系统（Disk-base Database），由于 CPU 速度与磁盘速度之间的鸿沟，基于磁盘的数据库系统通常使用缓冲池，通过 <strong>内存的速度</strong> 来弥补磁盘速度较慢对性能的影响。查询时先判断该页是否在缓冲池中，如果在则称该页在缓冲池被命中，直接读取该页，否则读取磁盘上的页；修改时先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。为了提高数据库的整体性能，页从缓冲区刷新回磁盘的操作 <strong>并不是在每次页发生更新时触发</strong>，而是通过一种称为 <code>Checkpoint</code> 的机制刷新回磁盘。</p>
<p>可见缓冲池的大小直接影响着数据库的整体性能：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">show</span> variables <span style="color:#66d9ef">like</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">innodb_buffer_pool_size</span><span style="color:#e6db74">&#39;</span>;

Variable_name          <span style="color:#f92672">|</span>Value    <span style="color:#f92672">|</span>
<span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">|</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">|</span>
innodb_buffer_pool_size<span style="color:#f92672">|</span><span style="color:#ae81ff">134217728</span><span style="color:#f92672">|</span>
</code></pre></div><p>具体来看，缓冲池中缓存的数据页类型有：索引页、数据页、undo 页、插入缓冲、自适应哈希索引、InnoDB 存储的锁信息、数据字典信息等。</p>
<p><img src="/images/InnoDB-buffer-pool.jpg" alt=""></p>
<ul>
<li>LRU</li>
</ul>
<p>数据库中的缓冲池是通过 LRU（Lastest Recent Used，最近最少使用）算法来管理的，即最频繁使用的页在 LRU 列表的前端，而最少使用的页在 LRU 列表的尾端。当缓冲池不能存放新读取到的页时，将 <strong>首先释放 LRU 列表中尾端的页</strong>。</p>
<p>InnoDB 对传统的 LRU 算法做了一些优化，新增了 <code>midpoint insertion strategy</code> 算法，新读取到的页并不是直接放入到 LRU 列表的首部，而是放入到 LRU 列表的 midpoint 位置，midpoint 位置由参数 <code>innodb_old_blocks_pct</code> 控制，默认位置在 LRU 列表长度的 5/8 （37%）处。midpoint 之后的列表称为 old 列表，之前的列表称为 new 列表，可以简单理解为 new 列表中的页都是最为活跃的热点数据。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">show</span> variables <span style="color:#66d9ef">like</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">innodb_old_blocks_pct</span><span style="color:#e6db74">&#39;</span>

Variable_name        <span style="color:#f92672">|</span>Value<span style="color:#f92672">|</span>
<span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">|</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">|</span>
innodb_old_blocks_pct<span style="color:#f92672">|</span><span style="color:#ae81ff">37</span>   <span style="color:#f92672">|</span>
</code></pre></div><p>若是直接将读取到的页放入到 LRU 的首部，那么某些 SQL 操作（索引或者数据的扫描操作）可能会使缓冲池中的页被刷新出，从而影响缓冲池的效率。如果页被放入 LRU 列表的首部，可能将所需要的 <strong>热点数据页</strong> 从 LRU 列表中移除，为此 InnoDB 引入了 <code>innodb_old_blocks_time</code>，表示页读取到 mid 位置后需要等待多久才会被加入到 LRU 列表的热端。当页从 LRU 列表的 old 部分加入到 new 部分时，称此操作为 <code>page made young</code>，因设置了 innodb_old_blocks_time 导致页没有从 old 移动到 new 部分的操作称为 page_not_made_young</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">show engine innodb status;

----------------------
BUFFER POOL AND MEMORY
----------------------
Total memory allocated 137363456; in additional pool allocated 0
Dictionary memory allocated 10088749
Buffer pool size   <span style="color:#ae81ff">8191</span>     // 缓冲池中页的数量，除了 LRU 还可能有自适应哈希索引、插入缓冲、锁信息等
Free buffers       <span style="color:#ae81ff">0</span>        
Database pages     <span style="color:#ae81ff">7545</span>     // LRU 列表中页的数量
Old database pages 2765
Modified db pages  <span style="color:#ae81ff">0</span>        // 脏页的数量
Pending reads 0
Pending writes: LRU 0, flush list 1, single page 0
Pages made young 1115739907, not young <span style="color:#ae81ff">0</span>     // LRU 列表中页移动到前端的次数
0.00 youngs/s, 0.00 non-youngs/s
Pages read 592119280, created 299958, written 7230109
0.00 reads/s, 0.00 creates/s, 1.75 writes/s
Buffer pool hit rate <span style="color:#ae81ff">1000</span> / 1000, young-making rate <span style="color:#ae81ff">0</span> / <span style="color:#ae81ff">1000</span> not <span style="color:#ae81ff">0</span> / <span style="color:#ae81ff">1000</span>    // 缓冲池的命中率，若小于 95% 需要观察 LRU 列表是否被污染
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
LRU len: 7545, unzip_LRU len: <span style="color:#ae81ff">0</span>              // LRU 列表中页的数量，unzip LRU 中页的数量
I/O sum<span style="color:#f92672">[</span>4<span style="color:#f92672">]</span>:cur<span style="color:#f92672">[</span>7<span style="color:#f92672">]</span>, unzip sum<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>:cur<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>
--------------
</code></pre></div><p>在 LRU 列表中的页被修改后，称该页为 <strong>脏页</strong>（dirty page），即缓冲池中的页和磁盘上的页的数据产生了不一致，脏页既存在于 LRU 列表中，来管理页的可用性，也存在于 Flush 列表中，通过 checkpoint 机制刷新回磁盘。</p>
<ul>
<li>Checkpoint</li>
</ul>
<p>缓冲池协调了 CPU 速度与磁盘速度的鸿沟，而脏页的产生使得数据库需要将新版本的页从缓冲池刷新到磁盘。这里就出现了几个矛盾点：</p>
<ol>
<li>若每次一个页发生变化就刷新到磁盘，开销会非常大。</li>
<li>刷新过程中发生了宕机，会导致数据丢失。
当前的事务数据库系统普遍采用了 <code>Write Ahead Log</code> 策略，即当事务提交时，写先 <strong>重做日志</strong> redo log，再修改页。当发生宕机导致数据丢失时，通过重做日志来完成数据的恢复，这也是事务 ACID 中 D（Durability 持久性）的要求。</li>
</ol>
<p>即使缓冲池足够大（可以缓存数据库中所有的数据）并且重做日志可以无限增大，宕机后数据库重新应用重做日志的 <strong>数据恢复时间</strong> 也会非常久，因此 checkpoint 技术解决了以下三个问题：</p>
<ol>
<li>缩短数据库的恢复时间（宕机后只需对 checkpoint 后的重做日志进行恢复，这样就大大缩短了恢复时间）</li>
<li>缓冲池不够用时，刷新脏页到磁盘</li>
<li>重做日志不可用时，刷新脏页（重做日志缓冲 redo log buffer <code>innodb_log_buffer_size</code> 一般不需要设置得很大（默认 8 MB），因为每一秒钟都会将重做日志缓冲刷新到日志文件；磁盘中的重做日志设计成循环使用的，不再需要的重做日志可以被重复使用）</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">show engine innodb status;

---
LOG
---
Log sequence number <span style="color:#ae81ff">49109625455</span>      // 重做日志的 LSN
Log flushed up to   <span style="color:#ae81ff">49109625455</span>      // FLUSH 列表的 LSN
Last checkpoint at  <span style="color:#ae81ff">49109625197</span>      // 已经刷新回磁盘最新页的 LSN
<span style="color:#ae81ff">0</span> pending log writes, <span style="color:#ae81ff">0</span> pending chkp writes
<span style="color:#ae81ff">6626161</span> log i/o<span style="color:#e6db74">&#39;s done, 0.08 log i/o&#39;</span>s/second
----------------------
</code></pre></div><p>InnoDB 通过 LSN Log Sequence Number 来标记版本，每个页有 LSN，重做日志中也有 LSN，Checkpoint 也有 LSN。InnoDB 有两种 Checkpoint 机制，在数据库关闭时将所有脏页刷新回磁盘的 <code>Sharp Checkpoint</code> （运行时使用影响数据库的可用性）和引擎内部使用的 <code>Fuzzy Checkpoint</code>，在以下几种情况下可能会发生 Fuzzy Checkpoint：</p>
<ol>
<li>Master Thread Checkpoint：每秒/每十秒以异步方式刷新一定比例的脏页，不阻塞用户查询线程</li>
<li>FLUSH_LRU_LIST Checkpoint：检查 LRU 列表是否有 100 个可用空闲页（阻塞用户查询线程），否就刷新 LRU 尾端的脏页，从 MySQL 5.6 开始，这个检查被单独放在了 Page Cleaner 线程中，可以通过 <code>innodb_lru_scan_depth</code> 来控制 LRU 列表中可用页的数量</li>
<li>Async/Sync Flush Checkpoint：重做日志不可用时，强制刷新一些脏页回磁盘，保证重做日志的循环使用的可用性。从 MySQL 5.6 开始这个检查也被放入了 Page Cleaner 线程中来避免对用户查询线程的阻塞。</li>
<li>Dirty Page too much Checkpoint：为保证缓冲池中有足够可用的页，当脏页数量比例超过 <code>innodb_max_dirty_pages-pct</code> （MySQL 5.5 及之后版本，默认为 75）时进行刷新操作。</li>
</ol>
<h4 id="后台线程">后台线程</h4>
<p>InnoDB 是多线程的模型，后台有多个不同的后台线程，负责处理不同的任务：</p>
<ul>
<li>Master Thread</li>
</ul>
<p>核心的后台线程，完成 InnoDB 主要工作，负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲、UNDO 页的回收等。</p>
<p><strong>InnoDB 1.0.x（MySQL 5.1）</strong> 版本之前的 Master Thread</p>
<p>Master Thread 内部由多个循环组合，大多数的操作在主循环中，其中有两大部分的操作 —— 每秒钟的操作和每十秒的操作，其行为伪代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">master_thread</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">goto</span> loop<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
loop:
<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 10<span style="color:#f92672">;</span> i<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>               <span style="color:#75715e">// ---------- 每秒钟的操作 -------------
</span><span style="color:#75715e"></span>  thread_sleep<span style="color:#f92672">(</span>1<span style="color:#f92672">)</span>  <span style="color:#75715e">// sleep 1 second
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">do</span> log buffer flush to disk                <span style="color:#75715e">// 刷新日志缓冲到磁盘，即使这个事务还没提交
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>last_one_second_ios <span style="color:#f92672">&lt;</span> 5<span style="color:#f92672">)</span>              
    <span style="color:#66d9ef">do</span> merge at most 5 insert buffer         <span style="color:#75715e">// I/O 压力很小时（小于每秒 5 次），合并至多 5 个插入缓冲
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>buf_get_modified_ratio_pct <span style="color:#f92672">&gt;</span> innodb_max_dirty_pages_pct<span style="color:#f92672">)</span>
    <span style="color:#66d9ef">do</span> buffer pool flush 100 dirty page      <span style="color:#75715e">// 当前缓冲池脏页比例过大时，刷新 100 个脏页到磁盘
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>no user activity<span style="color:#f92672">)</span> 
    <span style="color:#66d9ef">goto</span> backgroud loop                      <span style="color:#75715e">// 如果当前没有用户活动，则切换到 backgroud loop
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
                                             <span style="color:#75715e">// ---------- 每十秒钟的操作 -------------
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>last_ten_second_ios <span style="color:#f92672">&lt;</span> 200<span style="color:#f92672">)</span> 
  <span style="color:#66d9ef">do</span> buffer pool flush 100 dirty page        <span style="color:#75715e">// I/O 压力较小时（过去 10 秒小于 200 次），刷新 100 个脏页到磁盘
</span><span style="color:#75715e"></span><span style="color:#66d9ef">do</span> merge at most 5 insert buffer             <span style="color:#75715e">// 合并至多 5 个插入缓冲
</span><span style="color:#75715e"></span><span style="color:#66d9ef">do</span> log buffer flush to disk                  <span style="color:#75715e">// 将日志缓冲刷新到磁盘
</span><span style="color:#75715e"></span><span style="color:#66d9ef">do</span> full purge                                <span style="color:#75715e">// 删除无用的 Undo 页
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>buf_get_modified_ratio_pct <span style="color:#f92672">&gt;</span> 70<span style="color:#f92672">%</span><span style="color:#f92672">)</span>
  <span style="color:#66d9ef">do</span> buffer pool flush 100 dirty page        <span style="color:#75715e">// 如果缓冲池脏页比例过大，刷新 100 个脏页，否则刷新 10 个脏页
</span><span style="color:#75715e"></span><span style="color:#66d9ef">else</span>
  buffer pool flush 10 dirty page
<span style="color:#66d9ef">goto</span> loop
backgroud loop<span style="color:#f92672">:</span>
  <span style="color:#66d9ef">do</span> something                               <span style="color:#75715e">// 数据库空闲或者关闭时会被切换到 backgroud loop
</span><span style="color:#75715e"></span><span style="color:#66d9ef">goto</span> loop<span style="color:#f92672">:</span>
</code></pre></div><p><strong>InnoDB 1.2.x（MySQL 5.6）</strong> 版本之前的 Master Thread</p>
<ul>
<li>I/O Thread</li>
</ul>
<p>异步 I/O 线程来处理写 I/O 请求，以极大地提高数据库的性能。可以通过 <code>show engine innodb status</code> 来观察 InnoDB 中的 IO Thread，默认为 1 个 insert buffer thread，1 个 log thread，4 个 read thread 和 4 个 write thread，可以使用 <code>innodb_read_io_threads</code> 和 <code>innodb_write_io_threads</code> 参数进行设置。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">show</span> <span style="color:#66d9ef">engine</span> innodb status;

<span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#75715e">--
</span><span style="color:#75715e">FILE I/O
</span><span style="color:#75715e"></span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#75715e">--
</span><span style="color:#75715e">I/O thread 0 state: waiting for completed aio requests (insert buffer thread)
</span><span style="color:#75715e"></span>I<span style="color:#f92672">/</span>O thread <span style="color:#ae81ff">1</span> state: waiting <span style="color:#66d9ef">for</span> completed aio <span style="color:#a6e22e">requests</span> (log thread)
I<span style="color:#f92672">/</span>O thread <span style="color:#ae81ff">2</span> state: waiting <span style="color:#66d9ef">for</span> completed aio <span style="color:#a6e22e">requests</span> (<span style="color:#66d9ef">read</span> thread)
I<span style="color:#f92672">/</span>O thread <span style="color:#ae81ff">3</span> state: waiting <span style="color:#66d9ef">for</span> completed aio <span style="color:#a6e22e">requests</span> (<span style="color:#66d9ef">read</span> thread)
I<span style="color:#f92672">/</span>O thread <span style="color:#ae81ff">4</span> state: waiting <span style="color:#66d9ef">for</span> completed aio <span style="color:#a6e22e">requests</span> (<span style="color:#66d9ef">read</span> thread)
I<span style="color:#f92672">/</span>O thread <span style="color:#ae81ff">5</span> state: waiting <span style="color:#66d9ef">for</span> completed aio <span style="color:#a6e22e">requests</span> (<span style="color:#66d9ef">read</span> thread)
I<span style="color:#f92672">/</span>O thread <span style="color:#ae81ff">6</span> state: waiting <span style="color:#66d9ef">for</span> completed aio <span style="color:#a6e22e">requests</span> (<span style="color:#66d9ef">write</span> thread)
I<span style="color:#f92672">/</span>O thread <span style="color:#ae81ff">7</span> state: waiting <span style="color:#66d9ef">for</span> completed aio <span style="color:#a6e22e">requests</span> (<span style="color:#66d9ef">write</span> thread)
I<span style="color:#f92672">/</span>O thread <span style="color:#ae81ff">8</span> state: waiting <span style="color:#66d9ef">for</span> completed aio <span style="color:#a6e22e">requests</span> (<span style="color:#66d9ef">write</span> thread)
I<span style="color:#f92672">/</span>O thread <span style="color:#ae81ff">9</span> state: waiting <span style="color:#66d9ef">for</span> completed aio <span style="color:#a6e22e">requests</span> (<span style="color:#66d9ef">write</span> thread)
</code></pre></div><ul>
<li>Purge Thread</li>
</ul>
<p>在事务提交后，<strong>回收已经使用并分配的 undo 页</strong>。在 InnoDB 1.1 版本之前，purge 操作仅在 Master Thread 中完成，1.1 版本开始 purge 操作可以独立到单独的线程中进行，1.2 版本开始支持多个 Purge Thread 来加快 undo 页的回收，以此来减轻 Master Thread 的工作，从而提高 CPU 的使用率以及提升存储引擎的性能。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">show</span> variables <span style="color:#66d9ef">like</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">innodb_purge_threads</span><span style="color:#e6db74">&#39;</span>;

Variable_name       <span style="color:#f92672">|</span>Value<span style="color:#f92672">|</span>
<span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">|</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">|</span>
innodb_purge_threads<span style="color:#f92672">|</span><span style="color:#ae81ff">4</span>    <span style="color:#f92672">|</span>
</code></pre></div><ul>
<li>Page Cleaner Thread</li>
</ul>
<p>InnoDB 1.2.x 引入的，将 <strong>脏页刷新</strong> 操作放入单独的线程来完成，减轻原 Master Thread 的工作及对于用户查询线程的阻塞， 进一步提高 InnoDB 存储引擎的性能。</p>
<h3 id="日志文件">日志文件</h3>
<h3 id="锁">锁</h3>
<h3 id="事务">事务</h3>
<h3 id="备份与恢复">备份与恢复</h3>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>Chenghao.Zheng </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://nervousorange.github.io/2021/database-innodb/>https://nervousorange.github.io/2021/database-innodb/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a> 进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://nervousorange.github.io/tags/database/">
                    #Database</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://nervousorange.github.io/">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://nervousorange.github.io/2020/advanced-git/" class="prev" rel="prev" title="Git 进阶与 GitHub 协作详解"><i class="iconfont icon-left"></i>&nbsp;Git 进阶与 GitHub 协作详解</a>
         
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2019 - 2021</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://nervousorange.github.io/">Chenghao.Zheng</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>













    
     <link href="//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css" rel="stylesheet">  
      
     <script src="/js/vendor_gallery.min.js" async="" ></script>
    
  



     </div>
  </body>
</html>
